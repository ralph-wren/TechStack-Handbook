# Clickhouse 命令文档

## 目录
- [Clickhouse 命令文档](#clickhouse-命令文档)
  - [目录](#目录)
  - [设置与配置](#设置与配置)
  - [数据操作](#数据操作)
    - [插入数据](#插入数据)
    - [查询数据](#查询数据)
    - [Bitmap操作](#bitmap操作)
      - [基本操作](#基本操作)
      - [聚合操作](#聚合操作)
      - [转换操作](#转换操作)
      - [性能优化](#性能优化)
    - [数组操作](#数组操作)
    - [字符串操作](#字符串操作)
  - [表管理](#表管理)
    - [表分区与大小](#表分区与大小)
    - [表优化](#表优化)
  - [系统管理](#系统管理)
    - [查询监控](#查询监控)
    - [性能监控](#性能监控)
  - [特性对比](#特性对比)
    - [ORDER BY vs PRIMARY KEY](#order-by-vs-primary-key)
  - [集群配置](#集群配置)

## 设置与配置
```sql
-- 设置最大线程数和内存使用
SETTINGS max_threads=5, max_memory_usage=41474836480;
```

## 数据操作

### 插入数据
```sql
-- 基本插入
INSERT INTO table_name (column1, column2) VALUES (value1, value2);

-- 从HDFS插入数据
INSERT INTO glab_gid_info.appinfo_v2 
SELECT * FROM hdfs('hdfs://path/to/file', 'Parquet');

-- 使用命令行工具插入
clickhouse-client -m --port 9000 --user default --database glab_gid_info --password xxxxx \
 --host hzxs-ga-ck-xs6 --max_insert_block_size=536970912 --max_insert_threads=4 \
 -q 'INSERT INTO table_name SELECT * FROM hdfs("path/to/file", "Parquet");'
```

### 查询数据
```sql
-- 基本查询
SELECT * FROM table_name WHERE condition;

-- 抽样查询
SELECT * FROM table_name WHERE (cityHash64(essid) % 100000) = 0;

-- WITH子句使用
WITH (SELECT AVG(value) FROM some_table) AS avg_value
SELECT id, value, avg_value
FROM some_table
WHERE value > avg_value;
```

### Bitmap操作

#### 基本操作
```sql
-- 创建bitmap
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS bitmap;

-- 添加元素
SELECT bitmapAdd(bitmapBuild([1,2,3]), 4) AS bitmap;

-- 删除元素
SELECT bitmapSubtract(bitmapBuild([1,2,3]), 2) AS bitmap;

-- 判断元素是否存在
SELECT bitmapContains(bitmapBuild([1,2,3]), 2) AS exists;

-- 获取基数（元素个数）
SELECT bitmapCardinality(bitmap_column) FROM table;
```

#### 聚合操作
```sql
-- OR操作（并集）
SELECT 
    bitmapOr(bitmap1, bitmap2) AS union_bitmap,
    bitmapOrCardinality(bitmap1, bitmap2) AS union_count
FROM table;

-- AND操作（交集）
SELECT 
    bitmapAnd(bitmap1, bitmap2) AS intersect_bitmap,
    bitmapAndCardinality(bitmap1, bitmap2) AS intersect_count
FROM table;

-- XOR操作（异或）
SELECT 
    bitmapXor(bitmap1, bitmap2) AS xor_bitmap,
    bitmapXorCardinality(bitmap1, bitmap2) AS xor_count
FROM table;

-- 聚合OR操作
SELECT bitmapOrState(bitmap_column)
FROM table
GROUP BY group_column;

-- 聚合AND操作
SELECT bitmapAndState(bitmap_column)
FROM table
GROUP BY group_column;
```

#### 转换操作
```sql
-- Bitmap转数组
SELECT bitmapToArray(bitmap_column) AS array;

-- 数组转Bitmap
SELECT bitmapBuild([1, 2, 3]) AS bitmap;

-- 获取Bitmap中的指定范围元素
SELECT arraySlice(bitmapToArray(bitmap_column), 1, 5) AS first_five;

-- 实际应用示例
SELECT 
    tag,
    bitmapCardinality(gid_index_bitmap) AS user_count,
    arraySlice(bitmapToArray(gid_index_bitmap), 1, 10) AS sample_users
FROM tag_bitmap 
WHERE tag_md5 = lower(hex(MD5('tag_name')));

-- Bitmap分段统计示例
SELECT 
    bitmap_segment_number,
    bitmapCardinality(gid_index_bitmap) AS segment_count,
    formatReadableSize(length(gid_index_bitmap)) AS bitmap_size
FROM tag_bitmap 
WHERE tag_md5 = lower(hex(MD5('tag_name')))
ORDER BY bitmap_segment_number;
```

#### 性能优化
```sql
-- 使用 bitmapOrCardinality 替代 bitmapCardinality(bitmapOr())
SELECT bitmapOrCardinality(
    bitmapBuild([1, 2, 3]),
    bitmapBuild([3, 4, 5])
) AS union_count;

-- 批量处理时使用State聚合函数
SELECT 
    tag,
    bitmapCardinality(groupBitmapOrState(gid_index_bitmap)) AS total_users
FROM tag_bitmap
WHERE tag IN ('tag1', 'tag2', 'tag3')
GROUP BY tag;

-- 大规模数据处理优化
SELECT 
    tag,
    bitmapCardinality(gid_index_bitmap) AS user_count,
    formatReadableSize(length(gid_index_bitmap)) AS bitmap_size
FROM tag_bitmap 
WHERE tag_md5 IN (
    SELECT lower(hex(MD5(tag))) 
    FROM (SELECT ['tag1', 'tag2', 'tag3'] AS tags) 
    ARRAY JOIN tags AS tag
)
SETTINGS max_threads = 4;
```

### 数组操作
```sql
-- 数组转换
SELECT arrayJoin([1, 2, 3]) AS value;

-- 数组去重
SELECT arrayDistinct([1, 2, 2, 3]);

-- 数组合并
SELECT arrayConcat([1, 2], [3, 4]);

-- 数组映射
SELECT arrayMap(x -> x * 2, [1, 2, 3, 4, 5]) AS result;

-- 数组过滤
SELECT arrayFilter(x -> x > 3, [1, 2, 3, 4, 5]);

-- 数组聚合
SELECT groupUniqArray(column) -- 去重聚合
SELECT groupArray(column)     -- 不去重聚合

-- 数组打平
SELECT arrayFlatten(groupArray(values));

-- 数组添加元素
SELECT arrayPushBack([1, 2, 3], 4);
```

### 字符串操作
```sql
-- 字符串分割
SELECT splitByChar(',', 'a,b,c');

-- 字符串匹配
SELECT match('string', 'pattern');
SELECT match('aftvf', 'a');

-- 字符串包含多个模式
SELECT * FROM table WHERE match(column_name, 'MG|XZ');
```

## 表管理

### 表分区与大小
```sql
-- 查看表大小
SELECT 
    database,
    table,
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
WHERE database NOT IN ('test', 'default')
GROUP BY database, table
ORDER BY sum(data_compressed_bytes) DESC;

-- 查看表字段大小
SELECT 
    column AS `字段名`,
    any(type) AS `类型`,
    formatReadableSize(sum(column_data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(column_data_compressed_bytes)) AS `压缩大小`,
    sum(rows) AS `行数`
FROM system.parts_columns
WHERE database = 'database_name' AND table = 'table_name'
GROUP BY column
ORDER BY sum(column_data_uncompressed_bytes) DESC;
```

### 表优化
```sql
-- 优化表
OPTIMIZE TABLE table_name FINAL;
OPTIMIZE TABLE table_name PARTITION partition_name FINAL;

-- 查看待合并分区
SELECT 
    partition_num,
    unmerged_partition_num,
    files_num 
FROM (
    SELECT 1 flag, count() unmerged_partition_num 
    FROM (
        SELECT partition, count() counts
        FROM system.parts 
        WHERE database = 'database_name' 
        AND table = 'table_name' 
        AND active = 1
        GROUP BY partition 
        HAVING counts > 1
    )
) t1 
JOIN (
    SELECT 
        1 flag,
        count(DISTINCT partition) partition_num,
        count() files_num
    FROM system.parts 
    WHERE database = 'database_name' 
    AND table = 'table_name' 
    AND active = 1
) t2 ON t1.flag = t2.flag;
```

## 系统管理

### 查询监控
```sql
-- 查看正在执行的查询
SELECT 
    query_id,
    substr(query, 1, 50),
    elapsed,
    read_rows,
    total_rows_approx,
    formatReadableSize(memory_usage)
FROM system.processes
WHERE query NOT LIKE '%SELECT query%'
ORDER BY elapsed DESC;

-- 查看历史执行SQL
SELECT 
    event_time,
    query_duration_ms/1000 AS `耗时(秒)`,
    read_rows AS `读取行数`,
    result_rows AS `返回行数`,
    formatReadableSize(result_bytes) AS `返回数据大小`,
    formatReadableSize(memory_usage) AS `内存使用`,
    substr(query, 1, 40),
    databases,
    tables
FROM system.query_log
WHERE query NOT LIKE '%*%'
AND event_time >= '2025-01-21 19:00:00'
AND query_kind = 'Select'
ORDER BY query_duration_ms DESC
LIMIT 10;
```

### 性能监控
```sql
-- 获取内存使用情况
SELECT * FROM system.metrics WHERE metric LIKE 'Memory.%';

-- 查询常驻内存大小
SELECT value FROM system.metrics WHERE metric = 'Memory.Resident';

-- 查看正在进行的合并
SELECT 
    database,
    table,
    num_parts,
    formatReadableSize(total_size_bytes_compressed) AS total_size_bytes_compressed,
    total_size_marks,
    rows_read,
    rows_written,
    columns_written,
    memory_usage
FROM system.merges;
```

## 特性对比

### ORDER BY vs PRIMARY KEY

特性 | ORDER BY | PRIMARY KEY
-|-|-
定义位置 | 必须在建表时定义 | 可选，通常与 ORDER BY 一起定义
控制数据物理存储顺序 | 是 | 否
作用 | 决定数据存储的物理排序顺序，影响压缩效率 | 用于加速查询，生成稀疏索引
关系 | PRIMARY KEY 是 ORDER BY 的一个子集或相同 | PRIMARY KEY 的字段必须在 ORDER BY 字段中
影响范围查询性能 | 是，数据按顺序存储能加快范围查询 | 是，通过索引跳表可以加速范围查询
去重功能 | 无 | 在特定引擎下可以（如 ReplacingMergeTree）

## 集群配置

```text
single 7-12   172.xx.69.206-211   bi
batch  1-6    172.xx.69.199-204   jm
