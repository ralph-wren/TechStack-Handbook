# Python 完整技术指南

## 目录
- [Python 完整技术指南](#python-完整技术指南)
  - [目录](#目录)
  - [1. Python 语言基础](#1-python-语言基础)
    - [1.1 Python 概述](#11-python-概述)
      - [1.1.1 Python 特点与优势](#111-python-特点与优势)
      - [1.1.2 Python 解释器架构](#112-python-解释器架构)
    - [1.2 数据类型深度解析](#12-数据类型深度解析)
      - [1.2.1 内置数据类型体系](#121-内置数据类型体系)
      - [1.2.2 数据类型详解与性能特性](#122-数据类型详解与性能特性)
    - [1.3 控制流与逻辑结构](#13-控制流与逻辑结构)
      - [1.3.1 条件控制的高级用法](#131-条件控制的高级用法)
      - [1.3.2 循环控制的高级技巧](#132-循环控制的高级技巧)
    - [1.4 函数与作用域](#14-函数与作用域)
      - [1.4.1 函数参数的高级特性](#141-函数参数的高级特性)
      - [1.4.2 作用域与LEGB规则](#142-作用域与legb规则)
    - [1.5 模块与包管理](#15-模块与包管理)
      - [1.5.1 模块导入机制深度解析](#151-模块导入机制深度解析)
      - [1.5.2 包管理最佳实践](#152-包管理最佳实践)
  - [2. 面向对象编程](#2-面向对象编程)
    - [2.1 类与对象](#21-类与对象)
      - [2.1.1 类的定义与实例化](#211-类的定义与实例化)
      - [2.1.2 属性访问控制](#212-属性访问控制)
    - [2.2 继承与多态](#22-继承与多态)
      - [2.2.1 单继承与方法重写](#221-单继承与方法重写)
      - [2.2.2 多重继承与MRO](#222-多重继承与mro)
    - [2.3 特殊方法与运算符重载](#23-特殊方法与运算符重载)
    - [2.4 属性与描述符](#24-属性与描述符)
      - [2.4.1 属性装饰器](#241-属性装饰器)
      - [2.4.2 描述符协议](#242-描述符协议)
  - [Python 高级特性](#python-高级特性)
    - [装饰器](#装饰器)
  - [4. 内存管理与性能优化](#4-内存管理与性能优化)
    - [4.1 Python 内存模型](#41-python-内存模型)
      - [4.1.1 对象内存结构](#411-对象内存结构)
    - [4.2 垃圾回收机制](#42-垃圾回收机制)
    - [4.3 性能分析与优化](#43-性能分析与优化)
  - [环境与工具](#环境与工具)
    - [搭建环境](#搭建环境)
    - [包管理工具](#包管理工具)
    - [虚拟环境](#虚拟环境)
    - [常用开发工具](#常用开发工具)
  - [数据处理与分析](#数据处理与分析)
    - [NumPy 基础](#numpy-基础)
    - [Pandas 数据处理](#pandas-数据处理)
      - [数据结构与创建](#数据结构与创建)
      - [数据读取与写入](#数据读取与写入)
    - [Matplotlib 数据可视化](#matplotlib-数据可视化)
      - [基础绘图](#基础绘图)
      - [图形样式与美化](#图形样式与美化)
      - [多子图与布局](#多子图与布局)
      - [实战案例](#实战案例)
    - [Bokeh 交互式可视化](#bokeh-交互式可视化)
      - [Bokeh 基础](#bokeh-基础)
      - [基本图表类型](#基本图表类型)
      - [交互式功能](#交互式功能)
      - [布局与组合](#布局与组合)
      - [Pandas-Bokeh 集成](#pandas-bokeh-集成)
      - [高级应用](#高级应用)
- [获取一只股票方法](#获取一只股票方法)
- [根据股票中文名称获取股票行情信息](#根据股票中文名称获取股票行情信息)

## 1. Python 语言基础

### 1.1 Python 概述

#### 1.1.1 Python 特点与优势

**Python核心特点**：
- **简洁优雅**：语法简单，代码可读性强
- **动态类型**：运行时确定变量类型
- **解释执行**：无需编译，开发效率高
- **丰富生态**：拥有庞大的第三方库生态
- **跨平台**：支持Windows、Linux、macOS

**Python应用领域**：

| 领域 | 主要框架/库 | 应用场景 |
|------|-------------|----------|
| **Web开发** | Django、Flask、FastAPI | 网站、API服务 |
| **数据科学** | NumPy、Pandas、Matplotlib | 数据分析、可视化 |
| **机器学习** | TensorFlow、PyTorch、Scikit-learn | AI模型开发 |
| **自动化** | Selenium、Beautiful Soup | 爬虫、自动化测试 |
| **DevOps** | Ansible、SaltStack | 运维自动化 |

#### 1.1.2 Python 解释器架构

```mermaid
graph TB
    subgraph "Python代码执行流程"
        SOURCE[Python源代码<br/>.py文件]
        LEXER[词法分析器<br/>Lexer]
        PARSER[语法分析器<br/>Parser]
        AST[抽象语法树<br/>AST]
        COMPILER[字节码编译器<br/>Compiler]
        BYTECODE[字节码<br/>.pyc文件]
        PVM[Python虚拟机<br/>PVM]
        RESULT[执行结果]
    end
    
    SOURCE --> LEXER
    LEXER --> PARSER
    PARSER --> AST
    AST --> COMPILER
    COMPILER --> BYTECODE
    BYTECODE --> PVM
    PVM --> RESULT
```

**CPython执行原理**：
1. **词法分析**：将源代码分解为Token
2. **语法分析**：构建抽象语法树(AST)
3. **字节码编译**：AST编译为字节码
4. **虚拟机执行**：PVM解释执行字节码

### 1.2 数据类型深度解析

#### 1.2.1 内置数据类型体系

```mermaid
graph TB
    subgraph "Python数据类型"
        ROOT[Python对象]
        
        subgraph "数值类型"
            INT[int 整数]
            FLOAT[float 浮点数]
            COMPLEX[complex 复数]
            BOOL[bool 布尔值]
        end
        
        subgraph "序列类型"
            STR[str 字符串]
            LIST[list 列表]
            TUPLE[tuple 元组]
            RANGE[range 范围]
        end
        
        subgraph "映射类型"
            DICT[dict 字典]
        end
        
        subgraph "集合类型"
            SET[set 集合]
            FROZENSET[frozenset 不可变集合]
        end
        
        subgraph "其他类型"
            NONE[None 空值]
            BYTES[bytes 字节序列]
            BYTEARRAY[bytearray 可变字节序列]
        end
    end
    
    ROOT --> INT
    ROOT --> FLOAT
    ROOT --> COMPLEX
    ROOT --> BOOL
    ROOT --> STR
    ROOT --> LIST
    ROOT --> TUPLE
    ROOT --> RANGE
    ROOT --> DICT
    ROOT --> SET
    ROOT --> FROZENSET
    ROOT --> NONE
    ROOT --> BYTES
    ROOT --> BYTEARRAY
```

#### 1.2.2 数据类型详解与性能特性

**数值类型深度解析**：
```python
# 整数类型 - 无限精度
big_int = 2 ** 1000  # Python支持任意大整数
print(type(big_int))  # <class 'int'>

# 浮点数类型 - IEEE 754双精度
pi = 3.141592653589793
print(f"浮点数精度：{pi:.15f}")

# 复数类型
z = 3 + 4j
print(f"复数模长：{abs(z)}")  # 5.0

# 布尔值 - 整数子类
print(True + True)  # 2
print(isinstance(True, int))  # True
```

**字符串类型深度解析**：
```python
# 字符串不可变性验证
s1 = "hello"
s2 = s1
s1 += " world"
print(f"s1: {s1}, s2: {s2}")  # s1: hello world, s2: hello
print(f"id相同: {id(s1) == id(s2)}")  # False

# 字符串intern机制
a = "python"
b = "python"
print(f"字符串intern: {a is b}")  # True

# 字符串格式化性能对比
import timeit

# f-string (最快)
def f_string_format():
    name, age = "Alice", 25
    return f"Name: {name}, Age: {age}"

# str.format()
def str_format():
    name, age = "Alice", 25
    return "Name: {}, Age: {}".format(name, age)

# % 格式化
def percent_format():
    name, age = "Alice", 25
    return "Name: %s, Age: %d" % (name, age)

print("f-string 性能最优")
```

**容器类型性能分析**：

| 操作 | list | tuple | dict | set |
|------|------|-------|------|-----|
| **创建** | O(n) | O(n) | O(n) | O(n) |
| **访问** | O(1) | O(1) | O(1) | - |
| **查找** | O(n) | O(n) | O(1) | O(1) |
| **插入** | O(1)/O(n) | 不可变 | O(1) | O(1) |
| **删除** | O(n) | 不可变 | O(1) | O(1) |

```python
# 列表与元组性能对比
import sys

list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(f"列表内存占用: {sys.getsizeof(list_obj)} bytes")
print(f"元组内存占用: {sys.getsizeof(tuple_obj)} bytes")

# 字典内部结构演示
class HashDict:
    """简化的字典实现，展示哈希表原理"""
    def __init__(self, size=8):
        self.size = size
        self.buckets = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        bucket = self.buckets[self._hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))
    
    def get(self, key):
        bucket = self.buckets[self._hash(key)]
        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)

# 演示哈希冲突
hash_dict = HashDict(4)
hash_dict.put("a", 1)
hash_dict.put("b", 2)
print(f"获取值: {hash_dict.get('a')}")
```

### 1.3 控制流与逻辑结构

#### 1.3.1 条件控制的高级用法

```python
# 三元运算符
result = "positive" if x > 0 else "non-positive"

# 链式比较
if 0 < x < 10:
    print("x在0到10之间")

# 短路求值
def expensive_function():
    print("执行昂贵操作")
    return True

# 只有当condition为False时才会执行expensive_function
condition = True
result = condition or expensive_function()

# match-case语句 (Python 3.10+)
def handle_data(data):
    match data:
        case int() if data > 0:
            return f"正整数: {data}"
        case int() if data < 0:
            return f"负整数: {data}"
        case 0:
            return "零"
        case str() if len(data) > 0:
            return f"非空字符串: {data}"
        case []:
            return "空列表"
        case [x] if isinstance(x, int):
            return f"单元素整数列表: {x}"
        case [x, y]:
            return f"双元素列表: {x}, {y}"
        case {"name": str(name), "age": int(age)}:
            return f"人员信息: {name}, {age}岁"
        case _:
            return "未知类型"

# 测试match-case
print(handle_data(42))  # 正整数: 42
print(handle_data([1, 2]))  # 双元素列表: 1, 2
print(handle_data({"name": "Alice", "age": 25}))  # 人员信息: Alice, 25岁
```

#### 1.3.2 循环控制的高级技巧

```python
# enumerate获取索引和值
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")

# zip并行迭代
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
cities = ['New York', 'London', 'Tokyo']

for name, age, city in zip(names, ages, cities):
    print(f"{name}, {age}岁, 住在{city}")

# zip_longest处理不等长序列
from itertools import zip_longest

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for num, letter in zip_longest(list1, list2, fillvalue=0):
    print(f"{num} - {letter}")

# 列表推导式的高级用法
# 带条件的列表推导式
squares = [x**2 for x in range(10) if x % 2 == 0]

# 嵌套列表推导式
matrix = [[i + j for j in range(3)] for i in range(3)]

# 字典推导式
word_lengths = {word: len(word) for word in ['python', 'java', 'go']}

# 集合推导式
unique_lengths = {len(word) for word in ['python', 'java', 'go', 'rust']}

# 生成器表达式（内存友好）
large_squares = (x**2 for x in range(1000000))
```

### 1.4 函数与作用域

#### 1.4.1 函数参数的高级特性

```python
# 参数类型完整示例
def complex_function(
    pos_only, /,                    # 仅位置参数
    pos_or_kw,                      # 位置或关键字参数
    *args,                          # 可变位置参数
    kw_only,                        # 仅关键字参数
    kw_with_default="default",      # 带默认值的关键字参数
    **kwargs                        # 可变关键字参数
):
    print(f"pos_only: {pos_only}")
    print(f"pos_or_kw: {pos_or_kw}")
    print(f"args: {args}")
    print(f"kw_only: {kw_only}")
    print(f"kw_with_default: {kw_with_default}")
    print(f"kwargs: {kwargs}")

# 调用示例
complex_function(
    1,                              # pos_only
    2,                              # pos_or_kw
    3, 4, 5,                        # args
    kw_only="required",             # kw_only
    extra1="value1",                # kwargs
    extra2="value2"                 # kwargs
)

# 函数注解与类型提示
from typing import List, Dict, Optional, Union, Callable

def process_data(
    data: List[int],
    multiplier: float = 1.0,
    formatter: Optional[Callable[[float], str]] = None
) -> Dict[str, Union[int, float, str]]:
    """
    处理数据并返回统计信息
    
    Args:
        data: 整数列表
        multiplier: 乘数因子
        formatter: 可选的格式化函数
    
    Returns:
        包含统计信息的字典
    """
    total = sum(data) * multiplier
    avg = total / len(data) if data else 0
    
    result = {
        "count": len(data),
        "total": total,
        "average": avg
    }
    
    if formatter:
        result["formatted_total"] = formatter(total)
    
    return result

# 使用示例
numbers = [1, 2, 3, 4, 5]
stats = process_data(numbers, 2.0, lambda x: f"${x:.2f}")
print(stats)
```

#### 1.4.2 作用域与LEGB规则

```mermaid
graph TB
    subgraph "LEGB作用域解析顺序"
        L[Local 局部作用域<br/>函数内部定义的变量]
        E[Enclosing 闭包作用域<br/>外层函数的局部变量]
        G[Global 全局作用域<br/>模块级别的变量]
        B[Built-in 内置作用域<br/>内置函数和异常]
    end
    
    L --> E
    E --> G
    G --> B
```

```python
# LEGB作用域演示
builtin_name = "内置"  # 这实际上会覆盖内置作用域

global_var = "全局变量"

def outer_function():
    enclosing_var = "闭包变量"
    
    def inner_function():
        local_var = "局部变量"
        
        # 演示作用域查找顺序
        print(f"局部: {local_var}")
        print(f"闭包: {enclosing_var}")
        print(f"全局: {global_var}")
        
        # 使用nonlocal修改闭包变量
        nonlocal enclosing_var
        enclosing_var = "修改后的闭包变量"
        
        # 使用global修改全局变量
        global global_var
        global_var = "修改后的全局变量"
    
    inner_function()
    print(f"外层函数中的闭包变量: {enclosing_var}")
    return inner_function

# 闭包示例
def create_multiplier(factor):
    """创建一个乘法器闭包"""
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(f"double(5) = {double(5)}")  # 10
print(f"triple(5) = {triple(5)}")  # 15

# 查看闭包变量
print(f"double的闭包变量: {double.__closure__[0].cell_contents}")  # 2
```

### 1.5 模块与包管理

#### 1.5.1 模块导入机制深度解析

```python
# 模块搜索路径
import sys
print("Python模块搜索路径:")
for path in sys.path:
    print(f"  {path}")

# 动态导入模块
import importlib

def dynamic_import(module_name, function_name):
    """动态导入模块中的函数"""
    try:
        module = importlib.import_module(module_name)
        function = getattr(module, function_name)
        return function
    except (ImportError, AttributeError) as e:
        print(f"导入失败: {e}")
        return None

# 模块重新加载
def reload_module(module):
    """重新加载模块（开发时有用）"""
    return importlib.reload(module)

# 相对导入和绝对导入
# 包结构示例：
# myproject/
#   __init__.py
#   main.py
#   utils/
#     __init__.py
#     helpers.py
#     math_utils.py

# 在 myproject/main.py 中：
# 绝对导入
# from myproject.utils.helpers import some_function

# 相对导入
# from .utils.helpers import some_function
# from ..other_package import other_function
```

#### 1.5.2 包管理最佳实践

```python
# __init__.py 文件的高级用法
# mypackage/__init__.py

# 控制 from mypackage import * 的行为
__all__ = ['PublicClass', 'public_function']

# 包级别的初始化代码
print(f"正在初始化包: {__name__}")

# 延迟导入，避免循环依赖
def get_heavy_module():
    """延迟导入重型模块"""
    import heavy_module
    return heavy_module

# 版本信息
__version__ = "1.0.0"
__author__ = "Your Name"

# 子模块的便捷访问
from .submodule import important_function

class PublicClass:
    """包的公共类"""
    pass

def public_function():
    """包的公共函数"""
    pass

# 包的命名空间包（PEP 420）
# 不需要 __init__.py 文件，允许分布式包结构
```

**包结构最佳实践**：
```
myproject/
├── README.md
├── setup.py
├── requirements.txt
├── myproject/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── models.py
│   │   └── services.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── helpers.py
│   │   └── validators.py
│   └── tests/
│       ├── __init__.py
│       ├── test_core.py
│       └── test_utils.py
└── docs/
    └── api.md
```

## 2. 面向对象编程

### 2.1 类与对象

#### 2.1.1 类的定义与实例化

```python
class Person:
    """人员类示例"""
    
    # 类变量
    species = "Homo sapiens"
    population = 0
    
    def __init__(self, name, age, email=None):
        """构造函数"""
        # 实例变量
        self.name = name
        self.age = age
        self.email = email
        
        # 更新类变量
        Person.population += 1
    
    def __str__(self):
        """字符串表示"""
        return f"Person(name='{self.name}', age={self.age})"
    
    def __repr__(self):
        """调试表示"""
        return f"Person('{self.name}', {self.age}, '{self.email}')"
    
    def greet(self):
        """实例方法"""
        return f"Hello, I'm {self.name}"
    
    @classmethod
    def get_population(cls):
        """类方法"""
        return cls.population
    
    @staticmethod
    def is_adult(age):
        """静态方法"""
        return age >= 18
    
    def __del__(self):
        """析构函数"""
        Person.population -= 1

# 使用示例
person1 = Person("Alice", 25, "alice@example.com")
person2 = Person("Bob", 17)

print(person1.greet())  # Hello, I'm Alice
print(Person.get_population())  # 2
print(Person.is_adult(person2.age))  # False
```

#### 2.1.2 属性访问控制

```python
class BankAccount:
    """银行账户类，演示访问控制"""
    
    def __init__(self, account_number, initial_balance=0):
        self.account_number = account_number  # 公开属性
        self._balance = initial_balance       # 受保护属性（约定）
        self.__pin = "1234"                  # 私有属性（名称修饰）
    
    @property
    def balance(self):
        """余额属性的getter"""
        return self._balance
    
    @balance.setter
    def balance(self, value):
        """余额属性的setter"""
        if value < 0:
            raise ValueError("余额不能为负数")
        self._balance = value
    
    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self._balance += amount
            return True
        return False
    
    def withdraw(self, amount, pin):
        """取款"""
        if pin != self.__pin:
            raise ValueError("PIN码错误")
        if amount > self._balance:
            raise ValueError("余额不足")
        self._balance -= amount
        return True
    
    def _internal_audit(self):
        """受保护方法"""
        return f"账户 {self.account_number} 余额审计: {self._balance}"
    
    def __validate_transaction(self, amount):
        """私有方法"""
        return amount > 0 and amount <= self._balance

# 使用示例
account = BankAccount("123456789", 1000)
print(f"余额: {account.balance}")  # 1000

account.deposit(500)
print(f"存款后余额: {account.balance}")  # 1500

# 私有属性的名称修饰
print(f"私有属性实际名称: {account._BankAccount__pin}")  # 1234
```

### 2.2 继承与多态

#### 2.2.1 单继承与方法重写

```python
class Animal:
    """动物基类"""
    
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        """发出声音 - 抽象方法"""
        raise NotImplementedError("子类必须实现此方法")
    
    def info(self):
        """获取动物信息"""
        return f"{self.name} is a {self.species}"

class Dog(Animal):
    """狗类"""
    
    def __init__(self, name, breed):
        super().__init__(name, "Dog")  # 调用父类构造函数
        self.breed = breed
    
    def make_sound(self):
        """重写父类方法"""
        return f"{self.name} says Woof!"
    
    def fetch(self):
        """狗特有的方法"""
        return f"{self.name} is fetching the ball"

class Cat(Animal):
    """猫类"""
    
    def __init__(self, name, indoor=True):
        super().__init__(name, "Cat")
        self.indoor = indoor
    
    def make_sound(self):
        return f"{self.name} says Meow!"
    
    def climb(self):
        return f"{self.name} is climbing"

# 多态演示
def animal_concert(animals):
    """动物演唱会 - 多态的体现"""
    for animal in animals:
        print(animal.make_sound())

# 使用示例
dog = Dog("Buddy", "Golden Retriever")
cat = Cat("Whiskers", indoor=True)

animals = [dog, cat]
animal_concert(animals)
# Buddy says Woof!
# Whiskers says Meow!

# 检查继承关系
print(isinstance(dog, Animal))  # True
print(issubclass(Dog, Animal))  # True
```

#### 2.2.2 多重继承与MRO

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

# 方法解析顺序（MRO）
print(D.mro())
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

d = D()
d.method()
# D.method
# B.method
# C.method
# A.method

# Mixin模式示例
class TimestampMixin:
    """时间戳混入类"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        from datetime import datetime
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def touch(self):
        """更新时间戳"""
        from datetime import datetime
        self.updated_at = datetime.now()

class LoggingMixin:
    """日志混入类"""
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class User(TimestampMixin, LoggingMixin):
    """用户类，使用多个Mixin"""
    def __init__(self, username):
        super().__init__()
        self.username = username
        self.log(f"User {username} created")
    
    def update_profile(self):
        self.touch()
        self.log("Profile updated")

user = User("alice")
user.update_profile()
```

### 2.3 特殊方法与运算符重载

```python
class Vector:
    """二维向量类，演示运算符重载"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        """字符串表示"""
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        """调试表示"""
        return f"Vector({self.x!r}, {self.y!r})"
    
    def __add__(self, other):
        """向量加法"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __sub__(self, other):
        """向量减法"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    def __mul__(self, scalar):
        """标量乘法"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __rmul__(self, scalar):
        """反向标量乘法"""
        return self.__mul__(scalar)
    
    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False
    
    def __lt__(self, other):
        """小于比较（按长度）"""
        if isinstance(other, Vector):
            return self.magnitude() < other.magnitude()
        return NotImplemented
    
    def __len__(self):
        """长度（转换为整数）"""
        return int(self.magnitude())
    
    def __bool__(self):
        """布尔值转换"""
        return self.magnitude() != 0
    
    def __getitem__(self, key):
        """索引访问"""
        if key == 0:
            return self.x
        elif key == 1:
            return self.y
        else:
            raise IndexError("Vector只有两个分量")
    
    def __setitem__(self, key, value):
        """索引赋值"""
        if key == 0:
            self.x = value
        elif key == 1:
            self.y = value
        else:
            raise IndexError("Vector只有两个分量")
    
    def magnitude(self):
        """计算向量长度"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def dot(self, other):
        """点积"""
        return self.x * other.x + self.y * other.y

# 使用示例
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)  # Vector(4, 6)
print(v1 * 2)   # Vector(6, 8)
print(2 * v1)   # Vector(6, 8)
print(v1[0])    # 3
print(len(v1))  # 5
print(bool(v1)) # True
print(v1 == v2) # False
```

### 2.4 属性与描述符

#### 2.4.1 属性装饰器

```python
class Temperature:
    """温度类，演示属性装饰器"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """摄氏度"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """华氏度"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9
    
    @property
    def kelvin(self):
        """开尔文"""
        return self._celsius + 273.15
    
    @kelvin.setter
    def kelvin(self, value):
        self.celsius = value - 273.15

# 使用示例
temp = Temperature(25)
print(f"摄氏度: {temp.celsius}")    # 25
print(f"华氏度: {temp.fahrenheit}")  # 77.0
print(f"开尔文: {temp.kelvin}")     # 298.15

temp.fahrenheit = 100
print(f"摄氏度: {temp.celsius}")    # 37.77777777777778
```

#### 2.4.2 描述符协议

```python
class ValidatedAttribute:
    """验证描述符"""
    
    def __init__(self, validator=None, default=None):
        self.validator = validator
        self.default = default
        self.name = None
    
    def __set_name__(self, owner, name):
        """当描述符被赋值给类属性时调用"""
        self.name = name
        self.private_name = f'_{name}'
    
    def __get__(self, instance, owner):
        """获取属性值"""
        if instance is None:
            return self
        return getattr(instance, self.private_name, self.default)
    
    def __set__(self, instance, value):
        """设置属性值"""
        if self.validator:
            value = self.validator(value)
        setattr(instance, self.private_name, value)
    
    def __delete__(self, instance):
        """删除属性"""
        delattr(instance, self.private_name)

# 验证函数
def positive_number(value):
    """验证正数"""
    if not isinstance(value, (int, float)):
        raise TypeError("必须是数字")
    if value <= 0:
        raise ValueError("必须是正数")
    return value

def non_empty_string(value):
    """验证非空字符串"""
    if not isinstance(value, str):
        raise TypeError("必须是字符串")
    if not value.strip():
        raise ValueError("不能是空字符串")
    return value.strip()

class Product:
    """产品类，使用描述符进行验证"""
    
    name = ValidatedAttribute(non_empty_string)
    price = ValidatedAttribute(positive_number)
    quantity = ValidatedAttribute(positive_number, default=1)
    
    def __init__(self, name, price, quantity=1):
        self.name = name
        self.price = price
        self.quantity = quantity
    
    @property
    def total_value(self):
        return self.price * self.quantity

# 使用示例
product = Product("Laptop", 999.99, 2)
print(f"产品: {product.name}, 总价值: ${product.total_value}")

# 验证会自动触发
try:
    product.price = -100  # 将触发ValueError
except ValueError as e:
    print(f"验证错误: {e}")
```

## Python 高级特性

### 装饰器

## 4. 内存管理与性能优化

### 4.1 Python 内存模型

#### 4.1.1 对象内存结构

```python
import sys
import gc

# 检查对象内存占用
def check_memory_usage():
    """检查不同数据类型的内存占用"""
    objects = [
        42,                    # int
        3.14,                  # float
        "hello",               # str
        [1, 2, 3],            # list
        (1, 2, 3),            # tuple
        {"a": 1, "b": 2},     # dict
        {1, 2, 3}             # set
    ]
    
    for obj in objects:
        size = sys.getsizeof(obj)
        print(f"{type(obj).__name__}: {obj} -> {size} bytes")

check_memory_usage()

# Python对象引用计数
class RefCountDemo:
    def __init__(self, name):
        self.name = name
    
    def __del__(self):
        print(f"对象 {self.name} 被销毁")

def reference_counting_demo():
    """引用计数演示"""
    obj = RefCountDemo("test")
    print(f"引用计数: {sys.getrefcount(obj)}")  # 包括函数参数的引用
    
    ref1 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    ref2 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    del ref1
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    del ref2
    print(f"引用计数: {sys.getrefcount(obj)}")

reference_counting_demo()
```

### 4.2 垃圾回收机制

```python
import gc
import weakref

# 循环引用问题
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.parent = None
    
    def add_child(self, child):
        child.parent = self
        self.children.append(child)
    
    def __del__(self):
        print(f"节点 {self.value} 被销毁")

def circular_reference_demo():
    """循环引用演示"""
    print("创建循环引用...")
    root = Node("root")
    child = Node("child")
    root.add_child(child)
    
    # 创建循环引用
    child.children.append(root)
    
    print(f"垃圾回收前: {len(gc.get_objects())} 个对象")
    
    # 删除引用
    del root
    del child
    
    print("手动触发垃圾回收...")
    collected = gc.collect()
    print(f"回收了 {collected} 个对象")

# 弱引用解决循环引用
class WeakNode:
    def __init__(self, value):
        self.value = value
        self.children = []
        self._parent = None
    
    @property
    def parent(self):
        return self._parent() if self._parent else None
    
    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value) if value else None
    
    def add_child(self, child):
        child.parent = self
        self.children.append(child)

circular_reference_demo()
```

### 4.3 性能分析与优化

```python
import cProfile
import timeit
from functools import lru_cache
import numpy as np

# 性能分析装饰器
def profile_performance(func):
    """性能分析装饰器"""
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()
        
        result = func(*args, **kwargs)
        
        profiler.disable()
        profiler.print_stats(sort='cumulative')
        
        return result
    return wrapper

# 缓存优化
@lru_cache(maxsize=128)
def fibonacci_cached(n):
    """带缓存的斐波那契函数"""
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_naive(n):
    """朴素的斐波那契函数"""
    if n <= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

# 性能对比
def performance_comparison():
    """性能对比测试"""
    n = 30
    
    # 测试朴素版本
    naive_time = timeit.timeit(
        lambda: fibonacci_naive(n), 
        number=1
    )
    
    # 测试缓存版本
    cached_time = timeit.timeit(
        lambda: fibonacci_cached(n), 
        number=100
    ) / 100
    
    print(f"朴素版本 (n={n}): {naive_time:.6f}秒")
    print(f"缓存版本 (n={n}): {cached_time:.6f}秒")
    print(f"性能提升: {naive_time / cached_time:.2f}倍")

performance_comparison()

# 列表推导式 vs 循环性能
def list_comprehension_vs_loop():
    """列表推导式与循环性能对比"""
    size = 100000
    
    # 列表推导式
    def list_comp():
        return [x**2 for x in range(size) if x % 2 == 0]
    
    # 传统循环
    def traditional_loop():
        result = []
        for x in range(size):
            if x % 2 == 0:
                result.append(x**2)
        return result
    
    # 性能测试
    comp_time = timeit.timeit(list_comp, number=10) / 10
    loop_time = timeit.timeit(traditional_loop, number=10) / 10
    
    print(f"列表推导式: {comp_time:.6f}秒")
    print(f"传统循环: {loop_time:.6f}秒")
    print(f"推导式更快: {loop_time / comp_time:.2f}倍")

list_comprehension_vs_loop()
```

## 环境与工具

### 搭建环境

**创建venv虚拟环境**
```bash
python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt
```

**查看pip位置**
```bash
conda run which pip   
```

**终端配置代理**
```bash
# 设置代理
export http_proxy=http://127.0.0.1:10809  
export https_proxy=http://127.0.0.1:10809 
export ALL_PROXY=socks5://127.0.0.1:10808

# 或者
export http_proxy="http://127.0.0.1:7890"
export https_proxy="http://127.0.0.1:7890"

# 取消代理
unset http_proxy
unset https_proxy
unset all_proxy
```

### 包管理工具

**pip 使用**
```bash
# 安装包
pip install package_name

# 指定镜像源安装
pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple

# 安装特定版本
pip install package_name==1.0.0

# 从requirements.txt安装
pip install -r requirements.txt

# 升级包
pip install --upgrade package_name

# 卸载包
pip uninstall package_name
```

**conda 使用**
```bash
# 添加频道
conda config --add channels conda-forge
conda config --set channel_priority strict

# 安装包
conda install osmium

# 创建环境
conda create -n osm-env python=3.10

# 激活环境
conda activate osm-env

# 安装多个包
conda install -c conda-forge pyosmium pandas
```

### 虚拟环境

**venv**
```bash
# 创建虚拟环境
python -m venv myenv

# 激活虚拟环境(Windows)
myenv\Scripts\activate

# 激活虚拟环境(Linux/Mac)
source myenv/bin/activate

# 退出虚拟环境
deactivate
```

**conda环境**
```bash
# 创建环境
conda create -n myenv python=3.9

# 激活环境
conda activate myenv

# 退出环境
conda deactivate

# 列出所有环境
conda env list
```

### 常用开发工具

**检测当前可用字体**
```python
import matplotlib.font_manager as fm
for font in fm.findSystemFonts(fontpaths=None, fontext='ttf'):
    print(fm.FontProperties(fname=font).get_name())
```

**IDE与编辑器**
- PyCharm: 功能全面的Python IDE
- VS Code: 轻量级编辑器，配合Python扩展使用
- Jupyter Notebook: 交互式开发环境，适合数据分析
- Spyder: 科学计算导向的IDE

## 数据处理与分析

### NumPy 基础

**创建数组**
```python
import numpy as np

# 从列表创建
arr1 = np.array([1, 2, 3, 4, 5])

# 创建特殊数组
zeros = np.zeros((3, 3))  # 全0数组
ones = np.ones((2, 4))    # 全1数组
rand = np.random.random((2, 2))  # 随机数组
arange = np.arange(10)    # 0到9的数组
linspace = np.linspace(0, 1, 5)  # 均匀分布的5个点
```

**数组操作**
```python
# 重塑数组
arr = np.arange(12)
arr_reshaped = arr.reshape(3, 4)

# 数组切片
slice1 = arr_reshaped[0:2, 1:3]

# 数组运算
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
sum_arr = arr1 + arr2
product = arr1 * arr2
dot_product = np.dot(arr1, arr2)
```

### Pandas 数据处理

#### 数据结构与创建

**Series 和 DataFrame 基础**
```python
import pandas as pd
import numpy as np

# 创建Series
s1 = pd.Series([1, 3, 5, np.nan, 6, 8])
s2 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
s3 = pd.Series({'a': 1, 'b': 2, 'c': 3})

# 创建DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3, 4],
    'B': pd.date_range('20230101', periods=4),
    'C': pd.Series(1, index=list(range(4))),
    'D': np.random.randn(4),
    'E': pd.Categorical(['test', 'train', 'test', 'train']),
    'F': 'foo'
})

# 从字典创建DataFrame
data = {
    'name': ['Alice', 'Bob', 'Charlie', 'David'],
    'age': [25, 30, 35, 28],
    'city': ['New York', 'London', 'Tokyo', 'Paris'],
    'salary': [50000, 60000, 70000, 55000]
}
df_people = pd.DataFrame(data)
```

**数据操作**

#### 数据读取与写入

**文件读取操作**
```python
# CSV文件读取
df_csv = pd.read_csv('data/my_csv.csv', encoding='utf-8')

# 文本文件读取
df_txt = pd.read_table('data/my_table.txt', sep='\t')

# Excel文件读取
df_excel = pd.read_excel('data/my_excel.xlsx', sheet_name='Sheet1')
```
**写出数据**
a.df.to_csv(‘existing.csv’, mode=’a’, index=False, header=False)  mode 默认w覆盖，a追加
b.b.tail(2).to_csv('../data/fund/20230421.xlsx',mode='a',index=False,header=False)
c.df_txt.to_csv('data/my_txt_saved.txt', sep='\t', index=False)
**df求大小**
a.df.shape[1] 求df列长度
b.df.shape[0] 或者 len(df) 求df的行数
**描述df**
a.info, describe 分别返回表的 信息概况 和表中 数值列对应的主要统计量 
**行列处理**
a.df.drop_duplicates() 删除重复行，如果需要按照列过滤，参数选填['col1', 'col2',...]
b.stock.drop('ts_code',axis=1)  stock.drop(['last','pct_chg'],axis=1)删除列
c.stock.drop(0)   stock.drop([0,1]) 删除行
d.df.column = col_lst 重新制定列名
e.df.rename(index={'row1':'A'}), 重命名索引名 stock.rename(columns=({'last':'last_open'})) 重命名列名
f.df['foo'] = df.Q1 + df.Q2 # 新列为两列相加
g.stock['trade_date']=stock['trade_date'].astype('datetime64')  设置列类型 
h.df.dtypes 查看字段类型
**字段处理**
a.all_stock[all_stock['name'].str.contains('宁德时代')]
b.df['date'] = pd.to_datetime(df['date'])  转为时间类型
c.保留小数点后几位 round('amount',2)
**时间相关**
a.df = pd.DataFrame({'sales': [3, 3, 3, 9, 10, 6],'signups': [4, 5, 6, 10, 12, 13]}, index=pd.date_range(start='2018/01/01', end='2018/07/01', freq='M'))
**获取头部数据**
a.head, tail 函数分别表示返回表或者序列的前 n 行和后 n 行，其中 n 默认为5：
**排序**
a.sort_values、sort_index
a.stock.sort_values('high')  df_demo.sort_values(['Weight','Height'],ascending=[True,False],inplace=True)
**apply方法**
a.stock['diff']=stock.apply(lambda x:x['open']-x['close'],axis=1) 注意axis的值为1是对一行数据处理
b.stock[['open','close','high']].apply(lambda x:x.mean()) axis默认为0，对一列数据处理
**滑动窗口**
a.rolling 、扩张窗口 expanding 以及指数加权窗口 ewm
b.stock['open'].rolling(3,min_periods=1).apply(lambda x:x.mean()) , axis默认为0，在列方向计算，=1在行方向计算,min_periods,表示窗口的最小观测值，即：窗口里面元素的最小数量，默认它是和窗口的长度相等的
c.扩张窗口又称累计窗口，可以理解为一个动态长度的窗口，其窗口的大小就是从序列开始处到具体操作的对应位置，其使用的聚合函数会作用于这些逐步扩张的窗口上。具体地说，设序列为a1, a2, a3, a4，则其每个位置对应的窗口即[a1]、[a1, a2]、[a1, a2, a3]、[a1, a2, a3, a4]。
d.df['tmp']=df['close'].rolling(window=5).apply(lambda t:t.iloc[4])  获取窗口内最后一位元素
**滑动取值**
a.shift, diff, pct_change 公共参数为 periods=n ，默认为1，可以不写
b.分别表示取向前第 n 个元素的值、与向前第 n 个元素做差、与向前第 n 个元素相比计算增长率。这里的 n 可以为负，表示反方向的类似操作。
**索引**
a.loc
i.a.loc[0:1,'trade_date':'vol']  索引取0到1的（不包含1），列取trade_date到vol的（包含vol），返回df
ii.a.loc[0,'trade_date':'vol'] 取索引为0，列取trade_date到vol的（包含vol），返回series
iii.a.loc[0,'trade_date'] 返回索引为0，列为trade_date的值
iv.a.loc[a['index']>0,['open','close']]  对索引返回过滤，列选择一个list
v.df.loc[df['Q1']> 90, 'Q1':] # Q1大于90，只显示Q1
i.df.loc[(df.Q1> 80) & (df.Q2 < 15)] # and关系  多个条件用括号括起来
b.iloc
i.a.iloc[0,1]  返回第1行，第1列的值
ii.a.iloc[0,1:3]  返回第1行，第2，3列的内容
c.df.set_index(keys='trade_date') 设置某一个字段为索引
**query方法**
a.df.query('open>17.50 and open<= 17.56')
b.df.query('open.isin([17.52,17.50])')   stock.query('open not in([12.60,12.41])')
c.df.query('(Grade not in ["Freshman", "Sophomore"]) and (Gender == "Male")')
d.low, high =70, 80    df.query('Weight.between(@low, @high)')   对于 query 中的字符串，如果要引用外部变量，只需在变量名前加 @ 符号
e.也可以使用 or, and, or, isin（==）, not in（！=）
**字段类型转换**
a.df = pd.DataFrame(data, dtype='float32') # 对所有字段指定统一类型
b.df = pd.read_excel(data, dtype={'team':'string', 'Q1': 'int32'}) # 对每个字段分别指定
**随机抽样**
a.sample 函数中的主要参数为 n, axis, frac, replace, weights ，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）
b.df_sample.sample(3, replace = True, weights = df_sample.value)
**分组**
a.df.groupby('open').mean() 
b.df.groupby(df.open>df.avg_open).mean()
c.df.agg({'open':['sum','count'],'close':'max'})
**聚合函数**
a.max/min/mean/median/count/all/any/idxmax/idxmin/mad/nunique/skew/quantile/sum/std/var/sem/size/prod
b.df.agg(lambda x:x.max()-x.min())
c.如果想要对聚合结果的列名进行重命名，只需要将上述函数的位置改写成元组，元组的第一个元素为新的名字，第二个位置为原来的函数，包括聚合字符串和自定义函数
**变换**
a.gb.transform(lambda x: (x-x.mean())/x.std()).head()
b. cumcount/cumsum/cumprod/cummax/cummin 
**过滤**
a.gb.filter(lambda x: x.shape[0] > 100).head() 没看懂
b.df.filter(items=['Q1', 'Q2']) # 选择两列
c.df.filter(regex='Q', axis=1) # 列名包含Q的列
d.df.filter(regex='e$', axis=1) # 以e结尾的列
e.filtered_df = df[df["name"].isin(["Bob", "Dave"])]  
**变形**
a.stock.head().pivot(index='open',columns='close',values='high')
b.df.pivot_table(index='Name',columns='Subject', values='Grade',aggfunc=lambda x:x.std())
c.df.melt(id_vars = ['Class', 'Name'], value_vars = ['Chinese', 'Math'], var_name = 'Subject',value_name = 'Grade')
**索引的变形**
a.stack 的作用就是把列索引的层压入行索引
b.unstack 函数的作用是把行索引转为列索引
**其他变形函数**
a.crosstab
b.explode
c.get_dummies
**连接**
a.df1.merge(df2,how='inner',on='name')
b.df1.merge(df2,left_on='name', right_on='name',how='inner',sort=True)
c.df1.merge(df2,left_on='name', right_on='name',how='inner',suffixes=['_chinese','_math']) 两边相同字段添加不同后缀
d.df1.join(df2， how=left'')  索引连接
e.concat 最常用的有三个参数，它们是 axis, join, keys,axis=0 纵向拼接，=1是横向 pd.concat([a,b])
**缺失数据**
a.缺失数据可以使用 isna 或 isnull （两个函数没有区别）来查看每个单元格是否缺失，结合 
b.pd.notna(basic['市盈率（TTM）']) 筛选某个字段不为空
c.df[sub_set.isna().all(1)] # 全部缺失
d.a[a.isna().any(1)] # 至少有一个缺失 一行里至少有一个字段缺失
e.df[sub_set.notna().all(1)].head() # 没有缺失
**缺失信息的删除**
a.dropna 的主要参数为轴方向 axis （默认为0，即删除行）、删除方式 how 、删除的非缺失值个数阈值 thresh （ 非缺失值 没有达到这个数量的相应维度会被删除）、备选的删除子集 subset ，其中 how 主要有 any 和 all 两种参数可以选择。
b.res = df.dropna(how = 'any', subset = ['Height', 'Weight'])
**缺失值的填充和插值**
a. fillna 中有三个参数是常用的： value, method, limit 。其中， value 为填充值，可以是标量，也可以是索引到元素的字典映射； method 为填充方法，有用前面的元素填充 ffill 和用后面的元素填充 bfill 两种类型， limit 参数表示连续缺失值的最大填充次数。
b.df.fillna(0) 用实数0填充na
**Nullable类型**
a.在 python 中的缺失值用 None 表示，该元素除了等于自己本身之外，与其他任何元素不相等
b.在 numpy 中利用 np.nan 来表示缺失值，该元素除了不和其他任何元素相等之外，和自身的比较结果也返回 False ：
c.对缺失序列或表格的元素进行比较操作的时候， np.nan 的对应位置会返回 False ，但是在使用 equals 函数进行两张表或两个序列的相同性检验时，会自动跳过两侧表都是缺失值的位置，直接返回 True 
d.从字面意义上看 Nullable 就是可空的，言下之意就是序列类型不受缺失值的影响。例如，在上述三个 Nullable 类型中存储缺失值，都会转为 pandas 内置的 pd.NA ：
e.sum, prod 使用加法和乘法的时候，缺失数据等价于被分别视作0和1，即不改变原来的计算结果：
f.当进行单个标量运算的时候，除了 np.nan ** 0 和 1 ** np.nan 这两种情况为确定的值之外，所有运算结果全为缺失（ pd.NA 的行为与此一致 ），并且 np.nan 在比较操作时一定返回 False ，而 pd.NA 返回 pd.NA
**连接mysql**
a.安装包
i.python -m pip install SQLALchemy
b.创建连接引擎
i.con = 'mysql+pymysql://root:Password1?@localhost:3306/mrhd?charset=utf8'
ii.engine = create_engine(con, echo=False)
c.读取数据
i.df=pd.read_sql("select * from azkaban_session_id",con=engine)
d.写出数据
i.b.to_sql(name='azkaban_session_id', con=engine, if_exists='append', index=False, chunksize=1000)
**参数**
a.pd.set_option('display.max_columns', 100)
b.pd.set_option('display.max_rows', 100)
c.pd.set_option('display.float_format', lambda x: '%.2f' % x) 控制展示数值小数位数
d.https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/125012967


### Matplotlib 数据可视化

#### 基础绘图

**基本图表类型**
```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# 设置中文字体和样式
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'SimHei']
plt.rcParams['axes.unicode_minus'] = False
plt.style.use('seaborn-v0_8')  # 使用seaborn样式

# 准备数据
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# 1. 线图
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# 基本线图
axes[0, 0].plot(x, y1, label='sin(x)', linewidth=2)
axes[0, 0].plot(x, y2, label='cos(x)', linewidth=2, linestyle='--')
axes[0, 0].set_title('线图示例')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# 2. 散点图
np.random.seed(42)
x_scatter = np.random.randn(100)
y_scatter = np.random.randn(100)
colors = np.random.rand(100)
sizes = 1000 * np.random.rand(100)

scatter = axes[0, 1].scatter(x_scatter, y_scatter, c=colors, s=sizes, alpha=0.6, cmap='viridis')
axes[0, 1].set_title('散点图示例')
plt.colorbar(scatter, ax=axes[0, 1])

# 3. 柱状图
categories = ['A', 'B', 'C', 'D', 'E']
values = [23, 45, 56, 78, 32]
bars = axes[1, 0].bar(categories, values, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'])
axes[1, 0].set_title('柱状图示例')

# 在柱子上添加数值标签
for bar, value in zip(bars, values):
    height = bar.get_height()
    axes[1, 0].text(bar.get_x() + bar.get_width()/2., height + 1,
                    f'{value}', ha='center', va='bottom')

# 4. 直方图
data = np.random.normal(100, 15, 1000)
axes[1, 1].hist(data, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
axes[1, 1].set_title('直方图示例')
axes[1, 1].axvline(data.mean(), color='red', linestyle='--', label=f'均值: {data.mean():.1f}')
axes[1, 1].legend()

plt.tight_layout()
plt.show()
```

**高级图表类型**
```python
# 创建更复杂的图表
fig, axes = plt.subplots(2, 3, figsize=(18, 12))

# 1. 箱线图
data_box = [np.random.normal(0, std, 100) for std in range(1, 4)]
box_plot = axes[0, 0].boxplot(data_box, labels=['Group 1', 'Group 2', 'Group 3'])
axes[0, 0].set_title('箱线图')
axes[0, 0].set_ylabel('数值')

# 2. 小提琴图
parts = axes[0, 1].violinplot(data_box, positions=[1, 2, 3])
axes[0, 1].set_title('小提琴图')
axes[0, 1].set_xticks([1, 2, 3])
axes[0, 1].set_xticklabels(['Group 1', 'Group 2', 'Group 3'])

# 3. 热力图
data_heatmap = np.random.rand(10, 12)
im = axes[0, 2].imshow(data_heatmap, cmap='YlOrRd', aspect='auto')
axes[0, 2].set_title('热力图')
plt.colorbar(im, ax=axes[0, 2])

# 4. 极坐标图
theta = np.linspace(0, 2*np.pi, 100)
r = 1 + 0.3*np.cos(5*theta)
axes[1, 0] = plt.subplot(2, 3, 4, projection='polar')
axes[1, 0].plot(theta, r)
axes[1, 0].set_title('极坐标图')

# 5. 3D散点图
ax_3d = plt.subplot(2, 3, 5, projection='3d')
x_3d = np.random.randn(100)
y_3d = np.random.randn(100)
z_3d = np.random.randn(100)
ax_3d.scatter(x_3d, y_3d, z_3d, c=z_3d, cmap='viridis')
ax_3d.set_title('3D散点图')

# 6. 饼图
sizes = [30, 25, 20, 15, 10]
labels = ['A', 'B', 'C', 'D', 'E']
colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7']
explode = (0.1, 0, 0, 0, 0)  # 突出显示第一个扇形

axes[1, 2].pie(sizes, labels=labels, colors=colors, explode=explode,
               autopct='%1.1f%%', shadow=True, startangle=90)
axes[1, 2].set_title('饼图')

plt.tight_layout()
plt.show()
```

#### 图形样式与美化

**颜色和样式设置**
```python
# 自定义颜色方案
colors = {
    'primary': '#2E86AB',
    'secondary': '#A23B72',
    'accent': '#F18F01',
    'success': '#C73E1D',
    'info': '#592E83'
}

# 创建专业的图表
fig, ax = plt.subplots(figsize=(12, 8))

# 数据
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
sales_2022 = [120, 135, 140, 155, 168, 180, 175, 185, 190, 200, 195, 210]
sales_2023 = [130, 145, 160, 170, 185, 195, 190, 200, 210, 220, 215, 230]

# 绘制线图
line1 = ax.plot(months, sales_2022, marker='o', linewidth=3, 
                color=colors['primary'], label='2022年销售额', markersize=8)
line2 = ax.plot(months, sales_2023, marker='s', linewidth=3, 
                color=colors['secondary'], label='2023年销售额', markersize=8)

# 填充区域
ax.fill_between(months, sales_2022, alpha=0.3, color=colors['primary'])
ax.fill_between(months, sales_2023, alpha=0.3, color=colors['secondary'])

# 样式设置
ax.set_title('月度销售额对比', fontsize=20, fontweight='bold', pad=20)
ax.set_xlabel('月份', fontsize=14, fontweight='bold')
ax.set_ylabel('销售额 (万元)', fontsize=14, fontweight='bold')

# 网格设置
ax.grid(True, linestyle='--', alpha=0.7, color='gray')
ax.set_facecolor('#F8F9FA')

# 图例设置
legend = ax.legend(loc='upper left', fontsize=12, frameon=True, 
                  fancybox=True, shadow=True, framealpha=0.9)
legend.get_frame().set_facecolor('white')

# 坐标轴设置
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_linewidth(2)
ax.spines['bottom'].set_linewidth(2)

# 添加注释
max_2023_idx = sales_2023.index(max(sales_2023))
ax.annotate(f'最高点: {max(sales_2023)}万', 
            xy=(max_2023_idx, max(sales_2023)), 
            xytext=(max_2023_idx+1, max(sales_2023)+10),
            arrowprops=dict(arrowstyle='->', color='red', lw=2),
            fontsize=12, color='red', fontweight='bold')

plt.tight_layout()
plt.show()
```

#### 多子图与布局

**复杂布局示例**
```python
# 创建复杂的子图布局
fig = plt.figure(figsize=(16, 12))

# 使用GridSpec创建不规则布局
gs = fig.add_gridspec(3, 4, hspace=0.3, wspace=0.3)

# 主图 (占据2x2空间)
ax_main = fig.add_subplot(gs[0:2, 0:2])
x = np.linspace(0, 10, 100)
y = np.sin(x) * np.exp(-x/10)
ax_main.plot(x, y, linewidth=3, color='#2E86AB')
ax_main.set_title('主图：衰减正弦波', fontsize=16, fontweight='bold')
ax_main.grid(True, alpha=0.3)

# 右上角小图
ax_top_right = fig.add_subplot(gs[0, 2:])
categories = ['A', 'B', 'C', 'D']
values = [25, 35, 30, 20]
ax_top_right.bar(categories, values, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'])
ax_top_right.set_title('分类统计')

# 右中间小图
ax_mid_right = fig.add_subplot(gs[1, 2:])
data = np.random.normal(0, 1, 1000)
ax_mid_right.hist(data, bins=30, alpha=0.7, color='orange')
ax_mid_right.set_title('数据分布')

# 底部横跨图
ax_bottom = fig.add_subplot(gs[2, :])
dates = pd.date_range('2023-01-01', periods=100, freq='D')
values = np.cumsum(np.random.randn(100))
ax_bottom.plot(dates, values, linewidth=2)
ax_bottom.set_title('时间序列数据')
ax_bottom.tick_params(axis='x', rotation=45)

plt.suptitle('复杂布局示例', fontsize=20, fontweight='bold', y=0.98)
plt.show()
```

#### 实战案例

**综合数据分析可视化**
```python
# 模拟真实数据分析场景
np.random.seed(42)

# 生成模拟数据
dates = pd.date_range('2023-01-01', periods=365, freq='D')
base_sales = 1000
trend = np.linspace(0, 200, 365)
seasonal = 100 * np.sin(2 * np.pi * np.arange(365) / 365.25 * 4)
noise = np.random.normal(0, 50, 365)
sales = base_sales + trend + seasonal + noise

# 创建DataFrame
df = pd.DataFrame({
    'date': dates,
    'sales': sales,
    'month': dates.month,
    'weekday': dates.dayofweek
})

# 创建综合分析图表
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. 时间序列图
axes[0, 0].plot(df['date'], df['sales'], linewidth=1, alpha=0.7, color='#2E86AB')
# 添加移动平均线
df['sales_ma'] = df['sales'].rolling(window=30).mean()
axes[0, 0].plot(df['date'], df['sales_ma'], linewidth=3, color='#A23B72', label='30日移动平均')
axes[0, 0].set_title('日销售额趋势', fontsize=14, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# 2. 月度销售分布
monthly_sales = df.groupby('month')['sales'].mean()
bars = axes[0, 1].bar(monthly_sales.index, monthly_sales.values, 
                     color='#4ECDC4', alpha=0.8, edgecolor='black')
axes[0, 1].set_title('月度平均销售额', fontsize=14, fontweight='bold')
axes[0, 1].set_xlabel('月份')
axes[0, 1].set_ylabel('平均销售额')

# 添加数值标签
for bar in bars:
    height = bar.get_height()
    axes[0, 1].text(bar.get_x() + bar.get_width()/2., height + 10,
                    f'{height:.0f}', ha='center', va='bottom', fontweight='bold')

# 3. 星期销售模式
weekday_names = ['周一', '周二', '周三', '周四', '周五', '周六', '周日']
weekday_sales = df.groupby('weekday')['sales'].mean()
axes[1, 0].plot(weekday_sales.index, weekday_sales.values, 
               marker='o', linewidth=3, markersize=8, color='#F18F01')
axes[1, 0].set_title('星期销售模式', fontsize=14, fontweight='bold')
axes[1, 0].set_xticks(range(7))
axes[1, 0].set_xticklabels(weekday_names)
axes[1, 0].grid(True, alpha=0.3)

# 4. 销售额分布直方图
axes[1, 1].hist(df['sales'], bins=50, alpha=0.7, color='#96CEB4', edgecolor='black')
axes[1, 1].axvline(df['sales'].mean(), color='red', linestyle='--', linewidth=2, 
                  label=f'均值: {df["sales"].mean():.0f}')
axes[1, 1].axvline(df['sales'].median(), color='orange', linestyle='--', linewidth=2, 
                  label=f'中位数: {df["sales"].median():.0f}')
axes[1, 1].set_title('销售额分布', fontsize=14, fontweight='bold')
axes[1, 1].legend()

plt.suptitle('2023年销售数据综合分析', fontsize=18, fontweight='bold', y=0.98)
plt.tight_layout()
plt.show()

# 输出统计摘要
print("销售数据统计摘要:")
print(f"总销售额: {df['sales'].sum():,.0f}")
print(f"平均日销售额: {df['sales'].mean():.0f}")
print(f"最高日销售额: {df['sales'].max():.0f}")
print(f"最低日销售额: {df['sales'].min():.0f}")
print(f"销售额标准差: {df['sales'].std():.0f}")
```

**折线图柱状图（同时显示数量和百分比）**

![图片1](assets/image1.png)

```
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from matplotlib.ticker import FuncFormatter

# 数据准备
data = {
    "key": ["1-5","6-10","11-15","16-20","21-25","26-30","31-35","36-40","41-45","46-50",
           "51-55","56-60","61-65","66-70","71-75","76-80","81-85","86-90","91-95","96-100"],
    "count": [64926535,1138119,411539,216186,131126,89296,66155,52622,45228,32027,
             23867,22066,17321,13541,10670,8168,5837,5157,5305,38348],
    "percentage": [96.53,1.69,0.61,0.32,0.19,0.13,0.10,0.08,0.07,0.05,
                  0.04,0.03,0.03,0.02,0.02,0.01,0.01,0.01,0.01,0.06]
}

df = pd.DataFrame(data)

# 设置样式
plt.style.use('ggplot')

# 解决中文显示问题
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] 
plt.rcParams['axes.unicode_minus'] = False

# 创建图形
fig, ax1 = plt.subplots(figsize=(14, 7))

# 自定义颜色
bar_color = '#4C72B0'
line_color = '#C44E52'

# 柱状图 (左侧Y轴)
bars = ax1.bar(df['key'], df['count'], color=bar_color, alpha=0.7, width=0.8)
ax1.set_ylabel('数量（万）', color=bar_color, fontsize=12)
ax1.tick_params(axis='y', labelcolor=bar_color)
ax1.set_yscale('log')

# 设置Y轴为中文单位（万）
def format_wan(x, pos):
    return f'{x/10000:.0f}万' if x >= 10000 else f'{x:.0f}'

ax1.yaxis.set_major_formatter(FuncFormatter(format_wan))

# 在柱子上添加标签（百分比和数量）
for bar, count, percentage in zip(bars, df['count'], df['percentage']):
    height = bar.get_height()
    count_wan = count/10000
    
    # 在柱子上方显示百分比
    ax1.text(bar.get_x() + bar.get_width()/2, height*1.05, 
            f'{percentage:.2f}%', 
            ha='center', va='bottom', fontsize=9, color='black')
    
    # 在柱子内部显示数量（万）
    ax1.text(bar.get_x() + bar.get_width()/2, height*0.5, 
            f'{count_wan:.1f}万' if count_wan < 10 else f'{count_wan:.0f}万', 
            ha='center', va='center', fontsize=9, color='white',
            fontweight='bold')

# 折线图 (右侧Y轴)
ax2 = ax1.twinx()
line = ax2.plot(df['key'], df['percentage'], color=line_color, 
                marker='o', markersize=6, linewidth=2.5, alpha=0.9)
ax2.set_ylabel('百分比 (%)', color=line_color, fontsize=12)
ax2.tick_params(axis='y', labelcolor=line_color)
ax2.grid(False)
ax2.set_yscale('log')  # 设置右侧Y轴为对数刻度

# 设置百分比的对数刻度格式
def format_percent(x, pos):
    return f'{x:.2f}%' if x >= 0.1 else f'{x:.3f}%'

ax2.yaxis.set_major_formatter(FuncFormatter(format_percent))

# 设置X轴
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.xlim(-0.5, len(df['key'])-0.5)

# 添加标题和网格
plt.title('uuid推测出来wifi数量分布', fontsize=14, pad=20)
ax1.grid(True, which="both", ls="--", linewidth=0.5, alpha=0.3)

# 调整布局
plt.tight_layout()

# 添加图例
from matplotlib.lines import Line2D
legend_elements = [
    Line2D([0], [0], color=bar_color, lw=4, label='数量（对数刻度）'),
    Line2D([0], [0], color=line_color, marker='o', lw=2.5, label='百分比（对数刻度）')
]
ax1.legend(handles=legend_elements, loc='upper right', fontsize=10)

plt.show()
```

### Bokeh 交互式可视化

#### Bokeh 基础

**环境设置与基本概念**
```python
from bokeh.plotting import figure, show, output_notebook, output_file
from bokeh.layouts import column, row, gridplot
from bokeh.models import HoverTool, ColumnDataSource, Range1d, LinearAxis
from bokeh.palettes import Category20, Viridis256
from bokeh.transform import factor_cmap
import pandas as pd
import numpy as np

# Jupyter Notebook中显示
output_notebook()

# 或者输出到HTML文件
# output_file("bokeh_plot.html")
```

**基本图表创建**
```python
# 创建基础图形对象
p = figure(
    title="基础Bokeh图表",
    width=800, 
    height=400,
    x_axis_label='X轴',
    y_axis_label='Y轴',
    toolbar_location="above"
)

# 生成示例数据
x = np.linspace(0, 4*np.pi, 100)
y = np.sin(x)

# 添加线图
line = p.line(x, y, legend_label="sin(x)", line_width=2, color='navy')

# 添加圆点
circles = p.circle(x[::5], y[::5], legend_label="采样点", size=8, color='red', alpha=0.6)

# 设置图例
p.legend.location = "top_right"
p.legend.click_policy = "hide"

show(p)
```

#### 基本图表类型

**线图和散点图**
```python
# 创建多种线图
p1 = figure(title="多线图示例", width=600, height=400)

# 数据准备
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)
y3 = np.sin(x) * np.cos(x)

# 添加多条线
p1.line(x, y1, legend_label="sin(x)", line_width=2, color='red')
p1.line(x, y2, legend_label="cos(x)", line_width=2, color='blue', line_dash='dashed')
p1.line(x, y3, legend_label="sin(x)*cos(x)", line_width=2, color='green', line_dash='dotted')

# 散点图
p2 = figure(title="散点图示例", width=600, height=400)

# 生成随机数据
n = 100
x_scatter = np.random.random(n) * 100
y_scatter = np.random.random(n) * 100
colors = np.random.choice(['red', 'green', 'blue', 'orange', 'purple'], n)
sizes = np.random.randint(10, 30, n)

p2.scatter(x_scatter, y_scatter, size=sizes, color=colors, alpha=0.6)

# 显示图表
show(column(p1, p2))
```

**柱状图和条形图**
```python
# 柱状图
categories = ['产品A', '产品B', '产品C', '产品D', '产品E']
values = [23, 45, 56, 78, 32]

p3 = figure(x_range=categories, title="产品销售对比", width=600, height=400)

# 创建柱状图
bars = p3.vbar(x=categories, top=values, width=0.8, 
               color=factor_cmap('x', palette=Category20[5], factors=categories))

# 添加数值标签
from bokeh.models import LabelSet
source = ColumnDataSource(data=dict(x=categories, y=values))
labels = LabelSet(x='x', y='y', text='y', level='glyph',
                 x_offset=-10, y_offset=5, source=source)
p3.add_layout(labels)

# 水平条形图
p4 = figure(y_range=categories, title="水平条形图", width=600, height=400)
p4.hbar(y=categories, right=values, height=0.8, color='lightblue')

show(row(p3, p4))
```

**时间序列图**
```python
# 时间序列数据
dates = pd.date_range('2023-01-01', periods=100, freq='D')
values = np.cumsum(np.random.randn(100)) + 100

# 创建时间序列图
p5 = figure(title="时间序列图", width=800, height=400, x_axis_type='datetime')

# 添加线图
p5.line(dates, values, line_width=2, color='navy')

# 添加圆点标记
p5.circle(dates[::10], values[::10], size=8, color='red', alpha=0.8)

# 设置日期格式
from bokeh.models import DatetimeTickFormatter
p5.xaxis.formatter = DatetimeTickFormatter(
    hours=["%d %B %Y"],
    days=["%d %B %Y"],
    months=["%d %B %Y"],
    years=["%d %B %Y"],
)

show(p5)
```

#### 交互式功能

**悬停工具和选择**
```python
# 创建带悬停工具的散点图
source = ColumnDataSource(data=dict(
    x=np.random.random(100) * 100,
    y=np.random.random(100) * 100,
    size=np.random.randint(10, 30, 100),
    color=np.random.choice(['red', 'green', 'blue', 'orange'], 100),
    alpha=np.random.random(100),
    name=['点' + str(i) for i in range(100)]
))

# 创建悬停工具
hover = HoverTool(tooltips=[
    ("索引", "$index"),
    ("名称", "@name"),
    ("坐标", "($x, $y)"),
    ("大小", "@size")
])

p6 = figure(title="交互式散点图", width=600, height=400, tools=[hover, 'pan', 'wheel_zoom', 'reset'])

# 添加散点
circles = p6.circle('x', 'y', size='size', color='color', alpha='alpha', source=source)

show(p6)
```

**缩放和平移**
```python
# 创建可缩放的大数据集图表
n = 10000
x_large = np.random.randn(n)
y_large = np.random.randn(n)

p7 = figure(title="大数据集可视化", width=800, height=600, 
           tools='pan,wheel_zoom,box_zoom,reset,save')

# 使用alpha通道处理重叠
p7.circle(x_large, y_large, size=3, alpha=0.1, color='navy')

# 添加选择工具
from bokeh.models import BoxSelectTool, LassoSelectTool
p7.add_tools(BoxSelectTool())
p7.add_tools(LassoSelectTool())

show(p7)
```

#### 布局与组合

**多图布局**
```python
# 创建多个子图
p8 = figure(title="图1", width=300, height=300)
p8.circle([1, 2, 3], [1, 4, 2], size=20, color='red')

p9 = figure(title="图2", width=300, height=300)
p9.line([1, 2, 3, 4], [1, 3, 2, 4], line_width=3, color='blue')

p10 = figure(title="图3", width=300, height=300)
p10.vbar(x=[1, 2, 3], top=[1, 3, 2], width=0.5, color='green')

p11 = figure(title="图4", width=300, height=300)
p11.triangle([1, 2, 3], [1, 3, 2], size=20, color='orange')

# 网格布局
grid = gridplot([[p8, p9], [p10, p11]], sizing_mode='scale_width')
show(grid)
```

**复杂仪表板布局**
```python
from bokeh.layouts import layout
from bokeh.models import Div

# 创建标题
title = Div(text="<h1>销售数据仪表板</h1>", width=800, height=50)

# 主图表
main_plot = figure(title="月度销售趋势", width=600, height=400)
months = ['1月', '2月', '3月', '4月', '5月', '6月']
sales = [120, 135, 140, 155, 168, 180]
main_plot.line(range(len(months)), sales, line_width=3, color='navy')
main_plot.circle(range(len(months)), sales, size=10, color='red')
main_plot.xaxis.ticker = list(range(len(months)))
main_plot.xaxis.major_label_overrides = dict(zip(range(len(months)), months))

# 侧边图表
side_plot1 = figure(title="产品分布", width=300, height=200)
products = ['A', 'B', 'C', 'D']
counts = [25, 35, 20, 30]
side_plot1.vbar(x=products, top=counts, width=0.8, color='lightblue')

side_plot2 = figure(title="地区销售", width=300, height=200)
regions = ['北区', '南区', '东区', '西区']
region_sales = [40, 30, 20, 35]
side_plot2.vbar(x=regions, top=region_sales, width=0.8, color='lightgreen')

# 组合布局
dashboard = layout([
    [title],
    [main_plot, column(side_plot1, side_plot2)]
])

show(dashboard)
```

#### Pandas-Bokeh 集成

**快速绘图**
```python
import pandas_bokeh

# 设置输出到notebook
pandas_bokeh.output_notebook()

# 创建示例数据
df = pd.DataFrame({
    'date': pd.date_range('2023-01-01', periods=100, freq='D'),
    'sales': np.cumsum(np.random.randn(100)) + 1000,
    'profit': np.cumsum(np.random.randn(100)) + 200,
    'category': np.random.choice(['A', 'B', 'C'], 100)
})

# 快速线图
df.plot_bokeh.line(
    x='date',
    y=['sales', 'profit'],
    title='销售和利润趋势',
    figsize=(800, 400)
)

# 快速柱状图
category_summary = df.groupby('category').agg({
    'sales': 'mean',
    'profit': 'mean'
}).reset_index()

category_summary.plot_bokeh.bar(
    x='category',
    y=['sales', 'profit'],
    title='各类别平均销售和利润',
    stacked=True,
    figsize=(600, 400)
)

# 散点图
df.plot_bokeh.scatter(
    x='sales',
    y='profit',
    category='category',
    title='销售vs利润散点图',
    figsize=(600, 400),
    colormap=['red', 'green', 'blue']
)
```

#### 高级应用

**实时数据更新**
```python
from bokeh.models import ColumnDataSource
from bokeh.io import curdoc
from bokeh.plotting import figure
import random

# 创建数据源
source = ColumnDataSource(data=dict(x=[], y=[]))

# 创建图表
p = figure(title="实时数据流", width=600, height=400)
line = p.line('x', 'y', source=source, line_width=2, color='navy')

# 更新函数
def update():
    new_data = dict(
        x=[source.data['x'][-1] + 1 if source.data['x'] else 0],
        y=[random.random()]
    )
    source.stream(new_data, rollover=100)  # 保持最近100个点

# 添加定期回调（在Bokeh服务器中使用）
# curdoc().add_periodic_callback(update, 100)

show(p)
```

**自定义交互**
```python
from bokeh.models import CustomJS, Slider
from bokeh.layouts import column

# 创建数据
x = np.linspace(0, 4*np.pi, 100)
y = np.sin(x)
source = ColumnDataSource(data=dict(x=x, y=y))

# 创建图表
plot = figure(title="交互式正弦波", width=600, height=400)
line = plot.line('x', 'y', source=source, line_width=2, color='navy')

# 创建滑块
freq_slider = Slider(start=0.1, end=5, value=1, step=0.1, title="频率")
amp_slider = Slider(start=0.1, end=3, value=1, step=0.1, title="振幅")

# JavaScript回调
callback = CustomJS(args=dict(source=source, freq=freq_slider, amp=amp_slider), code="""
    const data = source.data;
    const f = freq.value;
    const a = amp.value;
    const x = data['x'];
    const y = data['y'];
    for (let i = 0; i < x.length; i++) {
        y[i] = a * Math.sin(f * x[i]);
    }
    source.change.emit();
""")

freq_slider.js_on_change('value', callback)
amp_slider.js_on_change('value', callback)

# 组合布局
layout = column(freq_slider, amp_slider, plot)
show(layout)
```
xi.toolbar_location:  (None, "above", "below", "left" or "right").
matplot


tushare
1.获取api 
a.pro = ts.pro_api('5d03fb68286c12bd294170ab5e8768b28e148a5e420d47b4b3b884dd')
2.获取所有股票
a.all_stock = pro.stock_basic()
3.通用行情接口
a.df = ts.pro_bar(ts_code='000001.SZ', adj='qfq', start_date='20180101', end_date='20181011',ma=[5, 20, 50],factors=['tor', 'vr'])
b.参数
i.asset    资产类别：E股票 I沪深指数 C数字货币 FT期货 FD基金 O期权 CB可转债（v1.2.39），默认E
ii.adj    复权类型(只针对股票)：None未复权 qfq前复权 hfq后复权 , 默认None
iii.freq    数据频度 ：支持分钟(min)/日(D)/周(W)/月(M)K线，其中1min表示1分钟（类推1/5/15/30/60分钟） ，默认D
iv.ma    均线，支持任意合理int数值 e.g: ma_5表示5日均价，ma_v_5表示5日均量
v.factors    股票因子（asset='E'有效）支持 tor换手率 vr量比  factors=['tor', 'vr']
4.获取某一只股票行情
a.pro.daily(ts_code=code)
# 获取一只股票方法
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        return pro.daily(ts_code=code)
5.定义获取股票行情方法
# 根据股票中文名称获取股票行情信息
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        stock=pro.daily(ts_code=code)
        stock.sort_values(by='trade_date',ascending=True,inplace=True)
        stock['trade_date']=stock['trade_date'].astype('datetime64')
        stock['avg_amount']=stock['amount']*10/stock['vol']
        stock['5d_ma']=stock['close'].rolling(5).apply(lambda x:x.mean())
        stock['10d_ma']=stock['close'].rolling(10).apply(lambda x:x.mean())
        stock=stock.dropna(how='any')
        stock.reset_index(inplace=True,drop=True)
        return stock
指标
文档
a.https://zhuanlan.zhihu.com/p/55311293
天勤
b.https://doc.shinnytech.com/tqsdk/latest/reference/tqsdk.ta.html
stockstats
1.文档  https://github.com/jealous/stockstats
2.指标
a.close_-1_s   往前一天的收盘价 、rsi_6_-1_s  6日rsi往前1天的值
b.close_-1_d 收盘价与前一日收盘价的差
c.close_-3,2_max  前三后2共5天内最大值，不包含当前值
d.downs_10_c   最近10天downs值求和
e.high_5_sma 5周期最高价简单移动平均
f.close_10_ema  10周期收盘价指数移动平均
量化工具
supermind
文档
a.http://quant.10jqka.com.cn/platform/html/home.html
