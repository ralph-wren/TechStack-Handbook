# Python 完整技术指南

## 目录
- [Python 完整技术指南](#python-完整技术指南)
  - [目录](#目录)
  - [1. Python 语言基础](#1-python-语言基础)
    - [1.1 Python 概述](#11-python-概述)
      - [1.1.1 Python 特点与优势](#111-python-特点与优势)
      - [1.1.2 Python 解释器架构](#112-python-解释器架构)
    - [1.2 数据类型深度解析](#12-数据类型深度解析)
      - [1.2.1 内置数据类型体系](#121-内置数据类型体系)
      - [1.2.2 数据类型详解与性能特性](#122-数据类型详解与性能特性)
    - [1.3 控制流与逻辑结构](#13-控制流与逻辑结构)
      - [1.3.1 条件控制的高级用法](#131-条件控制的高级用法)
      - [1.3.2 循环控制的高级技巧](#132-循环控制的高级技巧)
    - [1.4 函数与作用域](#14-函数与作用域)
      - [1.4.1 函数参数的高级特性](#141-函数参数的高级特性)
      - [1.4.2 作用域与LEGB规则](#142-作用域与legb规则)
    - [1.5 模块与包管理](#15-模块与包管理)
      - [1.5.1 模块导入机制深度解析](#151-模块导入机制深度解析)
      - [1.5.2 包管理最佳实践](#152-包管理最佳实践)
  - [2. 面向对象编程](#2-面向对象编程)
    - [2.1 类与对象](#21-类与对象)
      - [2.1.1 类的定义与实例化](#211-类的定义与实例化)
      - [2.1.2 属性访问控制](#212-属性访问控制)
    - [2.2 继承与多态](#22-继承与多态)
      - [2.2.1 单继承与方法重写](#221-单继承与方法重写)
      - [2.2.2 多重继承与MRO](#222-多重继承与mro)
    - [2.3 特殊方法与运算符重载](#23-特殊方法与运算符重载)
    - [2.4 属性与描述符](#24-属性与描述符)
      - [2.4.1 属性装饰器](#241-属性装饰器)
      - [2.4.2 描述符协议](#242-描述符协议)
  - [Python 高级特性](#python-高级特性)
    - [装饰器](#装饰器)
  - [4. 内存管理与性能优化](#4-内存管理与性能优化)
    - [4.1 Python 内存模型](#41-python-内存模型)
      - [4.1.1 对象内存结构](#411-对象内存结构)
    - [4.2 垃圾回收机制](#42-垃圾回收机制)
    - [4.3 性能分析与优化](#43-性能分析与优化)
  - [环境与工具](#环境与工具)
    - [搭建环境](#搭建环境)
    - [包管理工具](#包管理工具)
    - [虚拟环境](#虚拟环境)
    - [常用开发工具](#常用开发工具)
  - [数据处理与分析](#数据处理与分析)
    - [NumPy 基础](#numpy-基础)
    - [Pandas 基础](#pandas-基础)
  - [matplotlib](#matplotlib)
    - [实战应用](#实战应用)
- [作图](#作图)
- [组合](#组合)
- [获取一只股票方法](#获取一只股票方法)
- [根据股票中文名称获取股票行情信息](#根据股票中文名称获取股票行情信息)

## 1. Python 语言基础

### 1.1 Python 概述

#### 1.1.1 Python 特点与优势

**Python核心特点**：
- **简洁优雅**：语法简单，代码可读性强
- **动态类型**：运行时确定变量类型
- **解释执行**：无需编译，开发效率高
- **丰富生态**：拥有庞大的第三方库生态
- **跨平台**：支持Windows、Linux、macOS

**Python应用领域**：

| 领域 | 主要框架/库 | 应用场景 |
|------|-------------|----------|
| **Web开发** | Django、Flask、FastAPI | 网站、API服务 |
| **数据科学** | NumPy、Pandas、Matplotlib | 数据分析、可视化 |
| **机器学习** | TensorFlow、PyTorch、Scikit-learn | AI模型开发 |
| **自动化** | Selenium、Beautiful Soup | 爬虫、自动化测试 |
| **DevOps** | Ansible、SaltStack | 运维自动化 |

#### 1.1.2 Python 解释器架构

```mermaid
graph TB
    subgraph "Python代码执行流程"
        SOURCE[Python源代码<br/>.py文件]
        LEXER[词法分析器<br/>Lexer]
        PARSER[语法分析器<br/>Parser]
        AST[抽象语法树<br/>AST]
        COMPILER[字节码编译器<br/>Compiler]
        BYTECODE[字节码<br/>.pyc文件]
        PVM[Python虚拟机<br/>PVM]
        RESULT[执行结果]
    end
    
    SOURCE --> LEXER
    LEXER --> PARSER
    PARSER --> AST
    AST --> COMPILER
    COMPILER --> BYTECODE
    BYTECODE --> PVM
    PVM --> RESULT
```

**CPython执行原理**：
1. **词法分析**：将源代码分解为Token
2. **语法分析**：构建抽象语法树(AST)
3. **字节码编译**：AST编译为字节码
4. **虚拟机执行**：PVM解释执行字节码

### 1.2 数据类型深度解析

#### 1.2.1 内置数据类型体系

```mermaid
graph TB
    subgraph "Python数据类型"
        ROOT[Python对象]
        
        subgraph "数值类型"
            INT[int 整数]
            FLOAT[float 浮点数]
            COMPLEX[complex 复数]
            BOOL[bool 布尔值]
        end
        
        subgraph "序列类型"
            STR[str 字符串]
            LIST[list 列表]
            TUPLE[tuple 元组]
            RANGE[range 范围]
        end
        
        subgraph "映射类型"
            DICT[dict 字典]
        end
        
        subgraph "集合类型"
            SET[set 集合]
            FROZENSET[frozenset 不可变集合]
        end
        
        subgraph "其他类型"
            NONE[None 空值]
            BYTES[bytes 字节序列]
            BYTEARRAY[bytearray 可变字节序列]
        end
    end
    
    ROOT --> INT
    ROOT --> FLOAT
    ROOT --> COMPLEX
    ROOT --> BOOL
    ROOT --> STR
    ROOT --> LIST
    ROOT --> TUPLE
    ROOT --> RANGE
    ROOT --> DICT
    ROOT --> SET
    ROOT --> FROZENSET
    ROOT --> NONE
    ROOT --> BYTES
    ROOT --> BYTEARRAY
```

#### 1.2.2 数据类型详解与性能特性

**数值类型深度解析**：
```python
# 整数类型 - 无限精度
big_int = 2 ** 1000  # Python支持任意大整数
print(type(big_int))  # <class 'int'>

# 浮点数类型 - IEEE 754双精度
pi = 3.141592653589793
print(f"浮点数精度：{pi:.15f}")

# 复数类型
z = 3 + 4j
print(f"复数模长：{abs(z)}")  # 5.0

# 布尔值 - 整数子类
print(True + True)  # 2
print(isinstance(True, int))  # True
```

**字符串类型深度解析**：
```python
# 字符串不可变性验证
s1 = "hello"
s2 = s1
s1 += " world"
print(f"s1: {s1}, s2: {s2}")  # s1: hello world, s2: hello
print(f"id相同: {id(s1) == id(s2)}")  # False

# 字符串intern机制
a = "python"
b = "python"
print(f"字符串intern: {a is b}")  # True

# 字符串格式化性能对比
import timeit

# f-string (最快)
def f_string_format():
    name, age = "Alice", 25
    return f"Name: {name}, Age: {age}"

# str.format()
def str_format():
    name, age = "Alice", 25
    return "Name: {}, Age: {}".format(name, age)

# % 格式化
def percent_format():
    name, age = "Alice", 25
    return "Name: %s, Age: %d" % (name, age)

print("f-string 性能最优")
```

**容器类型性能分析**：

| 操作 | list | tuple | dict | set |
|------|------|-------|------|-----|
| **创建** | O(n) | O(n) | O(n) | O(n) |
| **访问** | O(1) | O(1) | O(1) | - |
| **查找** | O(n) | O(n) | O(1) | O(1) |
| **插入** | O(1)/O(n) | 不可变 | O(1) | O(1) |
| **删除** | O(n) | 不可变 | O(1) | O(1) |

```python
# 列表与元组性能对比
import sys

list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(f"列表内存占用: {sys.getsizeof(list_obj)} bytes")
print(f"元组内存占用: {sys.getsizeof(tuple_obj)} bytes")

# 字典内部结构演示
class HashDict:
    """简化的字典实现，展示哈希表原理"""
    def __init__(self, size=8):
        self.size = size
        self.buckets = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        bucket = self.buckets[self._hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))
    
    def get(self, key):
        bucket = self.buckets[self._hash(key)]
        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)

# 演示哈希冲突
hash_dict = HashDict(4)
hash_dict.put("a", 1)
hash_dict.put("b", 2)
print(f"获取值: {hash_dict.get('a')}")
```

### 1.3 控制流与逻辑结构

#### 1.3.1 条件控制的高级用法

```python
# 三元运算符
result = "positive" if x > 0 else "non-positive"

# 链式比较
if 0 < x < 10:
    print("x在0到10之间")

# 短路求值
def expensive_function():
    print("执行昂贵操作")
    return True

# 只有当condition为False时才会执行expensive_function
condition = True
result = condition or expensive_function()

# match-case语句 (Python 3.10+)
def handle_data(data):
    match data:
        case int() if data > 0:
            return f"正整数: {data}"
        case int() if data < 0:
            return f"负整数: {data}"
        case 0:
            return "零"
        case str() if len(data) > 0:
            return f"非空字符串: {data}"
        case []:
            return "空列表"
        case [x] if isinstance(x, int):
            return f"单元素整数列表: {x}"
        case [x, y]:
            return f"双元素列表: {x}, {y}"
        case {"name": str(name), "age": int(age)}:
            return f"人员信息: {name}, {age}岁"
        case _:
            return "未知类型"

# 测试match-case
print(handle_data(42))  # 正整数: 42
print(handle_data([1, 2]))  # 双元素列表: 1, 2
print(handle_data({"name": "Alice", "age": 25}))  # 人员信息: Alice, 25岁
```

#### 1.3.2 循环控制的高级技巧

```python
# enumerate获取索引和值
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")

# zip并行迭代
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
cities = ['New York', 'London', 'Tokyo']

for name, age, city in zip(names, ages, cities):
    print(f"{name}, {age}岁, 住在{city}")

# zip_longest处理不等长序列
from itertools import zip_longest

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for num, letter in zip_longest(list1, list2, fillvalue=0):
    print(f"{num} - {letter}")

# 列表推导式的高级用法
# 带条件的列表推导式
squares = [x**2 for x in range(10) if x % 2 == 0]

# 嵌套列表推导式
matrix = [[i + j for j in range(3)] for i in range(3)]

# 字典推导式
word_lengths = {word: len(word) for word in ['python', 'java', 'go']}

# 集合推导式
unique_lengths = {len(word) for word in ['python', 'java', 'go', 'rust']}

# 生成器表达式（内存友好）
large_squares = (x**2 for x in range(1000000))
```

### 1.4 函数与作用域

#### 1.4.1 函数参数的高级特性

```python
# 参数类型完整示例
def complex_function(
    pos_only, /,                    # 仅位置参数
    pos_or_kw,                      # 位置或关键字参数
    *args,                          # 可变位置参数
    kw_only,                        # 仅关键字参数
    kw_with_default="default",      # 带默认值的关键字参数
    **kwargs                        # 可变关键字参数
):
    print(f"pos_only: {pos_only}")
    print(f"pos_or_kw: {pos_or_kw}")
    print(f"args: {args}")
    print(f"kw_only: {kw_only}")
    print(f"kw_with_default: {kw_with_default}")
    print(f"kwargs: {kwargs}")

# 调用示例
complex_function(
    1,                              # pos_only
    2,                              # pos_or_kw
    3, 4, 5,                        # args
    kw_only="required",             # kw_only
    extra1="value1",                # kwargs
    extra2="value2"                 # kwargs
)

# 函数注解与类型提示
from typing import List, Dict, Optional, Union, Callable

def process_data(
    data: List[int],
    multiplier: float = 1.0,
    formatter: Optional[Callable[[float], str]] = None
) -> Dict[str, Union[int, float, str]]:
    """
    处理数据并返回统计信息
    
    Args:
        data: 整数列表
        multiplier: 乘数因子
        formatter: 可选的格式化函数
    
    Returns:
        包含统计信息的字典
    """
    total = sum(data) * multiplier
    avg = total / len(data) if data else 0
    
    result = {
        "count": len(data),
        "total": total,
        "average": avg
    }
    
    if formatter:
        result["formatted_total"] = formatter(total)
    
    return result

# 使用示例
numbers = [1, 2, 3, 4, 5]
stats = process_data(numbers, 2.0, lambda x: f"${x:.2f}")
print(stats)
```

#### 1.4.2 作用域与LEGB规则

```mermaid
graph TB
    subgraph "LEGB作用域解析顺序"
        L[Local 局部作用域<br/>函数内部定义的变量]
        E[Enclosing 闭包作用域<br/>外层函数的局部变量]
        G[Global 全局作用域<br/>模块级别的变量]
        B[Built-in 内置作用域<br/>内置函数和异常]
    end
    
    L --> E
    E --> G
    G --> B
```

```python
# LEGB作用域演示
builtin_name = "内置"  # 这实际上会覆盖内置作用域

global_var = "全局变量"

def outer_function():
    enclosing_var = "闭包变量"
    
    def inner_function():
        local_var = "局部变量"
        
        # 演示作用域查找顺序
        print(f"局部: {local_var}")
        print(f"闭包: {enclosing_var}")
        print(f"全局: {global_var}")
        
        # 使用nonlocal修改闭包变量
        nonlocal enclosing_var
        enclosing_var = "修改后的闭包变量"
        
        # 使用global修改全局变量
        global global_var
        global_var = "修改后的全局变量"
    
    inner_function()
    print(f"外层函数中的闭包变量: {enclosing_var}")
    return inner_function

# 闭包示例
def create_multiplier(factor):
    """创建一个乘法器闭包"""
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(f"double(5) = {double(5)}")  # 10
print(f"triple(5) = {triple(5)}")  # 15

# 查看闭包变量
print(f"double的闭包变量: {double.__closure__[0].cell_contents}")  # 2
```

### 1.5 模块与包管理

#### 1.5.1 模块导入机制深度解析

```python
# 模块搜索路径
import sys
print("Python模块搜索路径:")
for path in sys.path:
    print(f"  {path}")

# 动态导入模块
import importlib

def dynamic_import(module_name, function_name):
    """动态导入模块中的函数"""
    try:
        module = importlib.import_module(module_name)
        function = getattr(module, function_name)
        return function
    except (ImportError, AttributeError) as e:
        print(f"导入失败: {e}")
        return None

# 模块重新加载
def reload_module(module):
    """重新加载模块（开发时有用）"""
    return importlib.reload(module)

# 相对导入和绝对导入
# 包结构示例：
# myproject/
#   __init__.py
#   main.py
#   utils/
#     __init__.py
#     helpers.py
#     math_utils.py

# 在 myproject/main.py 中：
# 绝对导入
# from myproject.utils.helpers import some_function

# 相对导入
# from .utils.helpers import some_function
# from ..other_package import other_function
```

#### 1.5.2 包管理最佳实践

```python
# __init__.py 文件的高级用法
# mypackage/__init__.py

# 控制 from mypackage import * 的行为
__all__ = ['PublicClass', 'public_function']

# 包级别的初始化代码
print(f"正在初始化包: {__name__}")

# 延迟导入，避免循环依赖
def get_heavy_module():
    """延迟导入重型模块"""
    import heavy_module
    return heavy_module

# 版本信息
__version__ = "1.0.0"
__author__ = "Your Name"

# 子模块的便捷访问
from .submodule import important_function

class PublicClass:
    """包的公共类"""
    pass

def public_function():
    """包的公共函数"""
    pass

# 包的命名空间包（PEP 420）
# 不需要 __init__.py 文件，允许分布式包结构
```

**包结构最佳实践**：
```
myproject/
├── README.md
├── setup.py
├── requirements.txt
├── myproject/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── models.py
│   │   └── services.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── helpers.py
│   │   └── validators.py
│   └── tests/
│       ├── __init__.py
│       ├── test_core.py
│       └── test_utils.py
└── docs/
    └── api.md
```

## 2. 面向对象编程

### 2.1 类与对象

#### 2.1.1 类的定义与实例化

```python
class Person:
    """人员类示例"""
    
    # 类变量
    species = "Homo sapiens"
    population = 0
    
    def __init__(self, name, age, email=None):
        """构造函数"""
        # 实例变量
        self.name = name
        self.age = age
        self.email = email
        
        # 更新类变量
        Person.population += 1
    
    def __str__(self):
        """字符串表示"""
        return f"Person(name='{self.name}', age={self.age})"
    
    def __repr__(self):
        """调试表示"""
        return f"Person('{self.name}', {self.age}, '{self.email}')"
    
    def greet(self):
        """实例方法"""
        return f"Hello, I'm {self.name}"
    
    @classmethod
    def get_population(cls):
        """类方法"""
        return cls.population
    
    @staticmethod
    def is_adult(age):
        """静态方法"""
        return age >= 18
    
    def __del__(self):
        """析构函数"""
        Person.population -= 1

# 使用示例
person1 = Person("Alice", 25, "alice@example.com")
person2 = Person("Bob", 17)

print(person1.greet())  # Hello, I'm Alice
print(Person.get_population())  # 2
print(Person.is_adult(person2.age))  # False
```

#### 2.1.2 属性访问控制

```python
class BankAccount:
    """银行账户类，演示访问控制"""
    
    def __init__(self, account_number, initial_balance=0):
        self.account_number = account_number  # 公开属性
        self._balance = initial_balance       # 受保护属性（约定）
        self.__pin = "1234"                  # 私有属性（名称修饰）
    
    @property
    def balance(self):
        """余额属性的getter"""
        return self._balance
    
    @balance.setter
    def balance(self, value):
        """余额属性的setter"""
        if value < 0:
            raise ValueError("余额不能为负数")
        self._balance = value
    
    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self._balance += amount
            return True
        return False
    
    def withdraw(self, amount, pin):
        """取款"""
        if pin != self.__pin:
            raise ValueError("PIN码错误")
        if amount > self._balance:
            raise ValueError("余额不足")
        self._balance -= amount
        return True
    
    def _internal_audit(self):
        """受保护方法"""
        return f"账户 {self.account_number} 余额审计: {self._balance}"
    
    def __validate_transaction(self, amount):
        """私有方法"""
        return amount > 0 and amount <= self._balance

# 使用示例
account = BankAccount("123456789", 1000)
print(f"余额: {account.balance}")  # 1000

account.deposit(500)
print(f"存款后余额: {account.balance}")  # 1500

# 私有属性的名称修饰
print(f"私有属性实际名称: {account._BankAccount__pin}")  # 1234
```

### 2.2 继承与多态

#### 2.2.1 单继承与方法重写

```python
class Animal:
    """动物基类"""
    
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        """发出声音 - 抽象方法"""
        raise NotImplementedError("子类必须实现此方法")
    
    def info(self):
        """获取动物信息"""
        return f"{self.name} is a {self.species}"

class Dog(Animal):
    """狗类"""
    
    def __init__(self, name, breed):
        super().__init__(name, "Dog")  # 调用父类构造函数
        self.breed = breed
    
    def make_sound(self):
        """重写父类方法"""
        return f"{self.name} says Woof!"
    
    def fetch(self):
        """狗特有的方法"""
        return f"{self.name} is fetching the ball"

class Cat(Animal):
    """猫类"""
    
    def __init__(self, name, indoor=True):
        super().__init__(name, "Cat")
        self.indoor = indoor
    
    def make_sound(self):
        return f"{self.name} says Meow!"
    
    def climb(self):
        return f"{self.name} is climbing"

# 多态演示
def animal_concert(animals):
    """动物演唱会 - 多态的体现"""
    for animal in animals:
        print(animal.make_sound())

# 使用示例
dog = Dog("Buddy", "Golden Retriever")
cat = Cat("Whiskers", indoor=True)

animals = [dog, cat]
animal_concert(animals)
# Buddy says Woof!
# Whiskers says Meow!

# 检查继承关系
print(isinstance(dog, Animal))  # True
print(issubclass(Dog, Animal))  # True
```

#### 2.2.2 多重继承与MRO

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

# 方法解析顺序（MRO）
print(D.mro())
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

d = D()
d.method()
# D.method
# B.method
# C.method
# A.method

# Mixin模式示例
class TimestampMixin:
    """时间戳混入类"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        from datetime import datetime
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def touch(self):
        """更新时间戳"""
        from datetime import datetime
        self.updated_at = datetime.now()

class LoggingMixin:
    """日志混入类"""
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class User(TimestampMixin, LoggingMixin):
    """用户类，使用多个Mixin"""
    def __init__(self, username):
        super().__init__()
        self.username = username
        self.log(f"User {username} created")
    
    def update_profile(self):
        self.touch()
        self.log("Profile updated")

user = User("alice")
user.update_profile()
```

### 2.3 特殊方法与运算符重载

```python
class Vector:
    """二维向量类，演示运算符重载"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        """字符串表示"""
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        """调试表示"""
        return f"Vector({self.x!r}, {self.y!r})"
    
    def __add__(self, other):
        """向量加法"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __sub__(self, other):
        """向量减法"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    def __mul__(self, scalar):
        """标量乘法"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __rmul__(self, scalar):
        """反向标量乘法"""
        return self.__mul__(scalar)
    
    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False
    
    def __lt__(self, other):
        """小于比较（按长度）"""
        if isinstance(other, Vector):
            return self.magnitude() < other.magnitude()
        return NotImplemented
    
    def __len__(self):
        """长度（转换为整数）"""
        return int(self.magnitude())
    
    def __bool__(self):
        """布尔值转换"""
        return self.magnitude() != 0
    
    def __getitem__(self, key):
        """索引访问"""
        if key == 0:
            return self.x
        elif key == 1:
            return self.y
        else:
            raise IndexError("Vector只有两个分量")
    
    def __setitem__(self, key, value):
        """索引赋值"""
        if key == 0:
            self.x = value
        elif key == 1:
            self.y = value
        else:
            raise IndexError("Vector只有两个分量")
    
    def magnitude(self):
        """计算向量长度"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def dot(self, other):
        """点积"""
        return self.x * other.x + self.y * other.y

# 使用示例
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)  # Vector(4, 6)
print(v1 * 2)   # Vector(6, 8)
print(2 * v1)   # Vector(6, 8)
print(v1[0])    # 3
print(len(v1))  # 5
print(bool(v1)) # True
print(v1 == v2) # False
```

### 2.4 属性与描述符

#### 2.4.1 属性装饰器

```python
class Temperature:
    """温度类，演示属性装饰器"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """摄氏度"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """华氏度"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9
    
    @property
    def kelvin(self):
        """开尔文"""
        return self._celsius + 273.15
    
    @kelvin.setter
    def kelvin(self, value):
        self.celsius = value - 273.15

# 使用示例
temp = Temperature(25)
print(f"摄氏度: {temp.celsius}")    # 25
print(f"华氏度: {temp.fahrenheit}")  # 77.0
print(f"开尔文: {temp.kelvin}")     # 298.15

temp.fahrenheit = 100
print(f"摄氏度: {temp.celsius}")    # 37.77777777777778
```

#### 2.4.2 描述符协议

```python
class ValidatedAttribute:
    """验证描述符"""
    
    def __init__(self, validator=None, default=None):
        self.validator = validator
        self.default = default
        self.name = None
    
    def __set_name__(self, owner, name):
        """当描述符被赋值给类属性时调用"""
        self.name = name
        self.private_name = f'_{name}'
    
    def __get__(self, instance, owner):
        """获取属性值"""
        if instance is None:
            return self
        return getattr(instance, self.private_name, self.default)
    
    def __set__(self, instance, value):
        """设置属性值"""
        if self.validator:
            value = self.validator(value)
        setattr(instance, self.private_name, value)
    
    def __delete__(self, instance):
        """删除属性"""
        delattr(instance, self.private_name)

# 验证函数
def positive_number(value):
    """验证正数"""
    if not isinstance(value, (int, float)):
        raise TypeError("必须是数字")
    if value <= 0:
        raise ValueError("必须是正数")
    return value

def non_empty_string(value):
    """验证非空字符串"""
    if not isinstance(value, str):
        raise TypeError("必须是字符串")
    if not value.strip():
        raise ValueError("不能是空字符串")
    return value.strip()

class Product:
    """产品类，使用描述符进行验证"""
    
    name = ValidatedAttribute(non_empty_string)
    price = ValidatedAttribute(positive_number)
    quantity = ValidatedAttribute(positive_number, default=1)
    
    def __init__(self, name, price, quantity=1):
        self.name = name
        self.price = price
        self.quantity = quantity
    
    @property
    def total_value(self):
        return self.price * self.quantity

# 使用示例
product = Product("Laptop", 999.99, 2)
print(f"产品: {product.name}, 总价值: ${product.total_value}")

# 验证会自动触发
try:
    product.price = -100  # 将触发ValueError
except ValueError as e:
    print(f"验证错误: {e}")
```

## Python 高级特性

### 装饰器

## 4. 内存管理与性能优化

### 4.1 Python 内存模型

#### 4.1.1 对象内存结构

```python
import sys
import gc

# 检查对象内存占用
def check_memory_usage():
    """检查不同数据类型的内存占用"""
    objects = [
        42,                    # int
        3.14,                  # float
        "hello",               # str
        [1, 2, 3],            # list
        (1, 2, 3),            # tuple
        {"a": 1, "b": 2},     # dict
        {1, 2, 3}             # set
    ]
    
    for obj in objects:
        size = sys.getsizeof(obj)
        print(f"{type(obj).__name__}: {obj} -> {size} bytes")

check_memory_usage()

# Python对象引用计数
class RefCountDemo:
    def __init__(self, name):
        self.name = name
    
    def __del__(self):
        print(f"对象 {self.name} 被销毁")

def reference_counting_demo():
    """引用计数演示"""
    obj = RefCountDemo("test")
    print(f"引用计数: {sys.getrefcount(obj)}")  # 包括函数参数的引用
    
    ref1 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    ref2 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    del ref1
    print(f"引用计数: {sys.getrefcount(obj)}")
    
    del ref2
    print(f"引用计数: {sys.getrefcount(obj)}")

reference_counting_demo()
```

### 4.2 垃圾回收机制

```python
import gc
import weakref

# 循环引用问题
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.parent = None
    
    def add_child(self, child):
        child.parent = self
        self.children.append(child)
    
    def __del__(self):
        print(f"节点 {self.value} 被销毁")

def circular_reference_demo():
    """循环引用演示"""
    print("创建循环引用...")
    root = Node("root")
    child = Node("child")
    root.add_child(child)
    
    # 创建循环引用
    child.children.append(root)
    
    print(f"垃圾回收前: {len(gc.get_objects())} 个对象")
    
    # 删除引用
    del root
    del child
    
    print("手动触发垃圾回收...")
    collected = gc.collect()
    print(f"回收了 {collected} 个对象")

# 弱引用解决循环引用
class WeakNode:
    def __init__(self, value):
        self.value = value
        self.children = []
        self._parent = None
    
    @property
    def parent(self):
        return self._parent() if self._parent else None
    
    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value) if value else None
    
    def add_child(self, child):
        child.parent = self
        self.children.append(child)

circular_reference_demo()
```

### 4.3 性能分析与优化

```python
import cProfile
import timeit
from functools import lru_cache
import numpy as np

# 性能分析装饰器
def profile_performance(func):
    """性能分析装饰器"""
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()
        
        result = func(*args, **kwargs)
        
        profiler.disable()
        profiler.print_stats(sort='cumulative')
        
        return result
    return wrapper

# 缓存优化
@lru_cache(maxsize=128)
def fibonacci_cached(n):
    """带缓存的斐波那契函数"""
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_naive(n):
    """朴素的斐波那契函数"""
    if n <= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

# 性能对比
def performance_comparison():
    """性能对比测试"""
    n = 30
    
    # 测试朴素版本
    naive_time = timeit.timeit(
        lambda: fibonacci_naive(n), 
        number=1
    )
    
    # 测试缓存版本
    cached_time = timeit.timeit(
        lambda: fibonacci_cached(n), 
        number=100
    ) / 100
    
    print(f"朴素版本 (n={n}): {naive_time:.6f}秒")
    print(f"缓存版本 (n={n}): {cached_time:.6f}秒")
    print(f"性能提升: {naive_time / cached_time:.2f}倍")

performance_comparison()

# 列表推导式 vs 循环性能
def list_comprehension_vs_loop():
    """列表推导式与循环性能对比"""
    size = 100000
    
    # 列表推导式
    def list_comp():
        return [x**2 for x in range(size) if x % 2 == 0]
    
    # 传统循环
    def traditional_loop():
        result = []
        for x in range(size):
            if x % 2 == 0:
                result.append(x**2)
        return result
    
    # 性能测试
    comp_time = timeit.timeit(list_comp, number=10) / 10
    loop_time = timeit.timeit(traditional_loop, number=10) / 10
    
    print(f"列表推导式: {comp_time:.6f}秒")
    print(f"传统循环: {loop_time:.6f}秒")
    print(f"推导式更快: {loop_time / comp_time:.2f}倍")

list_comprehension_vs_loop()
```

## 环境与工具

### 搭建环境

**创建venv虚拟环境**
```bash
python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt
```

**查看pip位置**
```bash
conda run which pip   
```

**终端配置代理**
```bash
# 设置代理
export http_proxy=http://127.0.0.1:10809  
export https_proxy=http://127.0.0.1:10809 
export ALL_PROXY=socks5://127.0.0.1:10808

# 或者
export http_proxy="http://127.0.0.1:7890"
export https_proxy="http://127.0.0.1:7890"

# 取消代理
unset http_proxy
unset https_proxy
unset all_proxy
```

### 包管理工具

**pip 使用**
```bash
# 安装包
pip install package_name

# 指定镜像源安装
pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple

# 安装特定版本
pip install package_name==1.0.0

# 从requirements.txt安装
pip install -r requirements.txt

# 升级包
pip install --upgrade package_name

# 卸载包
pip uninstall package_name
```

**conda 使用**
```bash
# 添加频道
conda config --add channels conda-forge
conda config --set channel_priority strict

# 安装包
conda install osmium

# 创建环境
conda create -n osm-env python=3.10

# 激活环境
conda activate osm-env

# 安装多个包
conda install -c conda-forge pyosmium pandas
```

### 虚拟环境

**venv**
```bash
# 创建虚拟环境
python -m venv myenv

# 激活虚拟环境(Windows)
myenv\Scripts\activate

# 激活虚拟环境(Linux/Mac)
source myenv/bin/activate

# 退出虚拟环境
deactivate
```

**conda环境**
```bash
# 创建环境
conda create -n myenv python=3.9

# 激活环境
conda activate myenv

# 退出环境
conda deactivate

# 列出所有环境
conda env list
```

### 常用开发工具

**检测当前可用字体**
```python
import matplotlib.font_manager as fm
for font in fm.findSystemFonts(fontpaths=None, fontext='ttf'):
    print(fm.FontProperties(fname=font).get_name())
```

**IDE与编辑器**
- PyCharm: 功能全面的Python IDE
- VS Code: 轻量级编辑器，配合Python扩展使用
- Jupyter Notebook: 交互式开发环境，适合数据分析
- Spyder: 科学计算导向的IDE

## 数据处理与分析

### NumPy 基础

**创建数组**
```python
import numpy as np

# 从列表创建
arr1 = np.array([1, 2, 3, 4, 5])

# 创建特殊数组
zeros = np.zeros((3, 3))  # 全0数组
ones = np.ones((2, 4))    # 全1数组
rand = np.random.random((2, 2))  # 随机数组
arange = np.arange(10)    # 0到9的数组
linspace = np.linspace(0, 1, 5)  # 均匀分布的5个点
```

**数组操作**
```python
# 重塑数组
arr = np.arange(12)
arr_reshaped = arr.reshape(3, 4)

# 数组切片
slice1 = arr_reshaped[0:2, 1:3]

# 数组运算
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
sum_arr = arr1 + arr2
product = arr1 * arr2
dot_product = np.dot(arr1, arr2)
```

### Pandas 基础

**创建数据结构**
```python
import pandas as pd

# 创建Series
s = pd.Series([1, 3, 5, np.nan, 6, 8])

# 创建DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3, 4],
    'B': pd.date_range('20230101', periods=4),
    'C': pd.Series(1, index=list(range(4))),
    'D': np.random.randn(4)
})
```

**数据操作**

**读取文件**
    a.pd.read_csv('data/my_csv.csv')
    b.df_txt = pd.read_table('data/my_table.txt')
    c.df_excel = pd.read_excel('data/my_excel.xlsx')
**写出数据**
a.df.to_csv(‘existing.csv’, mode=’a’, index=False, header=False)  mode 默认w覆盖，a追加
b.b.tail(2).to_csv('../data/fund/20230421.xlsx',mode='a',index=False,header=False)
c.df_txt.to_csv('data/my_txt_saved.txt', sep='\t', index=False)
**df求大小**
a.df.shape[1] 求df列长度
b.df.shape[0] 或者 len(df) 求df的行数
**描述df**
a.info, describe 分别返回表的 信息概况 和表中 数值列对应的主要统计量 
**行列处理**
a.df.drop_duplicates() 删除重复行，如果需要按照列过滤，参数选填['col1', 'col2',...]
b.stock.drop('ts_code',axis=1)  stock.drop(['last','pct_chg'],axis=1)删除列
c.stock.drop(0)   stock.drop([0,1]) 删除行
d.df.column = col_lst 重新制定列名
e.df.rename(index={'row1':'A'}), 重命名索引名 stock.rename(columns=({'last':'last_open'})) 重命名列名
f.df['foo'] = df.Q1 + df.Q2 # 新列为两列相加
g.stock['trade_date']=stock['trade_date'].astype('datetime64')  设置列类型 
h.df.dtypes 查看字段类型
**字段处理**
a.all_stock[all_stock['name'].str.contains('宁德时代')]
b.df['date'] = pd.to_datetime(df['date'])  转为时间类型
c.保留小数点后几位 round('amount',2)
**时间相关**
a.df = pd.DataFrame({'sales': [3, 3, 3, 9, 10, 6],'signups': [4, 5, 6, 10, 12, 13]}, index=pd.date_range(start='2018/01/01', end='2018/07/01', freq='M'))
**获取头部数据**
a.head, tail 函数分别表示返回表或者序列的前 n 行和后 n 行，其中 n 默认为5：
**排序**
a.sort_values、sort_index
a.stock.sort_values('high')  df_demo.sort_values(['Weight','Height'],ascending=[True,False],inplace=True)
**apply方法**
a.stock['diff']=stock.apply(lambda x:x['open']-x['close'],axis=1) 注意axis的值为1是对一行数据处理
b.stock[['open','close','high']].apply(lambda x:x.mean()) axis默认为0，对一列数据处理
**滑动窗口**
a.rolling 、扩张窗口 expanding 以及指数加权窗口 ewm
b.stock['open'].rolling(3,min_periods=1).apply(lambda x:x.mean()) , axis默认为0，在列方向计算，=1在行方向计算,min_periods,表示窗口的最小观测值，即：窗口里面元素的最小数量，默认它是和窗口的长度相等的
c.扩张窗口又称累计窗口，可以理解为一个动态长度的窗口，其窗口的大小就是从序列开始处到具体操作的对应位置，其使用的聚合函数会作用于这些逐步扩张的窗口上。具体地说，设序列为a1, a2, a3, a4，则其每个位置对应的窗口即[a1]、[a1, a2]、[a1, a2, a3]、[a1, a2, a3, a4]。
d.df['tmp']=df['close'].rolling(window=5).apply(lambda t:t.iloc[4])  获取窗口内最后一位元素
**滑动取值**
a.shift, diff, pct_change 公共参数为 periods=n ，默认为1，可以不写
b.分别表示取向前第 n 个元素的值、与向前第 n 个元素做差、与向前第 n 个元素相比计算增长率。这里的 n 可以为负，表示反方向的类似操作。
**索引**
a.loc
i.a.loc[0:1,'trade_date':'vol']  索引取0到1的（不包含1），列取trade_date到vol的（包含vol），返回df
ii.a.loc[0,'trade_date':'vol'] 取索引为0，列取trade_date到vol的（包含vol），返回series
iii.a.loc[0,'trade_date'] 返回索引为0，列为trade_date的值
iv.a.loc[a['index']>0,['open','close']]  对索引返回过滤，列选择一个list
v.df.loc[df['Q1']> 90, 'Q1':] # Q1大于90，只显示Q1
i.df.loc[(df.Q1> 80) & (df.Q2 < 15)] # and关系  多个条件用括号括起来
b.iloc
i.a.iloc[0,1]  返回第1行，第1列的值
ii.a.iloc[0,1:3]  返回第1行，第2，3列的内容
c.df.set_index(keys='trade_date') 设置某一个字段为索引
**query方法**
a.df.query('open>17.50 and open<= 17.56')
b.df.query('open.isin([17.52,17.50])')   stock.query('open not in([12.60,12.41])')
c.df.query('(Grade not in ["Freshman", "Sophomore"]) and (Gender == "Male")')
d.low, high =70, 80    df.query('Weight.between(@low, @high)')   对于 query 中的字符串，如果要引用外部变量，只需在变量名前加 @ 符号
e.也可以使用 or, and, or, isin（==）, not in（！=）
**字段类型转换**
a.df = pd.DataFrame(data, dtype='float32') # 对所有字段指定统一类型
b.df = pd.read_excel(data, dtype={'team':'string', 'Q1': 'int32'}) # 对每个字段分别指定
**随机抽样**
a.sample 函数中的主要参数为 n, axis, frac, replace, weights ，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）
b.df_sample.sample(3, replace = True, weights = df_sample.value)
**分组**
a.df.groupby('open').mean() 
b.df.groupby(df.open>df.avg_open).mean()
c.df.agg({'open':['sum','count'],'close':'max'})
**聚合函数**
a.max/min/mean/median/count/all/any/idxmax/idxmin/mad/nunique/skew/quantile/sum/std/var/sem/size/prod
b.df.agg(lambda x:x.max()-x.min())
c.如果想要对聚合结果的列名进行重命名，只需要将上述函数的位置改写成元组，元组的第一个元素为新的名字，第二个位置为原来的函数，包括聚合字符串和自定义函数
**变换**
a.gb.transform(lambda x: (x-x.mean())/x.std()).head()
b. cumcount/cumsum/cumprod/cummax/cummin 
**过滤**
a.gb.filter(lambda x: x.shape[0] > 100).head() 没看懂
b.df.filter(items=['Q1', 'Q2']) # 选择两列
c.df.filter(regex='Q', axis=1) # 列名包含Q的列
d.df.filter(regex='e$', axis=1) # 以e结尾的列
e.filtered_df = df[df["name"].isin(["Bob", "Dave"])]  
**变形**
a.stock.head().pivot(index='open',columns='close',values='high')
b.df.pivot_table(index='Name',columns='Subject', values='Grade',aggfunc=lambda x:x.std())
c.df.melt(id_vars = ['Class', 'Name'], value_vars = ['Chinese', 'Math'], var_name = 'Subject',value_name = 'Grade')
**索引的变形**
a.stack 的作用就是把列索引的层压入行索引
b.unstack 函数的作用是把行索引转为列索引
**其他变形函数**
a.crosstab
b.explode
c.get_dummies
**连接**
a.df1.merge(df2,how='inner',on='name')
b.df1.merge(df2,left_on='name', right_on='name',how='inner',sort=True)
c.df1.merge(df2,left_on='name', right_on='name',how='inner',suffixes=['_chinese','_math']) 两边相同字段添加不同后缀
d.df1.join(df2， how=left'')  索引连接
e.concat 最常用的有三个参数，它们是 axis, join, keys,axis=0 纵向拼接，=1是横向 pd.concat([a,b])
**缺失数据**
a.缺失数据可以使用 isna 或 isnull （两个函数没有区别）来查看每个单元格是否缺失，结合 
b.pd.notna(basic['市盈率（TTM）']) 筛选某个字段不为空
c.df[sub_set.isna().all(1)] # 全部缺失
d.a[a.isna().any(1)] # 至少有一个缺失 一行里至少有一个字段缺失
e.df[sub_set.notna().all(1)].head() # 没有缺失
**缺失信息的删除**
a.dropna 的主要参数为轴方向 axis （默认为0，即删除行）、删除方式 how 、删除的非缺失值个数阈值 thresh （ 非缺失值 没有达到这个数量的相应维度会被删除）、备选的删除子集 subset ，其中 how 主要有 any 和 all 两种参数可以选择。
b.res = df.dropna(how = 'any', subset = ['Height', 'Weight'])
**缺失值的填充和插值**
a. fillna 中有三个参数是常用的： value, method, limit 。其中， value 为填充值，可以是标量，也可以是索引到元素的字典映射； method 为填充方法，有用前面的元素填充 ffill 和用后面的元素填充 bfill 两种类型， limit 参数表示连续缺失值的最大填充次数。
b.df.fillna(0) 用实数0填充na
**Nullable类型**
a.在 python 中的缺失值用 None 表示，该元素除了等于自己本身之外，与其他任何元素不相等
b.在 numpy 中利用 np.nan 来表示缺失值，该元素除了不和其他任何元素相等之外，和自身的比较结果也返回 False ：
c.对缺失序列或表格的元素进行比较操作的时候， np.nan 的对应位置会返回 False ，但是在使用 equals 函数进行两张表或两个序列的相同性检验时，会自动跳过两侧表都是缺失值的位置，直接返回 True 
d.从字面意义上看 Nullable 就是可空的，言下之意就是序列类型不受缺失值的影响。例如，在上述三个 Nullable 类型中存储缺失值，都会转为 pandas 内置的 pd.NA ：
e.sum, prod 使用加法和乘法的时候，缺失数据等价于被分别视作0和1，即不改变原来的计算结果：
f.当进行单个标量运算的时候，除了 np.nan ** 0 和 1 ** np.nan 这两种情况为确定的值之外，所有运算结果全为缺失（ pd.NA 的行为与此一致 ），并且 np.nan 在比较操作时一定返回 False ，而 pd.NA 返回 pd.NA
**连接mysql**
a.安装包
i.python -m pip install SQLALchemy
b.创建连接引擎
i.con = 'mysql+pymysql://root:Password1?@localhost:3306/mrhd?charset=utf8'
ii.engine = create_engine(con, echo=False)
c.读取数据
i.df=pd.read_sql("select * from azkaban_session_id",con=engine)
d.写出数据
i.b.to_sql(name='azkaban_session_id', con=engine, if_exists='append', index=False, chunksize=1000)
**参数**
a.pd.set_option('display.max_columns', 100)
b.pd.set_option('display.max_rows', 100)
c.pd.set_option('display.float_format', lambda x: '%.2f' % x) 控制展示数值小数位数
d.https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/125012967


## matplotlib

### 实战应用

![图片](assets/image1.png)
```python
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from matplotlib.ticker import FuncFormatter

# 数据准备
data = {
    "key": ["1-5","6-10","11-15","16-20","21-25","26-30","31-35","36-40","41-45","46-50",
           "51-55","56-60","61-65","66-70","71-75","76-80","81-85","86-90","91-95","96-100"],
    "count": [64926535,1138119,411539,216186,131126,89296,66155,52622,45228,32027,
             23867,22066,17321,13541,10670,8168,5837,5157,5305,38348],
    "percentage": [96.53,1.69,0.61,0.32,0.19,0.13,0.10,0.08,0.07,0.05,
                  0.04,0.03,0.03,0.02,0.02,0.01,0.01,0.01,0.01,0.06]
}

df = pd.DataFrame(data)

# 设置样式
plt.style.use('ggplot')

# 解决中文显示问题
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] 
plt.rcParams['axes.unicode_minus'] = False

# 创建图形
fig, ax1 = plt.subplots(figsize=(14, 7))

# 自定义颜色
bar_color = '#4C72B0'
line_color = '#C44E52'

# 柱状图 (左侧Y轴)
bars = ax1.bar(df['key'], df['count'], color=bar_color, alpha=0.7, width=0.8)
ax1.set_ylabel('数量（万）', color=bar_color, fontsize=12)
ax1.tick_params(axis='y', labelcolor=bar_color)
ax1.set_yscale('log')

# 设置Y轴为中文单位（万）
def format_wan(x, pos):
    return f'{x/10000:.0f}万' if x >= 10000 else f'{x:.0f}'

ax1.yaxis.set_major_formatter(FuncFormatter(format_wan))

# 在柱子上添加标签（百分比和数量）
for bar, count, percentage in zip(bars, df['count'], df['percentage']):
    height = bar.get_height()
    count_wan = count/10000
    
    # 在柱子上方显示百分比
    ax1.text(bar.get_x() + bar.get_width()/2, height*1.05, 
            f'{percentage:.2f}%', 
            ha='center', va='bottom', fontsize=9, color='black')
    
    # 在柱子内部显示数量（万）
    ax1.text(bar.get_x() + bar.get_width()/2, height*0.5, 
            f'{count_wan:.1f}万' if count_wan < 10 else f'{count_wan:.0f}万', 
            ha='center', va='center', fontsize=9, color='white',
            fontweight='bold')

# 折线图 (右侧Y轴)
ax2 = ax1.twinx()
line = ax2.plot(df['key'], df['percentage'], color=line_color, 
                marker='o', markersize=6, linewidth=2.5, alpha=0.9)
ax2.set_ylabel('百分比 (%)', color=line_color, fontsize=12)
ax2.tick_params(axis='y', labelcolor=line_color)
ax2.grid(False)
ax2.set_yscale('log')  # 设置右侧Y轴为对数刻度

# 设置百分比的对数刻度格式
def format_percent(x, pos):
    return f'{x:.2f}%' if x >= 0.1 else f'{x:.3f}%'

ax2.yaxis.set_major_formatter(FuncFormatter(format_percent))

# 设置X轴
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.xlim(-0.5, len(df['key'])-0.5)

# 添加标题和网格
plt.title('uuid推测出来wifi数量分布', fontsize=14, pad=20)
ax1.grid(True, which="both", ls="--", linewidth=0.5, alpha=0.3)

# 调整布局
plt.tight_layout()

# 添加图例
from matplotlib.lines import Line2D
legend_elements = [
    Line2D([0], [0], color=bar_color, lw=4, label='数量（对数刻度）'),
    Line2D([0], [0], color=line_color, marker='o', lw=2.5, label='百分比（对数刻度）')
]
ax1.legend(handles=legend_elements, loc='upper right', fontsize=10)

plt.show()
```



bokeh画图 
1.文档
a.https://docs.bokeh.org/en/latest/docs/user_guide/basic/bars.html
b.https://docs.bokeh.org/en/2.4.3/docs/user_guide/annotations.html  官方文档
c.https://docs.bokeh.org/en/latest/docs/gallery.html  例子
d.https://docs.bokeh.org/en/2.3.3/docs/reference/colors.html?highlight=color#module-bokeh.colors.color 颜色选择
2.设置图形显示在jupyter而不是跳转到html
a.bokeh.io.output_notebook()
3.画折线图
a.设置figure
i.p = figure(width=1200, height=300,x_range=(0, 20),title="ABC",toolbar_location=None, tools="")
ii.p.y_range.start = 0  p.y_range.end = 4  设置y轴范围，不能直接设置在figure对象参数里
iii.参数
1.在figure对象中使用
a.x_axis_type="datetime"  指定x轴为时间类型，同时x轴字段需要转换为时间类型 stock['trade_date']=stock['trade_date'].astype('datetime64')
b.legend_label='open'  设置每条线的标签 设置y轴位置，左还是右
c.y_axis_location = 'right'
d.p = figure(x_range=(-6.5, 6.5), y_range=(-1.1, 1.1))  设置 x、y轴的范围
2.调用对象p设置
a.p.legend.location = "top_left" 图例位置
b.p.legend.click_policy="mute"
c.p.toolbar.autohide = True  设置自动隐藏toolbar
d.p.legend.location = "top_left"  图例位置
e.p.legend.click_policy="hide" 图例点击策略
b.画各种折线
i.p.line([1, 2, 3], [4,6,2])
ii.p.multi_line([[1, 3, 2], [3, 4, 6, 6]], [[2, 1, 4], [4, 7, 8, 5]],color=["firebrick", "navy"], alpha=[0.8, 0.3], line_width=4)  多条线，x、y均不相同
iii.p.vline_stack(['open', 'close'], x='index', source=source) 横轴相同多条线,堆叠在一起，第二条线是两条线的和
c.画蜡烛图
i.p.vbar(x=[0,1],bottom=[2,3],top=[4,5],color=['red','green'], fill_color="#FF4500",
       line_color="black")  可以指定每个点的颜色
ii.p.line(x=[0,1],y=[4,5],color='black')
d.画圈
i.p.circle([1,2], [2,4], fill_color="white", size=8)  每个点画圆圈  
e.条形图
i.p = figure(x_range=['x','y'], height=350, title="Fruit Counts",toolbar_location=None, tools="")
ii.p.vbar(x=['x','y'], top=[2,4])
f.多个y轴
p=figure(x_range=(0,5), y_range=(1,5)) # 先指定画布范围
x,y1,y2=[1,2,3,4],[1,2,3,4],[20,40,50,60]
p.extra_y_ranges = {"high": Range1d(start=0, end=100)}  #设置第二个y轴范围，并命名，和默认y轴范围不一致
p.line(x,y1) # 默认使用第一个y轴
p.line(x,y2,y_range_name="high") # 指定使用第二个y轴
p.add_layout(LinearAxis(y_range_name="high",,axis_label='成交额), 'right') 
show(p)
g.show(column([p,p2,p1,p3,p4]))  把图纵向组合起来
4.使用pandas-bokeh
a.文档
i.https://zhuanlan.zhihu.com/p/376248349
ii.https://github.com/PatrikHlobil/Pandas-Bokeh#barplot
b.导包
i.import pandas_bokeh
ii.pandas_bokeh.output_notebook()
c.画图
i.stock.plot_bokeh.line('index','open')  折线图
ii.stock[['trade_date','open','close']].plot_bokeh.line(x='trade_date',figsize=(1000,300))  多条折线
iii.stock.plot_bokeh.bar('index','open') 柱形图
iv.堆积柱形图， 多个y值会累计 stacked=True，不设置默认为false，柱子不会叠在一起
p_stacked_bar = df.plot_bokeh.bar(
    ylabel="单位价格 [$]",  # y轴名称
    title="水果每年价格",   # 图表标题
    stacked=True,  # 是否设置为堆积柱形图
    alpha=0.6)  # 透明度
v.点图， marker代表每个店的样式
df.plot_bokeh.point(
    x="x",  # x轴
    xticks=range(-3, 4),  
    size=5,
    colormap=["#21209c", "#fdb827"],
    title="点图 (平方 vs. 立方)",
    marker="+")   # 标记样式  x o p . *  v  ^  +  -
vi.多张图合并一起
1.设置 show_figure=False
2.使用 pandas_bokeh.plot_grid组合
# 作图
p_scientific = df.plot_bokeh(x="动物", y="体重 [克]", show_figure=False)
p_non_scientific = df.plot_bokeh(x="动物", y="体重 [克]", disable_scientific_axes="y", show_figure=False)
# 组合
pandas_bokeh.plot_grid([[p_scientific, p_non_scientific]], plot_width = 450)
d.参数
i.figsize: 图的尺寸,如figsize=(600, 350)
ii.title: 图的标题
iii.xticks/ yticks=[0, 100, 200, 300, 400]  指定x/y轴有哪些刻度
iv.xlim/ylim: 设置图的x轴和y轴的范围  (0, 400)
v.xlabel/ylabel: 设置x轴和y轴的名字
vi.color: 对图中使用同一的颜色，如果想定义多种颜色，请使用colormap参数 colormap=["blue","green" ]
vii.hovertool: 默认True，鼠标放在图上会悬浮显示具体信息。
viii.zooming: 布尔值，默认True支持缩放
ix.rangetool=True  允许选中部分数据
x.show_figure是否显示图形，默认True
xi.toolbar_location:  (None, "above", "below", "left" or "right").
matplot


tushare
1.获取api 
a.pro = ts.pro_api('5d03fb68286c12bd294170ab5e8768b28e148a5e420d47b4b3b884dd')
2.获取所有股票
a.all_stock = pro.stock_basic()
3.通用行情接口
a.df = ts.pro_bar(ts_code='000001.SZ', adj='qfq', start_date='20180101', end_date='20181011',ma=[5, 20, 50],factors=['tor', 'vr'])
b.参数
i.asset    资产类别：E股票 I沪深指数 C数字货币 FT期货 FD基金 O期权 CB可转债（v1.2.39），默认E
ii.adj    复权类型(只针对股票)：None未复权 qfq前复权 hfq后复权 , 默认None
iii.freq    数据频度 ：支持分钟(min)/日(D)/周(W)/月(M)K线，其中1min表示1分钟（类推1/5/15/30/60分钟） ，默认D
iv.ma    均线，支持任意合理int数值 e.g: ma_5表示5日均价，ma_v_5表示5日均量
v.factors    股票因子（asset='E'有效）支持 tor换手率 vr量比  factors=['tor', 'vr']
4.获取某一只股票行情
a.pro.daily(ts_code=code)
# 获取一只股票方法
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        return pro.daily(ts_code=code)
5.定义获取股票行情方法
# 根据股票中文名称获取股票行情信息
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        stock=pro.daily(ts_code=code)
        stock.sort_values(by='trade_date',ascending=True,inplace=True)
        stock['trade_date']=stock['trade_date'].astype('datetime64')
        stock['avg_amount']=stock['amount']*10/stock['vol']
        stock['5d_ma']=stock['close'].rolling(5).apply(lambda x:x.mean())
        stock['10d_ma']=stock['close'].rolling(10).apply(lambda x:x.mean())
        stock=stock.dropna(how='any')
        stock.reset_index(inplace=True,drop=True)
        return stock
指标
文档
a.https://zhuanlan.zhihu.com/p/55311293
天勤
b.https://doc.shinnytech.com/tqsdk/latest/reference/tqsdk.ta.html
stockstats
1.文档  https://github.com/jealous/stockstats
2.指标
a.close_-1_s   往前一天的收盘价 、rsi_6_-1_s  6日rsi往前1天的值
b.close_-1_d 收盘价与前一日收盘价的差
c.close_-3,2_max  前三后2共5天内最大值，不包含当前值
d.downs_10_c   最近10天downs值求和
e.high_5_sma 5周期最高价简单移动平均
f.close_10_ema  10周期收盘价指数移动平均
量化工具
supermind
文档
a.http://quant.10jqka.com.cn/platform/html/home.html
