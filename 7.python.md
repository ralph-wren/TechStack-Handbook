```python
Python 完整技术指南
```

## 目录

*   [Python 完整技术指南](#python-%E5%AE%8C%E6%95%B4%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97)
    *   [目录](#%E7%9B%AE%E5%BD%95)
    *   [1\. Python 语言基础](#1-python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80)
        *   [1.1 Python 概述](#11-python-%E6%A6%82%E8%BF%B0)
            *   [1.1.1 Python 特点与优势](#111-python-%E7%89%B9%E7%82%B9%E4%B8%8E%E4%BC%98%E5%8A%BF)
            *   [1.1.2 Python 解释器架构](#112-python-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%B6%E6%9E%84)
        *   [1.2 数据类型深度解析](#12-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90)
            *   [1.2.1 内置数据类型体系](#121-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%93%E7%B3%BB)
            *   [1.2.2 数据类型详解与性能特性](#122-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%80%A7%E8%83%BD%E7%89%B9%E6%80%A7)
        *   [1.3 控制流与逻辑结构](#13-%E6%8E%A7%E5%88%B6%E6%B5%81%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84)
            *   [1.3.1 条件控制的高级用法](#131-%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95)
            *   [1.3.2 循环控制的高级技巧](#132-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7)
        *   [1.4 函数与作用域](#14-%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F)
            *   [1.4.1 函数参数的高级特性](#141-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)
            *   [1.4.2 作用域与LEGB规则](#142-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8Elegb%E8%A7%84%E5%88%99)
        *   [1.5 模块与包管理](#15-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86)
            *   [1.5.1 模块导入机制深度解析](#151-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90)
            *   [1.5.2 包管理最佳实践](#152-%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)
    *   [2\. 面向对象编程](#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B)
        *   [2.1 类与对象](#21-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1)
            *   [2.1.1 类的定义与实例化](#211-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96)
            *   [2.1.2 属性访问控制](#212-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)
        *   [2.2 继承与多态](#22-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81)
            *   [2.2.1 单继承与方法重写](#221-%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99)
            *   [2.2.2 多重继承与MRO](#222-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8Emro)
        *   [2.3 特殊方法与运算符重载](#23-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)
        *   [2.4 属性与描述符](#24-%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6)
            *   [2.4.1 属性装饰器](#241-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8)
            *   [2.4.2 描述符协议](#242-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8D%8F%E8%AE%AE)
    *   [3\. Python 高级特性](#3-python-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)
        *   [3.1 装饰器](#31-%E8%A3%85%E9%A5%B0%E5%99%A8)
            *   [3.1.1 函数装饰器](#311-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8)
            *   [3.1.2 类装饰器](#312-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8)
            *   [3.1.3 装饰器应用场景](#313-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
        *   [3.2 生成器与迭代器](#32-%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8)
            *   [3.2.1 迭代器协议](#321-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)
            *   [3.2.2 生成器函数](#322-%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0)
            *   [3.2.3 生成器表达式](#323-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F)
        *   [3.3 上下文管理器](#33-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8)
            *   [3.3.1 with语句](#331-with%E8%AF%AD%E5%8F%A5)
            *   [3.3.2 自定义上下文管理器](#332-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8)
        *   [3.4 元类与反射](#34-%E5%85%83%E7%B1%BB%E4%B8%8E%E5%8F%8D%E5%B0%84)
            *   [3.4.1 元类基础](#341-%E5%85%83%E7%B1%BB%E5%9F%BA%E7%A1%80)
            *   [3.4.2 反射机制](#342-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6)
            *   [3.2.2 生成器函数](#322-%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0-1)
            *   [3.2.3 生成器表达式](#323-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F-1)
        *   [3.3 上下文管理器](#33-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8-1)
            *   [3.3.1 with语句](#331-with%E8%AF%AD%E5%8F%A5-1)
            *   [3.3.2 自定义上下文管理器](#332-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8-1)
        *   [3.4 元类与反射](#34-%E5%85%83%E7%B1%BB%E4%B8%8E%E5%8F%8D%E5%B0%84-1)
            *   [3.4.1 元类基础](#341-%E5%85%83%E7%B1%BB%E5%9F%BA%E7%A1%80-1)
            *   [3.4.2 反射机制](#342-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-1)
    *   [4\. 内存管理与性能优化](#4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
        *   [4.1 Python 内存模型](#41-python-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
            *   [4.1.1 对象内存结构](#411-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84)
        *   [4.2 垃圾回收机制](#42-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6)
        *   [4.3 性能分析与优化](#43-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96)
    *   [5\. 环境与工具](#5-%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7)
        *   [5.1 开发环境搭建](#51-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA)
        *   [5.2 包管理工具](#52-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)
        *   [5.3 虚拟环境](#53-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83)
        *   [5.4 常用开发工具](#54-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7)
        *   [5.4 常用开发工具](#54-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-1)
    *   [6\. 数据处理与分析](#6-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90)
        *   [6.1 NumPy 基础](#61-numpy-%E5%9F%BA%E7%A1%80)
        *   [6.2 Pandas 数据处理](#62-pandas-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)
            *   [6.2.1 数据结构与创建](#621-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%88%9B%E5%BB%BA)
            *   [6.2.2 数据读取与写入](#622-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5)
            *   [6.2.3 数据基本信息与操作](#623-%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E4%B8%8E%E6%93%8D%E4%BD%9C)
            *   [6.2.4 数据清洗与处理](#624-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%A4%84%E7%90%86)
            *   [6.2.5 数据索引与选择](#625-%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%80%89%E6%8B%A9)
            *   [6.2.6 数据统计与分析](#626-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90)
            *   [6.2.7 时间序列处理](#627-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%84%E7%90%86)
            *   [6.2.8 数据变形与重塑](#628-%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BD%A2%E4%B8%8E%E9%87%8D%E5%A1%91)
            *   [6.2.9 数据合并与连接](#629-%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E4%B8%8E%E8%BF%9E%E6%8E%A5)
            *   [6.2.10 缺失数据处理](#6210-%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)
            *   [6.2.11 数据采样与过滤](#6211-%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7%E4%B8%8E%E8%BF%87%E6%BB%A4)
            *   [6.2.12 数据库连接](#6212-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5)
            *   [6.2.13 显示设置与配置](#6213-%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE)
        *   [6.3 Matplotlib 数据可视化](#63-matplotlib-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96)
            *   [6.3.1 基础绘图](#631-%E5%9F%BA%E7%A1%80%E7%BB%98%E5%9B%BE)
            *   [6.3.2 图形样式与美化](#632-%E5%9B%BE%E5%BD%A2%E6%A0%B7%E5%BC%8F%E4%B8%8E%E7%BE%8E%E5%8C%96)
            *   [6.3.3 多子图与布局](#633-%E5%A4%9A%E5%AD%90%E5%9B%BE%E4%B8%8E%E5%B8%83%E5%B1%80)
            *   [6.3.4 实战案例](#634-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B)
        *   [6.4 Bokeh 交互式可视化](#64-bokeh-%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96)
            *   [6.4.1 Bokeh 基础](#641-bokeh-%E5%9F%BA%E7%A1%80)
            *   [6.4.2 基本图表类型](#642-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B)
            *   [6.4.3 交互式功能](#643-%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8A%9F%E8%83%BD)
            *   [6.4.4 布局与组合](#644-%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%84%E5%90%88)
            *   [6.4.5 Pandas-Bokeh 集成](#645-pandas-bokeh-%E9%9B%86%E6%88%90)
            *   [6.4.6 高级应用](#646-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8)
        *   [tushare](#tushare)
    *   [7\. Python面试题集](#7-python%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86)
        *   [7.1 基础语法题](#71-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%A2%98)
            *   [题目1：Python中的可变与不可变对象](#%E9%A2%98%E7%9B%AE1python%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1)
            *   [题目2：深拷贝与浅拷贝](#%E9%A2%98%E7%9B%AE2%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D)
            *   [题目3：Python中的作用域](#%E9%A2%98%E7%9B%AE3python%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F)
        *   [7.2 面向对象题](#72-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A2%98)
            *   [题目4：类方法、静态方法和实例方法](#%E9%A2%98%E7%9B%AE4%E7%B1%BB%E6%96%B9%E6%B3%95%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95)
            *   [题目5：多重继承和MRO](#%E9%A2%98%E7%9B%AE5%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%92%8Cmro)
        *   [7.3 高级特性题](#73-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E9%A2%98)
            *   [题目6：装饰器的实现原理](#%E9%A2%98%E7%9B%AE6%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
            *   [题目7：生成器和迭代器](#%E9%A2%98%E7%9B%AE7%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8)
            *   [题目8：上下文管理器](#%E9%A2%98%E7%9B%AE8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8)
        *   [7.4 性能优化题](#74-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%A2%98)
            *   [题目9：Python性能优化技巧](#%E9%A2%98%E7%9B%AE9python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7)
            *   [题目10：内存管理和垃圾回收](#%E9%A2%98%E7%9B%AE10%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
        *   [7.5 实战编程题](#75-%E5%AE%9E%E6%88%98%E7%BC%96%E7%A8%8B%E9%A2%98)
            *   [题目11：实现LRU缓存](#%E9%A2%98%E7%9B%AE11%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98)
            *   [题目12：单例模式的多种实现](#%E9%A2%98%E7%9B%AE12%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0)
            *   [题目13：实现一个简单的线程池](#%E9%A2%98%E7%9B%AE13%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0)
    *   [8\. 总结与进阶方向](#8-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%BF%9B%E9%98%B6%E6%96%B9%E5%90%91)
        *   [Python学习路径总结](#python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E6%80%BB%E7%BB%93)
        *   [专业方向选择](#%E4%B8%93%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9)
        *   [持续学习建议](#%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE)

## 1\. Python 语言基础

### 1.1 Python 概述

#### 1.1.1 Python 特点与优势

**Python核心特点**：

*   **简洁优雅**：语法简单，代码可读性强
*   **动态类型**：运行时确定变量类型
*   **解释执行**：无需编译，开发效率高
*   **丰富生态**：拥有庞大的第三方库生态
*   **跨平台**：支持Windows、Linux、macOS

**Python应用领域**：

| 领域 | 主要框架/库 | 应用场景 |
| --- | --- | --- |
| **Web开发** | Django、Flask、FastAPI | 网站、API服务 |
| **数据科学** | NumPy、Pandas、Matplotlib | 数据分析、可视化 |
| **机器学习** | TensorFlow、PyTorch、Scikit-learn | AI模型开发 |
| **自动化** | Selenium、Beautiful Soup | 爬虫、自动化测试 |
| **DevOps** | Ansible、SaltStack | 运维自动化 |

#### 1.1.2 Python 解释器架构

```plaintext
graph TB
    subgraph "Python代码执行流程"
        SOURCE[Python源代码<br>.py文件]
        LEXER[词法分析器<br>Lexer]
        PARSER[语法分析器<br>Parser]
        AST[抽象语法树<br>AST]
        COMPILER[字节码编译器<br>Compiler]
        BYTECODE[字节码<br>.pyc文件]
        PVM[Python虚拟机<br>PVM]
        RESULT[执行结果]
    end

    SOURCE --&gt; LEXER
    LEXER --&gt; PARSER
    PARSER --&gt; AST
    AST --&gt; COMPILER
    COMPILER --&gt; BYTECODE
    BYTECODE --&gt; PVM
    PVM --&gt; RESULT
```

**CPython执行原理**：

1.  **词法分析**：将源代码分解为Token
2.  **语法分析**：构建抽象语法树(AST)
3.  **字节码编译**：AST编译为字节码
4.  **虚拟机执行**：PVM解释执行字节码

### 1.2 数据类型深度解析

#### 1.2.1 内置数据类型体系

```plaintext
graph TB
    subgraph "Python数据类型"
        ROOT[Python对象]

        subgraph "数值类型"
            INT[int 整数]
            FLOAT[float 浮点数]
            COMPLEX[complex 复数]
            BOOL[bool 布尔值]
        end

        subgraph "序列类型"
            STR[str 字符串]
            LIST[list 列表]
            TUPLE[tuple 元组]
            RANGE[range 范围]
        end

        subgraph "映射类型"
            DICT[dict 字典]
        end

        subgraph "集合类型"
            SET[set 集合]
            FROZENSET[frozenset 不可变集合]
        end

        subgraph "其他类型"
            NONE[None 空值]
            BYTES[bytes 字节序列]
            BYTEARRAY[bytearray 可变字节序列]
        end
    end

    ROOT --&gt; INT
    ROOT --&gt; FLOAT
    ROOT --&gt; COMPLEX
    ROOT --&gt; BOOL
    ROOT --&gt; STR
    ROOT --&gt; LIST
    ROOT --&gt; TUPLE
    ROOT --&gt; RANGE
    ROOT --&gt; DICT
    ROOT --&gt; SET
    ROOT --&gt; FROZENSET
    ROOT --&gt; NONE
    ROOT --&gt; BYTES
    ROOT --&gt; BYTEARRAY
```

#### 1.2.2 数据类型详解与性能特性

**数值类型深度解析**：

```python
# 整数类型 - 无限精度
big_int = 2 ** 1000  # Python支持任意大整数
print(type(big_int))  # <class 'int'="">

# 浮点数类型 - IEEE 754双精度
pi = 3.141592653589793
print(f"浮点数精度：{pi:.15f}")

# 复数类型
z = 3 + 4j
print(f"复数模长：{abs(z)}")  # 5.0

# 布尔值 - 整数子类
print(True + True)  # 2
print(isinstance(True, int))  # True
```

**字符串类型深度解析**：

```python
# 字符串不可变性验证
s1 = "hello"
s2 = s1
s1 += " world"
print(f"s1: {s1}, s2: {s2}")  # s1: hello world, s2: hello
print(f"id相同: {id(s1) == id(s2)}")  # False

# 字符串intern机制
a = "python"
b = "python"
print(f"字符串intern: {a is b}")  # True

# 字符串格式化性能对比
import timeit

# f-string (最快)
def f_string_format():
    name, age = "Alice", 25
    return f"Name: {name}, Age: {age}"

# str.format()
def str_format():
    name, age = "Alice", 25
    return "Name: {}, Age: {}".format(name, age)

# % 格式化
def percent_format():
    name, age = "Alice", 25
    return "Name: %s, Age: %d" % (name, age)

print("f-string 性能最优")
```

**容器类型性能分析**：

| 操作 | list | tuple | dict | set |
| --- | --- | --- | --- | --- |
| **创建** | O(n) | O(n) | O(n) | O(n) |
| **访问** | O(1) | O(1) | O(1) | \- |
| **查找** | O(n) | O(n) | O(1) | O(1) |
| **插入** | O(1)/O(n) | 不可变 | O(1) | O(1) |
| **删除** | O(n) | 不可变 | O(1) | O(1) |

```python
# 列表与元组性能对比
import sys

list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(f"列表内存占用: {sys.getsizeof(list_obj)} bytes")
print(f"元组内存占用: {sys.getsizeof(tuple_obj)} bytes")

# 字典内部结构演示
class HashDict:
    """简化的字典实现，展示哈希表原理"""
    def __init__(self, size=8):
        self.size = size
        self.buckets = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def put(self, key, value):
        bucket = self.buckets[self._hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))

    def get(self, key):
        bucket = self.buckets[self._hash(key)]
        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)

# 演示哈希冲突
hash_dict = HashDict(4)
hash_dict.put("a", 1)
hash_dict.put("b", 2)
print(f"获取值: {hash_dict.get('a')}")
```

### 1.3 控制流与逻辑结构

#### 1.3.1 条件控制的高级用法

```python
# 三元运算符
result = "positive" if x &gt; 0 else "non-positive"

# 链式比较
if 0 &lt; x &lt; 10:
    print("x在0到10之间")

# 短路求值
def expensive_function():
    print("执行昂贵操作")
    return True

# 只有当condition为False时才会执行expensive_function
condition = True
result = condition or expensive_function()

# match-case语句 (Python 3.10+)
def handle_data(data):
    match data:
        case int() if data &gt; 0:
            return f"正整数: {data}"
        case int() if data &lt; 0:
            return f"负整数: {data}"
        case 0:
            return "零"
        case str() if len(data) &gt; 0:
            return f"非空字符串: {data}"
        case []:
            return "空列表"
        case [x] if isinstance(x, int):
            return f"单元素整数列表: {x}"
        case [x, y]:
            return f"双元素列表: {x}, {y}"
        case {"name": str(name), "age": int(age)}:
            return f"人员信息: {name}, {age}岁"
        case _:
            return "未知类型"

# 测试match-case
print(handle_data(42))  # 正整数: 42
print(handle_data([1, 2]))  # 双元素列表: 1, 2
print(handle_data({"name": "Alice", "age": 25}))  # 人员信息: Alice, 25岁
```

#### 1.3.2 循环控制的高级技巧

```python
# enumerate获取索引和值
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")

# zip并行迭代
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
cities = ['New York', 'London', 'Tokyo']

for name, age, city in zip(names, ages, cities):
    print(f"{name}, {age}岁, 住在{city}")

# zip_longest处理不等长序列
from itertools import zip_longest

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for num, letter in zip_longest(list1, list2, fillvalue=0):
    print(f"{num} - {letter}")

# 列表推导式的高级用法
# 带条件的列表推导式
squares = [x**2 for x in range(10) if x % 2 == 0]

# 嵌套列表推导式
matrix = [[i + j for j in range(3)] for i in range(3)]

# 字典推导式
word_lengths = {word: len(word) for word in ['python', 'java', 'go']}

# 集合推导式
unique_lengths = {len(word) for word in ['python', 'java', 'go', 'rust']}

# 生成器表达式（内存友好）
large_squares = (x**2 for x in range(1000000))
```

### 1.4 函数与作用域

#### 1.4.1 函数参数的高级特性

```python
# 参数类型完整示例
def complex_function(
    pos_only, /,                    # 仅位置参数
    pos_or_kw,                      # 位置或关键字参数
    *args,                          # 可变位置参数
    kw_only,                        # 仅关键字参数
    kw_with_default="default",      # 带默认值的关键字参数
    **kwargs                        # 可变关键字参数
):
    print(f"pos_only: {pos_only}")
    print(f"pos_or_kw: {pos_or_kw}")
    print(f"args: {args}")
    print(f"kw_only: {kw_only}")
    print(f"kw_with_default: {kw_with_default}")
    print(f"kwargs: {kwargs}")

# 调用示例
complex_function(
    1,                              # pos_only
    2,                              # pos_or_kw
    3, 4, 5,                        # args
    kw_only="required",             # kw_only
    extra1="value1",                # kwargs
    extra2="value2"                 # kwargs
)

# 函数注解与类型提示
from typing import List, Dict, Optional, Union, Callable

def process_data(
    data: List[int],
    multiplier: float = 1.0,
    formatter: Optional[Callable[[float], str]] = None
) -&gt; Dict[str, Union[int, float, str]]:
    """
    处理数据并返回统计信息

    Args:
        data: 整数列表
        multiplier: 乘数因子
        formatter: 可选的格式化函数

    Returns:
        包含统计信息的字典
    """
    total = sum(data) * multiplier
    avg = total / len(data) if data else 0

    result = {
        "count": len(data),
        "total": total,
        "average": avg
    }

    if formatter:
        result["formatted_total"] = formatter(total)

    return result

# 使用示例
numbers = [1, 2, 3, 4, 5]
stats = process_data(numbers, 2.0, lambda x: f"${x:.2f}")
print(stats)
```

#### 1.4.2 作用域与LEGB规则

```plaintext
graph TB
    subgraph "LEGB作用域解析顺序"
        L[Local 局部作用域<br>函数内部定义的变量]
        E[Enclosing 闭包作用域<br>外层函数的局部变量]
        G[Global 全局作用域<br>模块级别的变量]
        B[Built-in 内置作用域<br>内置函数和异常]
    end

    L --&gt; E
    E --&gt; G
    G --&gt; B
```

```python
# LEGB作用域演示
builtin_name = "内置"  # 这实际上会覆盖内置作用域

global_var = "全局变量"

def outer_function():
    enclosing_var = "闭包变量"

    def inner_function():
        local_var = "局部变量"

        # 演示作用域查找顺序
        print(f"局部: {local_var}")
        print(f"闭包: {enclosing_var}")
        print(f"全局: {global_var}")

        # 使用nonlocal修改闭包变量
        nonlocal enclosing_var
        enclosing_var = "修改后的闭包变量"

        # 使用global修改全局变量
        global global_var
        global_var = "修改后的全局变量"

    inner_function()
    print(f"外层函数中的闭包变量: {enclosing_var}")
    return inner_function

# 闭包示例
def create_multiplier(factor):
    """创建一个乘法器闭包"""
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(f"double(5) = {double(5)}")  # 10
print(f"triple(5) = {triple(5)}")  # 15

# 查看闭包变量
print(f"double的闭包变量: {double.__closure__[0].cell_contents}")  # 2
```

### 1.5 模块与包管理

#### 1.5.1 模块导入机制深度解析

```python
# 模块搜索路径
import sys
print("Python模块搜索路径:")
for path in sys.path:
    print(f"  {path}")

# 动态导入模块
import importlib

def dynamic_import(module_name, function_name):
    """动态导入模块中的函数"""
    try:
        module = importlib.import_module(module_name)
        function = getattr(module, function_name)
        return function
    except (ImportError, AttributeError) as e:
        print(f"导入失败: {e}")
        return None

# 模块重新加载
def reload_module(module):
    """重新加载模块（开发时有用）"""
    return importlib.reload(module)

# 相对导入和绝对导入
# 包结构示例：
# myproject/
#   __init__.py
#   main.py
#   utils/
#     __init__.py
#     helpers.py
#     math_utils.py

# 在 myproject/main.py 中：
# 绝对导入
# from myproject.utils.helpers import some_function

# 相对导入
# from .utils.helpers import some_function
# from ..other_package import other_function
```

#### 1.5.2 包管理最佳实践

```python
# __init__.py 文件的高级用法
# mypackage/__init__.py

# 控制 from mypackage import * 的行为
__all__ = ['PublicClass', 'public_function']

# 包级别的初始化代码
print(f"正在初始化包: {__name__}")

# 延迟导入，避免循环依赖
def get_heavy_module():
    """延迟导入重型模块"""
    import heavy_module
    return heavy_module

# 版本信息
__version__ = "1.0.0"
__author__ = "Your Name"

# 子模块的便捷访问
from .submodule import important_function

class PublicClass:
    """包的公共类"""
    pass

def public_function():
    """包的公共函数"""
    pass

# 包的命名空间包（PEP 420）
# 不需要 __init__.py 文件，允许分布式包结构
```

**包结构最佳实践**：

```plaintext
myproject/
├── README.md
├── setup.py
├── requirements.txt
├── myproject/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── models.py
│   │   └── services.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── helpers.py
│   │   └── validators.py
│   └── tests/
│       ├── __init__.py
│       ├── test_core.py
│       └── test_utils.py
└── docs/
    └── api.md
```

## 2\. 面向对象编程

### 2.1 类与对象

#### 2.1.1 类的定义与实例化

```python
class Person:
    """人员类示例"""

    # 类变量
    species = "Homo sapiens"
    population = 0

    def __init__(self, name, age, email=None):
        """构造函数"""
        # 实例变量
        self.name = name
        self.age = age
        self.email = email

        # 更新类变量
        Person.population += 1

    def __str__(self):
        """字符串表示"""
        return f"Person(name='{self.name}', age={self.age})"

    def __repr__(self):
        """调试表示"""
        return f"Person('{self.name}', {self.age}, '{self.email}')"

    def greet(self):
        """实例方法"""
        return f"Hello, I'm {self.name}"

    @classmethod
    def get_population(cls):
        """类方法"""
        return cls.population

    @staticmethod
    def is_adult(age):
        """静态方法"""
        return age &gt;= 18

    def __del__(self):
        """析构函数"""
        Person.population -= 1

# 使用示例
person1 = Person("Alice", 25, "alice@example.com")
person2 = Person("Bob", 17)

print(person1.greet())  # Hello, I'm Alice
print(Person.get_population())  # 2
print(Person.is_adult(person2.age))  # False
```

#### 2.1.2 属性访问控制

```python
class BankAccount:
    """银行账户类，演示访问控制"""

    def __init__(self, account_number, initial_balance=0):
        self.account_number = account_number  # 公开属性
        self._balance = initial_balance       # 受保护属性（约定）
        self.__pin = "1234"                  # 私有属性（名称修饰）

    @property
    def balance(self):
        """余额属性的getter"""
        return self._balance

    @balance.setter
    def balance(self, value):
        """余额属性的setter"""
        if value &lt; 0:
            raise ValueError("余额不能为负数")
        self._balance = value

    def deposit(self, amount):
        """存款"""
        if amount &gt; 0:
            self._balance += amount
            return True
        return False

    def withdraw(self, amount, pin):
        """取款"""
        if pin != self.__pin:
            raise ValueError("PIN码错误")
        if amount &gt; self._balance:
            raise ValueError("余额不足")
        self._balance -= amount
        return True

    def _internal_audit(self):
        """受保护方法"""
        return f"账户 {self.account_number} 余额审计: {self._balance}"

    def __validate_transaction(self, amount):
        """私有方法"""
        return amount &gt; 0 and amount &lt;= self._balance

# 使用示例
account = BankAccount("123456789", 1000)
print(f"余额: {account.balance}")  # 1000

account.deposit(500)
print(f"存款后余额: {account.balance}")  # 1500

# 私有属性的名称修饰
print(f"私有属性实际名称: {account._BankAccount__pin}")  # 1234
```

### 2.2 继承与多态

#### 2.2.1 单继承与方法重写

```python
class Animal:
    """动物基类"""

    def __init__(self, name, species):
        self.name = name
        self.species = species

    def make_sound(self):
        """发出声音 - 抽象方法"""
        raise NotImplementedError("子类必须实现此方法")

    def info(self):
        """获取动物信息"""
        return f"{self.name} is a {self.species}"

class Dog(Animal):
    """狗类"""

    def __init__(self, name, breed):
        super().__init__(name, "Dog")  # 调用父类构造函数
        self.breed = breed

    def make_sound(self):
        """重写父类方法"""
        return f"{self.name} says Woof!"

    def fetch(self):
        """狗特有的方法"""
        return f"{self.name} is fetching the ball"

class Cat(Animal):
    """猫类"""

    def __init__(self, name, indoor=True):
        super().__init__(name, "Cat")
        self.indoor = indoor

    def make_sound(self):
        return f"{self.name} says Meow!"

    def climb(self):
        return f"{self.name} is climbing"

# 多态演示
def animal_concert(animals):
    """动物演唱会 - 多态的体现"""
    for animal in animals:
        print(animal.make_sound())

# 使用示例
dog = Dog("Buddy", "Golden Retriever")
cat = Cat("Whiskers", indoor=True)

animals = [dog, cat]
animal_concert(animals)
# Buddy says Woof!
# Whiskers says Meow!

# 检查继承关系
print(isinstance(dog, Animal))  # True
print(issubclass(Dog, Animal))  # True
```

#### 2.2.2 多重继承与MRO

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

# 方法解析顺序（MRO）
print(D.mro())
# [<class '__main__.d'="">, <class '__main__.b'="">, <class '__main__.c'="">, <class '__main__.a'="">, <class 'object'="">]

d = D()
d.method()
# D.method
# B.method
# C.method
# A.method

# Mixin模式示例
class TimestampMixin:
    """时间戳混入类"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        from datetime import datetime
        self.created_at = datetime.now()
        self.updated_at = datetime.now()

    def touch(self):
        """更新时间戳"""
        from datetime import datetime
        self.updated_at = datetime.now()

class LoggingMixin:
    """日志混入类"""
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class User(TimestampMixin, LoggingMixin):
    """用户类，使用多个Mixin"""
    def __init__(self, username):
        super().__init__()
        self.username = username
        self.log(f"User {username} created")

    def update_profile(self):
        self.touch()
        self.log("Profile updated")

user = User("alice")
user.update_profile()
```

### 2.3 特殊方法与运算符重载

```python
class Vector:
    """二维向量类，演示运算符重载"""

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        """字符串表示"""
        return f"Vector({self.x}, {self.y})"

    def __repr__(self):
        """调试表示"""
        return f"Vector({self.x!r}, {self.y!r})"

    def __add__(self, other):
        """向量加法"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    def __sub__(self, other):
        """向量减法"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented

    def __mul__(self, scalar):
        """标量乘法"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented

    def __rmul__(self, scalar):
        """反向标量乘法"""
        return self.__mul__(scalar)

    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False

    def __lt__(self, other):
        """小于比较（按长度）"""
        if isinstance(other, Vector):
            return self.magnitude() &lt; other.magnitude()
        return NotImplemented

    def __len__(self):
        """长度（转换为整数）"""
        return int(self.magnitude())

    def __bool__(self):
        """布尔值转换"""
        return self.magnitude() != 0

    def __getitem__(self, key):
        """索引访问"""
        if key == 0:
            return self.x
        elif key == 1:
            return self.y
        else:
            raise IndexError("Vector只有两个分量")

    def __setitem__(self, key, value):
        """索引赋值"""
        if key == 0:
            self.x = value
        elif key == 1:
            self.y = value
        else:
            raise IndexError("Vector只有两个分量")

    def magnitude(self):
        """计算向量长度"""
        return (self.x ** 2 + self.y ** 2) ** 0.5

    def dot(self, other):
        """点积"""
        return self.x * other.x + self.y * other.y

# 使用示例
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)  # Vector(4, 6)
print(v1 * 2)   # Vector(6, 8)
print(2 * v1)   # Vector(6, 8)
print(v1[0])    # 3
print(len(v1))  # 5
print(bool(v1)) # True
print(v1 == v2) # False
```

### 2.4 属性与描述符

#### 2.4.1 属性装饰器

```python
class Temperature:
    """温度类，演示属性装饰器"""

    def __init__(self, celsius=0):
        self._celsius = celsius

    @property
    def celsius(self):
        """摄氏度"""
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value &lt; -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value

    @property
    def fahrenheit(self):
        """华氏度"""
        return self._celsius * 9/5 + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9

    @property
    def kelvin(self):
        """开尔文"""
        return self._celsius + 273.15

    @kelvin.setter
    def kelvin(self, value):
        self.celsius = value - 273.15

# 使用示例
temp = Temperature(25)
print(f"摄氏度: {temp.celsius}")    # 25
print(f"华氏度: {temp.fahrenheit}")  # 77.0
print(f"开尔文: {temp.kelvin}")     # 298.15

temp.fahrenheit = 100
print(f"摄氏度: {temp.celsius}")    # 37.77777777777778
```

#### 2.4.2 描述符协议

```python
class ValidatedAttribute:
    """验证描述符"""

    def __init__(self, validator=None, default=None):
        self.validator = validator
        self.default = default
        self.name = None

    def __set_name__(self, owner, name):
        """当描述符被赋值给类属性时调用"""
        self.name = name
        self.private_name = f'_{name}'

    def __get__(self, instance, owner):
        """获取属性值"""
        if instance is None:
            return self
        return getattr(instance, self.private_name, self.default)

    def __set__(self, instance, value):
        """设置属性值"""
        if self.validator:
            value = self.validator(value)
        setattr(instance, self.private_name, value)

    def __delete__(self, instance):
        """删除属性"""
        delattr(instance, self.private_name)

# 验证函数
def positive_number(value):
    """验证正数"""
    if not isinstance(value, (int, float)):
        raise TypeError("必须是数字")
    if value &lt;= 0:
        raise ValueError("必须是正数")
    return value

def non_empty_string(value):
    """验证非空字符串"""
    if not isinstance(value, str):
        raise TypeError("必须是字符串")
    if not value.strip():
        raise ValueError("不能是空字符串")
    return value.strip()

class Product:
    """产品类，使用描述符进行验证"""

    name = ValidatedAttribute(non_empty_string)
    price = ValidatedAttribute(positive_number)
    quantity = ValidatedAttribute(positive_number, default=1)

    def __init__(self, name, price, quantity=1):
        self.name = name
        self.price = price
        self.quantity = quantity

    @property
    def total_value(self):
        return self.price * self.quantity

# 使用示例
product = Product("Laptop", 999.99, 2)
print(f"产品: {product.name}, 总价值: ${product.total_value}")

# 验证会自动触发
try:
    product.price = -100  # 将触发ValueError
except ValueError as e:
    print(f"验证错误: {e}")
```

## 3\. Python 高级特性

### 3.1 装饰器

#### 3.1.1 函数装饰器

**基本装饰器语法**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"调用函数 {func.__name__}")
        result = func(*args, **kwargs)
        print(f"函数 {func.__name__} 执行完成")
        return result
    return wrapper

@my_decorator
def greet(name):
    return f"Hello, {name}!"

# 等价于: greet = my_decorator(greet)
print(greet("Alice"))
```

**带参数的装饰器**

```python
def retry(max_attempts=3):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    print(f"尝试 {attempt + 1} 失败: {e}")
            return None
        return wrapper
    return decorator

@retry(max_attempts=3)
def unstable_function():
    import random
    if random.random() &lt; 0.7:
        raise Exception("随机失败")
    return "成功!"
```

#### 3.1.2 类装饰器

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数 {self.func.__name__} 被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # 函数 say_hello 被调用了 1 次
say_hello()  # 函数 say_hello 被调用了 2 次
```

#### 3.1.3 装饰器应用场景

**性能监控装饰器**

```python
import time
import functools

def timing(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 执行时间: {end - start:.4f}秒")
        return result
    return wrapper

@timing
def slow_function():
    time.sleep(1)
    return "完成"
```

### 3.2 生成器与迭代器

#### 3.2.1 迭代器协议

**自定义迭代器**

```python
class NumberSequence:
    """数字序列迭代器"""
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &gt;= self.end:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1

# 使用迭代器
seq = NumberSequence(1, 5)
for num in seq:
    print(num)  # 输出: 1, 2, 3, 4

# 手动迭代
iterator = iter(NumberSequence(1, 4))
print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
```

**内置迭代工具**

```python
from itertools import count, cycle, repeat, chain, combinations, permutations

# 无限迭代器
counter = count(10, 2)  # 从10开始，步长为2
print(list(next(counter) for _ in range(5)))  # [10, 12, 14, 16, 18]

# 循环迭代器
colors = cycle(['red', 'green', 'blue'])
print([next(colors) for _ in range(7)])  # ['red', 'green', 'blue', 'red', 'green', 'blue', 'red']

# 重复迭代器
repeated = repeat('hello', 3)
print(list(repeated))  # ['hello', 'hello', 'hello']

# 链式迭代器
list1 = [1, 2, 3]
list2 = [4, 5, 6]
chained = chain(list1, list2)
print(list(chained))  # [1, 2, 3, 4, 5, 6]

# 组合和排列
items = ['A', 'B', 'C']
print(list(combinations(items, 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'C')]
print(list(permutations(items, 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
```

#### 3.2.2 生成器函数

**基本生成器函数**

```python
def fibonacci_generator(n):
    """斐波那契数列生成器"""
    a, b = 0, 1
    count = 0
    while count &lt; n:
        yield a
        a, b = b, a + b
        count += 1

# 使用生成器
fib = fibonacci_generator(10)
print(list(fib))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

# 内存效率对比
def large_list():
    """返回大列表 - 占用大量内存"""
    return [x**2 for x in range(1000000)]

def large_generator():
    """返回生成器 - 节省内存"""
    for x in range(1000000):
        yield x**2

import sys
print(f"列表大小: {sys.getsizeof(large_list())} bytes")
print(f"生成器大小: {sys.getsizeof(large_generator())} bytes")
```

**生成器的高级用法**

```python
def data_processor():
    """数据处理生成器 - 支持send()方法"""
    result = None
    while True:
        data = yield result
        if data is None:
            break
        # 处理数据
        result = data * 2 + 1
        print(f"处理数据: {data} -&gt; {result}")

# 使用send()方法
processor = data_processor()
next(processor)  # 启动生成器

processor.send(5)   # 处理数据: 5 -&gt; 11
processor.send(10)  # 处理数据: 10 -&gt; 21
processor.send(None)  # 结束生成器
```

#### 3.2.3 生成器表达式

```python
# 生成器表达式 vs 列表推导式
numbers = range(1000000)

# 列表推导式 - 立即创建所有元素
squares_list = [x**2 for x in numbers]

# 生成器表达式 - 按需生成元素
squares_gen = (x**2 for x in numbers)

# 内存使用对比
import sys
print(f"列表推导式内存: {sys.getsizeof(squares_list)} bytes")
print(f"生成器表达式内存: {sys.getsizeof(squares_gen)} bytes")

# 管道式处理
def process_data(filename):
    """使用生成器进行管道式数据处理"""
    # 读取文件行
    lines = (line.strip() for line in open(filename))

    # 过滤非空行
    non_empty = (line for line in lines if line)

    # 转换为大写
    upper_lines = (line.upper() for line in non_empty)

    # 过滤包含特定关键词的行
    filtered = (line for line in upper_lines if 'ERROR' in line)

    return filtered

# 使用管道处理
# for line in process_data('log.txt'):
#     print(line)
```

### 3.3 上下文管理器

#### 3.3.1 with语句

**基本用法**

```python
# 文件操作 - 自动关闭文件
with open('example.txt', 'w') as f:
    f.write('Hello, World!')
# 文件自动关闭，即使发生异常

# 多个上下文管理器
with open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:
    data = infile.read()
    outfile.write(data.upper())

# 异常处理中的资源管理
try:
    with open('data.txt', 'r') as f:
        data = f.read()
        # 即使这里发生异常，文件也会被正确关闭
        result = 1 / 0
except ZeroDivisionError:
    print("除零错误，但文件已正确关闭")
```

#### 3.3.2 自定义上下文管理器

**使用类实现**

```python
class DatabaseConnection:
    """数据库连接上下文管理器"""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None

    def __enter__(self):
        print(f"连接到数据库 {self.host}:{self.port}")
        # 模拟建立连接
        self.connection = f"connection_to_{self.host}_{self.port}"
        return self.connection

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("关闭数据库连接")
        if exc_type is not None:
            print(f"发生异常: {exc_type.__name__}: {exc_val}")
        # 清理资源
        self.connection = None
        return False  # 不抑制异常

# 使用自定义上下文管理器
with DatabaseConnection('localhost', 5432) as conn:
    print(f"使用连接: {conn}")
    # 模拟数据库操作
```

**使用contextlib模块**

```python
from contextlib import contextmanager
import time

@contextmanager
def timer(name):
    """计时上下文管理器"""
    start = time.time()
    print(f"开始执行 {name}")
    try:
        yield
    finally:
        end = time.time()
        print(f"{name} 执行完成，耗时: {end - start:.4f}秒")

# 使用装饰器创建的上下文管理器
with timer("数据处理"):
    time.sleep(1)
    print("处理数据中...")

@contextmanager
def temporary_setting(obj, attr, new_value):
    """临时修改对象属性"""
    old_value = getattr(obj, attr)
    setattr(obj, attr, new_value)
    try:
        yield obj
    finally:
        setattr(obj, attr, old_value)

class Config:
    debug = False

config = Config()
print(f"原始debug值: {config.debug}")

with temporary_setting(config, 'debug', True):
    print(f"临时debug值: {config.debug}")

print(f"恢复后debug值: {config.debug}")
```

### 3.4 元类与反射

#### 3.4.1 元类基础

**理解元类**

```python
# 一切皆对象的体现
class MyClass:
    pass

obj = MyClass()

print(f"obj的类型: {type(obj)}")        # <class '__main__.myclass'="">
print(f"MyClass的类型: {type(MyClass)}")  # <class 'type'="">
print(f"type的类型: {type(type)}")       # <class 'type'="">

# 动态创建类
def init_method(self, name):
    self.name = name

def say_hello(self):
    return f"Hello, I'm {self.name}"

# 使用type()动态创建类
DynamicClass = type(
    'DynamicClass',           # 类名
    (object,),                # 基类
    {                         # 类属性和方法
        '__init__': init_method,
        'say_hello': say_hello,
        'class_var': 'I am dynamic'
    }
)

# 使用动态创建的类
obj = DynamicClass("Alice")
print(obj.say_hello())  # Hello, I'm Alice
```

**自定义元类**

```python
class SingletonMeta(type):
    """单例模式元类"""
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self):
        self.connection = "database_connection"

# 测试单例模式
db1 = Database()
db2 = Database()
print(f"db1 is db2: {db1 is db2}")  # True

class ValidatedMeta(type):
    """属性验证元类"""
    def __new__(mcs, name, bases, attrs):
        # 为所有方法添加验证
        for key, value in attrs.items():
            if callable(value) and not key.startswith('_'):
                attrs[key] = mcs.add_validation(value)
        return super().__new__(mcs, name, bases, attrs)

    @staticmethod
    def add_validation(func):
        def wrapper(self, *args, **kwargs):
            print(f"调用方法: {func.__name__}")
            return func(self, *args, **kwargs)
        return wrapper

class User(metaclass=ValidatedMeta):
    def __init__(self, name):
        self.name = name

    def greet(self):
        return f"Hello, {self.name}"

user = User("Bob")
print(user.greet())  # 会打印验证信息
```

#### 3.4.2 反射机制

**动态属性访问**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, I'm {self.name}"

    def get_info(self):
        return f"{self.name}, {self.age} years old"

person = Person("Alice", 25)

# hasattr - 检查属性是否存在
print(hasattr(person, 'name'))     # True
print(hasattr(person, 'salary'))   # False

# getattr - 获取属性值
name = getattr(person, 'name')
salary = getattr(person, 'salary', 0)  # 提供默认值
print(f"Name: {name}, Salary: {salary}")

# setattr - 设置属性值
setattr(person, 'salary', 50000)
setattr(person, 'department', 'Engineering')

# delattr - 删除属性
delattr(person, 'age')

# 动态调用方法
method_name = 'greet'
if hasattr(person, method_name):
    method = getattr(person, method_name)
    result = method()
    print(result)
```

**inspect模块深度反射**

```python
import inspect

def analyze_object(obj):
    """分析对象的详细信息"""
    print(f"对象类型: {type(obj)}")
    print(f"模块: {inspect.getmodule(obj)}")

    # 获取所有成员
    members = inspect.getmembers(obj)

    print("\n属性和方法:")
    for name, value in members:
        if not name.startswith('_'):
            member_type = "方法" if inspect.ismethod(value) else "属性"
            print(f"  {name}: {member_type}")

    # 获取方法签名
    if inspect.isclass(obj):
        print(f"\n构造函数签名: {inspect.signature(obj.__init__)}")

    # 获取源代码
    try:
        source = inspect.getsource(obj)
        print(f"\n源代码:\n{source}")
    except:
        print("\n无法获取源代码")

# 分析Person类
analyze_object(Person)

# 动态创建和调用
class APIClient:
    def get_user(self, user_id):
        return f"User {user_id}"

    def get_order(self, order_id):
        return f"Order {order_id}"

    def get_product(self, product_id):
        return f"Product {product_id}"

def dynamic_api_call(client, resource_type, resource_id):
    """动态API调用"""
    method_name = f"get_{resource_type}"

    if hasattr(client, method_name):
        method = getattr(client, method_name)
        return method(resource_id)
    else:
        raise AttributeError(f"不支持的资源类型: {resource_type}")

client = APIClient()
print(dynamic_api_call(client, 'user', 123))     # User 123
print(dynamic_api_call(client, 'order', 456))    # Order 456
print(dynamic_api_call(client, 'product', 789))  # Product 789
```

```python
class NumberIterator:
    def __init__(self, max_num):
        self.max_num = max_num
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &lt; self.max_num:
            self.current += 1
            return self.current
        else:
            raise StopIteration

# 使用自定义迭代器
for num in NumberIterator(5):
    print(num)  # 输出 1, 2, 3, 4, 5
```

#### 3.2.2 生成器函数

```python
def fibonacci_generator(n):
    """斐波那契数列生成器"""
    a, b = 0, 1
    count = 0
    while count &lt; n:
        yield a
        a, b = b, a + b
        count += 1

# 使用生成器
fib = fibonacci_generator(10)
for num in fib:
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34

# 生成器表达式
squares = (x**2 for x in range(10))
print(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### 3.2.3 生成器表达式

```python
# 内存效率对比
import sys

# 列表推导式 - 占用更多内存
list_comp = [x**2 for x in range(1000000)]
print(f"列表推导式内存占用: {sys.getsizeof(list_comp)} bytes")

# 生成器表达式 - 占用很少内存
gen_exp = (x**2 for x in range(1000000))
print(f"生成器表达式内存占用: {sys.getsizeof(gen_exp)} bytes")

# 生成器的惰性求值
def process_large_data():
    for i in range(1000000):
        yield i**2

# 只在需要时计算
data_gen = process_large_data()
first_10 = [next(data_gen) for _ in range(10)]
print(first_10)
```

### 3.3 上下文管理器

#### 3.3.1 with语句

```python
# 传统文件操作
file = open('example.txt', 'w')
try:
    file.write('Hello, World!')
finally:
    file.close()

# 使用with语句
with open('example.txt', 'w') as file:
    file.write('Hello, World!')
# 文件自动关闭
```

#### 3.3.2 自定义上下文管理器

**使用类实现**

```python
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connection = None

    def __enter__(self):
        print(f"连接到数据库 {self.db_name}")
        self.connection = f"connection_to_{self.db_name}"
        return self.connection

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"关闭数据库连接 {self.db_name}")
        if exc_type:
            print(f"发生异常: {exc_val}")
        return False  # 不抑制异常

# 使用自定义上下文管理器
with DatabaseConnection("mydb") as conn:
    print(f"使用连接: {conn}")
    # 可能的数据库操作
```

**使用contextlib模块**

```python
from contextlib import contextmanager
import time

@contextmanager
def timer():
    start = time.time()
    print("开始计时")
    try:
        yield
    finally:
        end = time.time()
        print(f"执行时间: {end - start:.4f}秒")

# 使用装饰器创建的上下文管理器
with timer():
    time.sleep(1)
    print("执行一些操作")
```

### 3.4 元类与反射

#### 3.4.1 元类基础

```python
# 元类示例
class SingletonMeta(type):
    """单例模式元类"""
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self):
        self.connection = "database_connection"

# 测试单例模式
db1 = Database()
db2 = Database()
print(db1 is db2)  # True - 同一个实例

# 动态创建类
def init_method(self, name):
    self.name = name

def greet_method(self):
    return f"Hello, I'm {self.name}"

# 使用type动态创建类
DynamicClass = type('DynamicClass', (object,), {
    '__init__': init_method,
    'greet': greet_method
})

obj = DynamicClass("Alice")
print(obj.greet())  # Hello, I'm Alice
```

#### 3.4.2 反射机制

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, I'm {self.name}"

    def get_age(self):
        return self.age

person = Person("Alice", 25)

# hasattr - 检查属性是否存在
print(hasattr(person, 'name'))     # True
print(hasattr(person, 'height'))   # False

# getattr - 获取属性值
name = getattr(person, 'name', 'Unknown')
print(name)  # Alice

height = getattr(person, 'height', 0)
print(height)  # 0 (默认值)

# setattr - 设置属性值
setattr(person, 'height', 170)
print(person.height)  # 170

# delattr - 删除属性
delattr(person, 'height')
print(hasattr(person, 'height'))  # False

# 动态调用方法
method_name = 'greet'
if hasattr(person, method_name):
    method = getattr(person, method_name)
    result = method()
    print(result)  # Hello, I'm Alice

# 获取对象的所有属性和方法
print("对象的所有属性和方法:")
for attr in dir(person):
    if not attr.startswith('_'):
        value = getattr(person, attr)
        print(f"{attr}: {value}")
```

## 4\. 内存管理与性能优化

### 4.1 Python 内存模型

#### 4.1.1 对象内存结构

```python
import sys
import gc

# 检查对象内存占用
def check_memory_usage():
    """检查不同数据类型的内存占用"""
    objects = [
        42,                    # int
        3.14,                  # float
        "hello",               # str
        [1, 2, 3],            # list
        (1, 2, 3),            # tuple
        {"a": 1, "b": 2},     # dict
        {1, 2, 3}             # set
    ]

    for obj in objects:
        size = sys.getsizeof(obj)
        print(f"{type(obj).__name__}: {obj} -&gt; {size} bytes")

check_memory_usage()

# Python对象引用计数
class RefCountDemo:
    def __init__(self, name):
        self.name = name

    def __del__(self):
        print(f"对象 {self.name} 被销毁")

def reference_counting_demo():
    """引用计数演示"""
    obj = RefCountDemo("test")
    print(f"引用计数: {sys.getrefcount(obj)}")  # 包括函数参数的引用

    ref1 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")

    ref2 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")

    del ref1
    print(f"引用计数: {sys.getrefcount(obj)}")

    del ref2
    print(f"引用计数: {sys.getrefcount(obj)}")

reference_counting_demo()
```

### 4.2 垃圾回收机制

```python
import gc
import weakref

# 循环引用问题
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.parent = None

    def add_child(self, child):
        child.parent = self
        self.children.append(child)

    def __del__(self):
        print(f"节点 {self.value} 被销毁")

def circular_reference_demo():
    """循环引用演示"""
    print("创建循环引用...")
    root = Node("root")
    child = Node("child")
    root.add_child(child)

    # 创建循环引用
    child.children.append(root)

    print(f"垃圾回收前: {len(gc.get_objects())} 个对象")

    # 删除引用
    del root
    del child

    print("手动触发垃圾回收...")
    collected = gc.collect()
    print(f"回收了 {collected} 个对象")

# 弱引用解决循环引用
class WeakNode:
    def __init__(self, value):
        self.value = value
        self.children = []
        self._parent = None

    @property
    def parent(self):
        return self._parent() if self._parent else None

    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value) if value else None

    def add_child(self, child):
        child.parent = self
        self.children.append(child)

circular_reference_demo()
```

### 4.3 性能分析与优化

```python
import cProfile
import timeit
from functools import lru_cache
import numpy as np

# 性能分析装饰器
def profile_performance(func):
    """性能分析装饰器"""
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()

        result = func(*args, **kwargs)

        profiler.disable()
        profiler.print_stats(sort='cumulative')

        return result
    return wrapper

# 缓存优化
@lru_cache(maxsize=128)
def fibonacci_cached(n):
    """带缓存的斐波那契函数"""
    if n &lt;= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_naive(n):
    """朴素的斐波那契函数"""
    if n &lt;= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

# 性能对比
def performance_comparison():
    """性能对比测试"""
    n = 30

    # 测试朴素版本
    naive_time = timeit.timeit(
        lambda: fibonacci_naive(n), 
        number=1
    )

    # 测试缓存版本
    cached_time = timeit.timeit(
        lambda: fibonacci_cached(n), 
        number=100
    ) / 100

    print(f"朴素版本 (n={n}): {naive_time:.6f}秒")
    print(f"缓存版本 (n={n}): {cached_time:.6f}秒")
    print(f"性能提升: {naive_time / cached_time:.2f}倍")

performance_comparison()

# 列表推导式 vs 循环性能
def list_comprehension_vs_loop():
    """列表推导式与循环性能对比"""
    size = 100000

    # 列表推导式
    def list_comp():
        return [x**2 for x in range(size) if x % 2 == 0]

    # 传统循环
    def traditional_loop():
        result = []
        for x in range(size):
            if x % 2 == 0:
                result.append(x**2)
        return result

    # 性能测试
    comp_time = timeit.timeit(list_comp, number=10) / 10
    loop_time = timeit.timeit(traditional_loop, number=10) / 10

    print(f"列表推导式: {comp_time:.6f}秒")
    print(f"传统循环: {loop_time:.6f}秒")
    print(f"推导式更快: {loop_time / comp_time:.2f}倍")

list_comprehension_vs_loop()
```

## 5\. 环境与工具

### 5.1 开发环境搭建

**创建venv虚拟环境**

```plaintext
python3 -m venv venv &amp;&amp; source venv/bin/activate &amp;&amp; pip install -r requirements.txt
```

**查看pip位置**

```plaintext
conda run which pip   
```

**终端配置代理**

```plaintext
# 设置代理
export http_proxy=http://127.0.0.1:10809  
export https_proxy=http://127.0.0.1:10809 
export ALL_PROXY=socks5://127.0.0.1:10808

# 或者
export http_proxy="http://127.0.0.1:7890"
export https_proxy="http://127.0.0.1:7890"

# 取消代理
unset http_proxy
unset https_proxy
unset all_proxy
```

### 5.2 包管理工具

**pip 使用**

```plaintext
# 安装包
pip install package_name

# 指定镜像源安装
pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple

# 安装特定版本
pip install package_name==1.0.0

# 从requirements.txt安装
pip install -r requirements.txt

# 升级包
pip install --upgrade package_name

# 卸载包
pip uninstall package_name
```

**conda 使用**

```plaintext
# 添加频道
conda config --add channels conda-forge
conda config --set channel_priority strict

# 安装包
conda install osmium

# 创建环境
conda create -n osm-env python=3.10

# 激活环境
conda activate osm-env

# 安装多个包
conda install -c conda-forge pyosmium pandas
```

### 5.3 虚拟环境

**venv标准库**

```plaintext
# 创建虚拟环境
python -m venv myenv

# 激活虚拟环境 (Windows)
myenv\Scripts\activate

# 激活虚拟环境 (macOS/Linux)
source myenv/bin/activate

# 停用虚拟环境
deactivate

# 删除虚拟环境
rm -rf myenv
```

**virtualenv增强工具**

```plaintext
# 安装virtualenv
pip install virtualenv

# 创建环境
virtualenv myenv
virtualenv -p python3.11 myenv  # 指定Python版本

# 使用不同的Python版本
virtualenv --python=/usr/bin/python3.9 myenv
```

**pipenv集成工具**

```plaintext
# 安装pipenv
pip install pipenv

# 创建Pipfile并安装依赖
pipenv install requests

# 安装开发依赖
pipenv install pytest --dev

# 激活shell
pipenv shell

# 运行命令
pipenv run python script.py

# 生成requirements.txt
pipenv requirements &gt; requirements.txt
```

### 5.4 常用开发工具

**代码格式化工具**

```plaintext
# Black - 代码格式化
pip install black
black script.py
black .  # 格式化整个目录

# autopep8 - PEP 8格式化
pip install autopep8
autopep8 --in-place --aggressive script.py

# isort - 导入排序
pip install isort
isort script.py
```

**代码检查工具**

```plaintext
# flake8 - 代码风格检查
pip install flake8
flake8 script.py

# pylint - 代码质量检查
pip install pylint
pylint script.py

# mypy - 类型检查
pip install mypy
mypy script.py
```

**测试框架**

```plaintext
# pytest - 现代测试框架
pip install pytest
pytest test_file.py

# unittest - 标准库测试框架
python -m unittest test_module.py

# coverage - 代码覆盖率
pip install coverage
coverage run -m pytest
coverage report
```

**myenv环境**

```plaintext
# 激活虚拟环境(Windows)
myenv\Scripts\activate

# 激活虚拟环境(Linux/Mac)
source myenv/bin/activate

# 退出虚拟环境
deactivate
```

**conda环境**

```plaintext
# 创建环境
conda create -n myenv python=3.9

# 激活环境
conda activate myenv

# 退出环境
conda deactivate

# 列出所有环境
conda env list
```

### 5.4 常用开发工具

**检测当前可用字体**

```python
import matplotlib.font_manager as fm
for font in fm.findSystemFonts(fontpaths=None, fontext='ttf'):
    print(fm.FontProperties(fname=font).get_name())
```

**IDE与编辑器**

*   PyCharm: 功能全面的Python IDE
*   VS Code: 轻量级编辑器，配合Python扩展使用
*   Jupyter Notebook: 交互式开发环境，适合数据分析
*   Spyder: 科学计算导向的IDE

## 6\. 数据处理与分析

### 6.1 NumPy 基础

**创建数组**

```python
import numpy as np

# 从列表创建
arr1 = np.array([1, 2, 3, 4, 5])

# 创建特殊数组
zeros = np.zeros((3, 3))  # 全0数组
ones = np.ones((2, 4))    # 全1数组
rand = np.random.random((2, 2))  # 随机数组
arange = np.arange(10)    # 0到9的数组
linspace = np.linspace(0, 1, 5)  # 均匀分布的5个点
```

**数组操作**

```python
# 重塑数组
arr = np.arange(12)
arr_reshaped = arr.reshape(3, 4)

# 数组切片
slice1 = arr_reshaped[0:2, 1:3]

# 数组运算
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
sum_arr = arr1 + arr2
product = arr1 * arr2
dot_product = np.dot(arr1, arr2)
```

### 6.2 Pandas 数据处理

#### 6.2.1 数据结构与创建

**Series 和 DataFrame 基础**

```python
import pandas as pd
import numpy as np

# 创建Series
s1 = pd.Series([1, 3, 5, np.nan, 6, 8])
s2 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
s3 = pd.Series({'a': 1, 'b': 2, 'c': 3})

# 创建DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3, 4],
    'B': pd.date_range('20230101', periods=4),
    'C': pd.Series(1, index=list(range(4))),
    'D': np.random.randn(4),
    'E': pd.Categorical(['test', 'train', 'test', 'train']),
    'F': 'foo'
})

# 从字典创建DataFrame
data = {
    'name': ['Alice', 'Bob', 'Charlie', 'David'],
    'age': [25, 30, 35, 28],
    'city': ['New York', 'London', 'Tokyo', 'Paris'],
    'salary': [50000, 60000, 70000, 55000]
}
df_people = pd.DataFrame(data)
```

#### 6.2.2 数据读取与写入

**文件读取操作**

```python
# CSV文件读取
df_csv = pd.read_csv('data/my_csv.csv', encoding='utf-8')

# 文本文件读取
df_txt = pd.read_table('data/my_table.txt', sep='\t')

# Excel文件读取
df_excel = pd.read_excel('data/my_excel.xlsx', sheet_name='Sheet1')
```

**写出数据**

```python
a.df.to_csv(‘existing.csv’, mode=’a’, index=False, header=False)  mode 默认w覆盖，a追加
b.b.tail(2).to_csv('../data/fund/20230421.xlsx',mode='a',index=False,header=False)
c.df_txt.to_csv('data/my_txt_saved.txt', sep='\t', index=False)
```

#### 6.2.3 数据基本信息与操作

**DataFrame 基本信息**

```python
# 获取DataFrame大小
rows = df.shape[0]  # 或 len(df) 获取行数
cols = df.shape[1]  # 获取列数

# 数据概览
df.info()      # 数据信息概况
df.describe()  # 数值列统计量
df.dtypes      # 查看字段类型
df.head()      # 前5行数据
df.tail()      # 后5行数据
```

#### 6.2.4 数据清洗与处理

**行列操作**

```python
# 删除重复行
df.drop_duplicates()  # 删除所有重复行
df.drop_duplicates(['col1', 'col2'])  # 按指定列删除重复

# 删除行列
df.drop('column_name', axis=1)  # 删除列
df.drop(['col1', 'col2'], axis=1)  # 删除多列
df.drop(0)  # 删除行
df.drop([0, 1])  # 删除多行

# 重命名
df.columns = ['new_col1', 'new_col2']  # 重新指定所有列名
df.rename(columns={'old_name': 'new_name'})  # 重命名指定列
df.rename(index={'old_index': 'new_index'})  # 重命名索引

# 新增列
df['new_col'] = df['col1'] + df['col2']  # 新列为两列相加
```

**数据类型转换**

```python
# 设置列类型
df['date_col'] = df['date_col'].astype('datetime64')
df['numeric_col'] = pd.to_numeric(df['numeric_col'])
df['date_col'] = pd.to_datetime(df['date_col'])

# 创建时指定类型
df = pd.DataFrame(data, dtype='float32')  # 统一类型
df = pd.read_csv('file.csv', dtype={'col1': 'string', 'col2': 'int32'})  # 分别指定
```

#### 6.2.5 数据索引与选择

**loc 和 iloc 索引**

```python
# loc - 基于标签的索引
df.loc[0:2, 'col1':'col3']  # 行0-2，列col1到col3
df.loc[0, 'col1':'col3']    # 第0行，列col1到col3，返回Series
df.loc[0, 'col1']           # 单个值
df.loc[df['col1'] &gt; 0, ['col2', 'col3']]  # 条件筛选

# iloc - 基于位置的索引
df.iloc[0, 1]      # 第0行第1列
df.iloc[0, 1:3]    # 第0行第1-2列
df.iloc[:3, :2]    # 前3行前2列

# 设置索引
df.set_index('date_col')  # 设置某列为索引
```

**query 方法查询**

```python
# 条件查询
df.query('price &gt; 100 and price &lt;= 200')
df.query('category.isin(["A", "B"])')
df.query('category not in ["C", "D"]')

# 使用外部变量
low, high = 50, 150
df.query('price.between(@low, @high)')

# 复杂条件
df.query('(grade not in ["A", "B"]) and (score &gt; 80)')
```

#### 6.2.6 数据统计与分析

**排序操作**

```python
# 按值排序
df.sort_values('column_name')  # 单列排序
df.sort_values(['col1', 'col2'], ascending=[True, False])  # 多列排序

# 按索引排序
df.sort_index()
```

**分组聚合**

```python
# 基本分组
df.groupby('category').mean()  # 按类别分组求均值
df.groupby(['col1', 'col2']).sum()  # 多列分组

# 聚合函数
agg_funcs = ['sum', 'mean', 'count', 'min', 'max', 'std']
df.groupby('category').agg({
    'price': ['sum', 'mean'],
    'quantity': 'count'
})

# 自定义聚合
df.agg(lambda x: x.max() - x.min())
```

**apply 方法**

```python
# 行方向应用函数 (axis=1)
df['diff'] = df.apply(lambda x: x['high'] - x['low'], axis=1)

# 列方向应用函数 (axis=0，默认)
df[['col1', 'col2']].apply(lambda x: x.mean())

# 复杂函数应用
def custom_function(row):
    if row['score'] &gt; 90:
        return 'A'
    elif row['score'] &gt; 80:
        return 'B'
    else:
        return 'C'

df['grade'] = df.apply(custom_function, axis=1)
```

#### 6.2.7 时间序列处理

**时间数据创建**

```python
# 创建时间序列DataFrame
dates = pd.date_range('2023-01-01', periods=6, freq='M')
df_time = pd.DataFrame({
    'sales': [100, 120, 110, 130, 125, 140],
    'profit': [20, 25, 22, 28, 26, 30]
}, index=dates)

# 时间相关操作
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['weekday'] = df['date'].dt.dayofweek
```

**滑动窗口分析**

```python
# 滑动窗口
df['price'].rolling(window=3).mean()  # 3期移动平均
df['price'].rolling(window=5, min_periods=1).apply(lambda x: x.mean())

# 扩张窗口（累计窗口）
df['price'].expanding().mean()  # 累计均值
df['price'].expanding().sum()   # 累计和

# 指数加权窗口
df['price'].ewm(span=10).mean()  # 指数加权移动平均

# 获取窗口内特定位置的值
df['last_in_window'] = df['price'].rolling(window=5).apply(lambda x: x.iloc[-1])
```

**时间偏移操作**

```python
# shift, diff, pct_change
df['price_lag1'] = df['price'].shift(1)      # 向前偏移1期
df['price_diff'] = df['price'].diff(1)       # 与前1期的差值
df['price_pct'] = df['price'].pct_change(1)  # 与前1期的增长率

# 负数表示向后偏移
df['price_lead1'] = df['price'].shift(-1)    # 向后偏移1期
```

#### 6.2.8 数据变形与重塑

**数据透视**

```python
# pivot 透视
df.pivot(index='date', columns='category', values='sales')

# pivot_table 透视表
df.pivot_table(
    index='region', 
    columns='product', 
    values='sales',
    aggfunc='sum',
    fill_value=0
)

# melt 逆透视
df.melt(
    id_vars=['id', 'name'],
    value_vars=['Q1', 'Q2', 'Q3', 'Q4'],
    var_name='quarter',
    value_name='sales'
)
```

**索引变形**

```python
# stack - 列索引转行索引
df.stack()

# unstack - 行索引转列索引
df.unstack()

# 多级索引操作
df.set_index(['col1', 'col2']).unstack('col2')
```

#### 6.2.9 数据合并与连接

**merge 合并**

```python
# 基本合并
df1.merge(df2, on='key_column', how='inner')

# 不同列名合并
df1.merge(df2, left_on='key1', right_on='key2', how='left')

# 多列合并
df1.merge(df2, on=['key1', 'key2'], how='outer')

# 添加后缀区分同名列
df1.merge(df2, on='key', suffixes=['_left', '_right'])
```

**join 连接**

```python
# 索引连接
df1.join(df2, how='left')
df1.join(df2, on='key_column')
```

**concat 拼接**

```python
# 纵向拼接 (axis=0)
pd.concat([df1, df2], axis=0)

# 横向拼接 (axis=1)
pd.concat([df1, df2], axis=1)

# 带标识的拼接
pd.concat([df1, df2], keys=['data1', 'data2'])
```

#### 6.2.10 缺失数据处理

**缺失数据检测**

```python
# 检测缺失值
df.isna()  # 或 df.isnull()
df.notna()  # 或 df.notnull()

# 缺失值统计
df.isna().sum()  # 每列缺失值数量
df.isna().any()  # 每列是否有缺失值

# 筛选缺失数据
df[df['column'].isna()]  # 某列为空的行
df[df.isna().any(axis=1)]  # 至少有一列为空的行
df[df.isna().all(axis=1)]  # 全部列都为空的行
df[df.notna().all(axis=1)]  # 没有缺失值的行
```

**缺失数据删除**

```python
# 删除缺失值
df.dropna()  # 删除任何包含缺失值的行
df.dropna(how='all')  # 删除全部为缺失值的行
df.dropna(axis=1)  # 删除包含缺失值的列
df.dropna(subset=['col1', 'col2'])  # 只考虑指定列的缺失值
df.dropna(thresh=2)  # 保留至少有2个非缺失值的行
```

**缺失数据填充**

```python
# 基本填充
df.fillna(0)  # 用0填充
df.fillna({'col1': 0, 'col2': 'unknown'})  # 不同列用不同值填充

# 前向填充和后向填充
df.fillna(method='ffill')  # 用前一个值填充
df.fillna(method='bfill')  # 用后一个值填充
df.fillna(method='ffill', limit=2)  # 限制连续填充次数

# 插值填充
df.interpolate()  # 线性插值
df.interpolate(method='polynomial', order=2)  # 多项式插值
```

#### 6.2.11 数据采样与过滤

**随机抽样**

```python
# 随机抽样
df.sample(n=100)  # 抽取100行
df.sample(frac=0.1)  # 抽取10%的数据
df.sample(n=50, replace=True)  # 有放回抽样
df.sample(n=100, weights=df['weight'])  # 加权抽样
```

**数据过滤**

```python
# 基本过滤
df[df['score'] &gt; 80]  # 条件过滤
df[df['name'].isin(['Alice', 'Bob'])]  # 包含过滤

# filter方法
df.filter(items=['col1', 'col2'])  # 选择指定列
df.filter(regex='sales_.*')  # 正则表达式匹配列名
df.filter(like='2023')  # 包含特定字符串的列
```

#### 6.2.12 数据库连接

**MySQL连接**

```python
from sqlalchemy import create_engine

# 创建连接引擎
connection_string = 'mysql+pymysql://user:password@localhost:3306/database?charset=utf8'
engine = create_engine(connection_string, echo=False)

# 读取数据
df = pd.read_sql("SELECT * FROM table_name", con=engine)
df = pd.read_sql_query("SELECT * FROM table_name WHERE condition", con=engine)

# 写入数据
df.to_sql(
    name='table_name',
    con=engine,
    if_exists='append',  # 'replace', 'fail'
    index=False,
    chunksize=1000
)
```

#### 6.2.13 显示设置与配置

**Pandas显示选项**

```python
# 设置显示选项
pd.set_option('display.max_columns', 100)  # 最大显示列数
pd.set_option('display.max_rows', 100)     # 最大显示行数
pd.set_option('display.width', 1000)       # 显示宽度
pd.set_option('display.float_format', '{:.2f}'.format)  # 浮点数格式

# 查看所有选项
pd.describe_option()

# 重置选项
pd.reset_option('all')
```

**性能优化技巧**

```python
# 使用分类数据类型节省内存
df['category'] = df['category'].astype('category')

# 使用合适的数据类型
df['int_col'] = df['int_col'].astype('int32')  # 而不是默认的int64

# 分块读取大文件
chunk_size = 10000
for chunk in pd.read_csv('large_file.csv', chunksize=chunk_size):
    # 处理每个chunk
    process_chunk(chunk)
```

```python
a.df.shape[1] 求df列长度
b.df.shape[0] 或者 len(df) 求df的行数
```

**描述df**

```python
a.info, describe 分别返回表的 信息概况 和表中 数值列对应的主要统计量 
```

**行列处理**

```python
a.df.drop_duplicates() 删除重复行，如果需要按照列过滤，参数选填['col1', 'col2',...]
b.stock.drop('ts_code',axis=1)  stock.drop(['last','pct_chg'],axis=1)删除列
c.stock.drop(0)   stock.drop([0,1]) 删除行
d.df.column = col_lst 重新制定列名
e.df.rename(index={'row1':'A'}), 重命名索引名 stock.rename(columns=({'last':'last_open'})) 重命名列名
f.df['foo'] = df.Q1 + df.Q2 # 新列为两列相加
g.stock['trade_date']=stock['trade_date'].astype('datetime64')  设置列类型 
h.df.dtypes 查看字段类型
```

**字段处理**

```python
a.all_stock[all_stock['name'].str.contains('宁德时代')]
b.df['date'] = pd.to_datetime(df['date'])  转为时间类型
c.保留小数点后几位 round('amount',2)
```

**时间相关**

```python
a.df = pd.DataFrame({'sales': [3, 3, 3, 9, 10, 6],'signups': [4, 5, 6, 10, 12, 13]}, index=pd.date_range(start='2018/01/01', end='2018/07/01', freq='M'))
```

**获取头部数据**

```python
a.head, tail 函数分别表示返回表或者序列的前 n 行和后 n 行，其中 n 默认为5：
```

**排序**

```python
a.sort_values、sort_index
a.stock.sort_values('high')  df_demo.sort_values(['Weight','Height'],ascending=[True,False],inplace=True)
```

**apply方法**

```python
a.stock['diff']=stock.apply(lambda x:x['open']-x['close'],axis=1) 注意axis的值为1是对一行数据处理
b.stock[['open','close','high']].apply(lambda x:x.mean()) axis默认为0，对一列数据处理
```

**滑动窗口**

```python
a.rolling 、扩张窗口 expanding 以及指数加权窗口 ewm
b.stock['open'].rolling(3,min_periods=1).apply(lambda x:x.mean()) , axis默认为0，在列方向计算，=1在行方向计算,min_periods,表示窗口的最小观测值，即：窗口里面元素的最小数量，默认它是和窗口的长度相等的
c.扩张窗口又称累计窗口，可以理解为一个动态长度的窗口，其窗口的大小就是从序列开始处到具体操作的对应位置，其使用的聚合函数会作用于这些逐步扩张的窗口上。具体地说，设序列为a1, a2, a3, a4，则其每个位置对应的窗口即[a1]、[a1, a2]、[a1, a2, a3]、[a1, a2, a3, a4]。
d.df['tmp']=df['close'].rolling(window=5).apply(lambda t:t.iloc[4])  获取窗口内最后一位元素
```

**滑动取值**

```python
a.shift, diff, pct_change 公共参数为 periods=n ，默认为1，可以不写
b.分别表示取向前第 n 个元素的值、与向前第 n 个元素做差、与向前第 n 个元素相比计算增长率。这里的 n 可以为负，表示反方向的类似操作。
```

**索引**

```python
a.loc
i.a.loc[0:1,'trade_date':'vol']  索引取0到1的（不包含1），列取trade_date到vol的（包含vol），返回df
ii.a.loc[0,'trade_date':'vol'] 取索引为0，列取trade_date到vol的（包含vol），返回series
iii.a.loc[0,'trade_date'] 返回索引为0，列为trade_date的值
iv.a.loc[a['index']&gt;0,['open','close']]  对索引返回过滤，列选择一个list
v.df.loc[df['Q1']&gt; 90, 'Q1':] # Q1大于90，只显示Q1
i.df.loc[(df.Q1&gt; 80) &amp; (df.Q2 &lt; 15)] # and关系  多个条件用括号括起来
b.iloc
i.a.iloc[0,1]  返回第1行，第1列的值
ii.a.iloc[0,1:3]  返回第1行，第2，3列的内容
c.df.set_index(keys='trade_date') 设置某一个字段为索引
```

**query方法**

```python
a.df.query('open&gt;17.50 and open&lt;= 17.56')
b.df.query('open.isin([17.52,17.50])')   stock.query('open not in([12.60,12.41])')
c.df.query('(Grade not in ["Freshman", "Sophomore"]) and (Gender == "Male")')
d.low, high =70, 80    df.query('Weight.between(@low, @high)')   对于 query 中的字符串，如果要引用外部变量，只需在变量名前加 @ 符号
e.也可以使用 or, and, or, isin（==）, not in（！=）
```

**字段类型转换**

```python
a.df = pd.DataFrame(data, dtype='float32') # 对所有字段指定统一类型
b.df = pd.read_excel(data, dtype={'team':'string', 'Q1': 'int32'}) # 对每个字段分别指定
```

**随机抽样**

```python
a.sample 函数中的主要参数为 n, axis, frac, replace, weights ，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）
b.df_sample.sample(3, replace = True, weights = df_sample.value)
```

**分组**

```python
a.df.groupby('open').mean() 
b.df.groupby(df.open&gt;df.avg_open).mean()
c.df.agg({'open':['sum','count'],'close':'max'})
```

**聚合函数**

```python
a.max/min/mean/median/count/all/any/idxmax/idxmin/mad/nunique/skew/quantile/sum/std/var/sem/size/prod
b.df.agg(lambda x:x.max()-x.min())
c.如果想要对聚合结果的列名进行重命名，只需要将上述函数的位置改写成元组，元组的第一个元素为新的名字，第二个位置为原来的函数，包括聚合字符串和自定义函数
```

**变换**

```python
a.gb.transform(lambda x: (x-x.mean())/x.std()).head()
b. cumcount/cumsum/cumprod/cummax/cummin 
```

**过滤**

```python
a.gb.filter(lambda x: x.shape[0] &gt; 100).head() 没看懂
b.df.filter(items=['Q1', 'Q2']) # 选择两列
c.df.filter(regex='Q', axis=1) # 列名包含Q的列
d.df.filter(regex='e$', axis=1) # 以e结尾的列
e.filtered_df = df[df["name"].isin(["Bob", "Dave"])]  
```

**变形**

```python
a.stock.head().pivot(index='open',columns='close',values='high')
b.df.pivot_table(index='Name',columns='Subject', values='Grade',aggfunc=lambda x:x.std())
c.df.melt(id_vars = ['Class', 'Name'], value_vars = ['Chinese', 'Math'], var_name = 'Subject',value_name = 'Grade')
```

**索引的变形**

```python
a.stack 的作用就是把列索引的层压入行索引
b.unstack 函数的作用是把行索引转为列索引
```

**其他变形函数**

```python
a.crosstab
b.explode
c.get_dummies
```

**连接**

```python
a.df1.merge(df2,how='inner',on='name')
b.df1.merge(df2,left_on='name', right_on='name',how='inner',sort=True)
c.df1.merge(df2,left_on='name', right_on='name',how='inner',suffixes=['_chinese','_math']) 两边相同字段添加不同后缀
d.df1.join(df2， how=left'')  索引连接
e.concat 最常用的有三个参数，它们是 axis, join, keys,axis=0 纵向拼接，=1是横向 pd.concat([a,b])
```

**缺失数据**

```python
a.缺失数据可以使用 isna 或 isnull （两个函数没有区别）来查看每个单元格是否缺失，结合 
b.pd.notna(basic['市盈率（TTM）']) 筛选某个字段不为空
c.df[sub_set.isna().all(1)] # 全部缺失
d.a[a.isna().any(1)] # 至少有一个缺失 一行里至少有一个字段缺失
e.df[sub_set.notna().all(1)].head() # 没有缺失
```

**缺失信息的删除**

```python
a.dropna 的主要参数为轴方向 axis （默认为0，即删除行）、删除方式 how 、删除的非缺失值个数阈值 thresh （ 非缺失值 没有达到这个数量的相应维度会被删除）、备选的删除子集 subset ，其中 how 主要有 any 和 all 两种参数可以选择。
b.res = df.dropna(how = 'any', subset = ['Height', 'Weight'])
```

**缺失值的填充和插值**

```python
a. fillna 中有三个参数是常用的： value, method, limit 。其中， value 为填充值，可以是标量，也可以是索引到元素的字典映射； method 为填充方法，有用前面的元素填充 ffill 和用后面的元素填充 bfill 两种类型， limit 参数表示连续缺失值的最大填充次数。
b.df.fillna(0) 用实数0填充na
```

**Nullable类型**

```python
a.在 python 中的缺失值用 None 表示，该元素除了等于自己本身之外，与其他任何元素不相等
b.在 numpy 中利用 np.nan 来表示缺失值，该元素除了不和其他任何元素相等之外，和自身的比较结果也返回 False ：
c.对缺失序列或表格的元素进行比较操作的时候， np.nan 的对应位置会返回 False ，但是在使用 equals 函数进行两张表或两个序列的相同性检验时，会自动跳过两侧表都是缺失值的位置，直接返回 True 
d.从字面意义上看 Nullable 就是可空的，言下之意就是序列类型不受缺失值的影响。例如，在上述三个 Nullable 类型中存储缺失值，都会转为 pandas 内置的 pd.NA ：
e.sum, prod 使用加法和乘法的时候，缺失数据等价于被分别视作0和1，即不改变原来的计算结果：
f.当进行单个标量运算的时候，除了 np.nan ** 0 和 1 ** np.nan 这两种情况为确定的值之外，所有运算结果全为缺失（ pd.NA 的行为与此一致 ），并且 np.nan 在比较操作时一定返回 False ，而 pd.NA 返回 pd.NA
```

**连接mysql**

```python
a.安装包
i.python -m pip install SQLALchemy
b.创建连接引擎
i.con = 'mysql+pymysql://root:Password1?@localhost:3306/mrhd?charset=utf8'
ii.engine = create_engine(con, echo=False)
c.读取数据
i.df=pd.read_sql("select * from azkaban_session_id",con=engine)
d.写出数据
i.b.to_sql(name='azkaban_session_id', con=engine, if_exists='append', index=False, chunksize=1000)
```

**参数**

```python
a.pd.set_option('display.max_columns', 100)
b.pd.set_option('display.max_rows', 100)
c.pd.set_option('display.float_format', lambda x: '%.2f' % x) 控制展示数值小数位数
d.https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/125012967
```

### 6.3 Matplotlib 数据可视化

#### 6.3.1 基础绘图

![](assets/image4.png)  
**基本图表类型**

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# 模拟真实数据分析场景
np.random.seed(42)

# 设置中文字体，防止乱码
plt.rcParams['font.sans-serif'] = ['SimHei']   # 使用黑体
plt.rcParams['axes.unicode_minus'] = False     # 正常显示负号

# 准备数据
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# 1. 线图
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# 基本线图
axes[0, 0].plot(x, y1, label='sin(x)', linewidth=2)
axes[0, 0].plot(x, y2, label='cos(x)', linewidth=2, linestyle='--')
axes[0, 0].set_title('线图示例')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# 2. 散点图
np.random.seed(42)
x_scatter = np.random.randn(100)
y_scatter = np.random.randn(100)
colors = np.random.rand(100)
sizes = 1000 * np.random.rand(100)

scatter = axes[0, 1].scatter(x_scatter, y_scatter, c=colors, s=sizes, alpha=0.6, cmap='viridis')
axes[0, 1].set_title('散点图示例')
plt.colorbar(scatter, ax=axes[0, 1])

# 3. 柱状图
categories = ['A', 'B', 'C', 'D', 'E']
values = [23, 45, 56, 78, 32]
bars = axes[1, 0].bar(categories, values, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'])
axes[1, 0].set_title('柱状图示例')

# 在柱子上添加数值标签
for bar, value in zip(bars, values):
    height = bar.get_height()
    axes[1, 0].text(bar.get_x() + bar.get_width()/2., height + 1,
                    f'{value}', ha='center', va='bottom')

# 4. 直方图
data = np.random.normal(100, 15, 1000)
axes[1, 1].hist(data, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
axes[1, 1].set_title('直方图示例')
axes[1, 1].axvline(data.mean(), color='red', linestyle='--', label=f'均值: {data.mean():.1f}')
axes[1, 1].legend()

plt.tight_layout()
plt.show()
```

**高级图表类型**  
![](assets/image3.png)

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# 模拟真实数据分析场景
np.random.seed(42)

# 设置中文字体，防止乱码
plt.rcParams['font.sans-serif'] = ['SimHei']   # 使用黑体
plt.rcParams['axes.unicode_minus'] = False     # 正常显示负号

# 创建更复杂的图表
fig, axes = plt.subplots(2, 3, figsize=(18, 12))

# 1. 箱线图
data_box = [np.random.normal(0, std, 100) for std in range(1, 4)]
box_plot = axes[0, 0].boxplot(data_box, labels=['Group 1', 'Group 2', 'Group 3'])
axes[0, 0].set_title('箱线图')
axes[0, 0].set_ylabel('数值')

# 2. 小提琴图
parts = axes[0, 1].violinplot(data_box, positions=[1, 2, 3])
axes[0, 1].set_title('小提琴图')
axes[0, 1].set_xticks([1, 2, 3])
axes[0, 1].set_xticklabels(['Group 1', 'Group 2', 'Group 3'])

# 3. 热力图
data_heatmap = np.random.rand(10, 12)
im = axes[0, 2].imshow(data_heatmap, cmap='YlOrRd', aspect='auto')
axes[0, 2].set_title('热力图')
plt.colorbar(im, ax=axes[0, 2])

# 4. 极坐标图
theta = np.linspace(0, 2*np.pi, 100)
r = 1 + 0.3*np.cos(5*theta)
axes[1, 0] = plt.subplot(2, 3, 4, projection='polar')
axes[1, 0].plot(theta, r)
axes[1, 0].set_title('极坐标图')

# 5. 3D散点图
ax_3d = plt.subplot(2, 3, 5, projection='3d')
x_3d = np.random.randn(100)
y_3d = np.random.randn(100)
z_3d = np.random.randn(100)
ax_3d.scatter(x_3d, y_3d, z_3d, c=z_3d, cmap='viridis')
ax_3d.set_title('3D散点图')

# 6. 饼图
sizes = [30, 25, 20, 15, 10]
labels = ['A', 'B', 'C', 'D', 'E']
colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7']
explode = (0.1, 0, 0, 0, 0)  # 突出显示第一个扇形

axes[1, 2].pie(sizes, labels=labels, colors=colors, explode=explode,
               autopct='%1.1f%%', shadow=True, startangle=90)
axes[1, 2].set_title('饼图')

plt.tight_layout()
plt.show()
```

#### 6.3.2 图形样式与美化

**颜色和样式设置**

```python
# 自定义颜色方案
colors = {
    'primary': '#2E86AB',
    'secondary': '#A23B72',
    'accent': '#F18F01',
    'success': '#C73E1D',
    'info': '#592E83'
}

# 创建专业的图表
fig, ax = plt.subplots(figsize=(12, 8))

# 数据
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
sales_2022 = [120, 135, 140, 155, 168, 180, 175, 185, 190, 200, 195, 210]
sales_2023 = [130, 145, 160, 170, 185, 195, 190, 200, 210, 220, 215, 230]

# 绘制线图
line1 = ax.plot(months, sales_2022, marker='o', linewidth=3, 
                color=colors['primary'], label='2022年销售额', markersize=8)
line2 = ax.plot(months, sales_2023, marker='s', linewidth=3, 
                color=colors['secondary'], label='2023年销售额', markersize=8)

# 填充区域
ax.fill_between(months, sales_2022, alpha=0.3, color=colors['primary'])
ax.fill_between(months, sales_2023, alpha=0.3, color=colors['secondary'])

# 样式设置
ax.set_title('月度销售额对比', fontsize=20, fontweight='bold', pad=20)
ax.set_xlabel('月份', fontsize=14, fontweight='bold')
ax.set_ylabel('销售额 (万元)', fontsize=14, fontweight='bold')

# 网格设置
ax.grid(True, linestyle='--', alpha=0.7, color='gray')
ax.set_facecolor('#F8F9FA')

# 图例设置
legend = ax.legend(loc='upper left', fontsize=12, frameon=True, 
                  fancybox=True, shadow=True, framealpha=0.9)
legend.get_frame().set_facecolor('white')

# 坐标轴设置
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_linewidth(2)
ax.spines['bottom'].set_linewidth(2)

# 添加注释
max_2023_idx = sales_2023.index(max(sales_2023))
ax.annotate(f'最高点: {max(sales_2023)}万', 
            xy=(max_2023_idx, max(sales_2023)), 
            xytext=(max_2023_idx+1, max(sales_2023)+10),
            arrowprops=dict(arrowstyle='-&gt;', color='red', lw=2),
            fontsize=12, color='red', fontweight='bold')

plt.tight_layout()
plt.show()
```

#### 6.3.3 多子图与布局

**复杂布局示例**  
![](assets/image2.png)

```python
# 创建复杂的子图布局
fig = plt.figure(figsize=(16, 12))

# 使用GridSpec创建不规则布局
gs = fig.add_gridspec(3, 4, hspace=0.3, wspace=0.3)

# 主图 (占据2x2空间)
ax_main = fig.add_subplot(gs[0:2, 0:2])
x = np.linspace(0, 10, 100)
y = np.sin(x) * np.exp(-x/10)
ax_main.plot(x, y, linewidth=3, color='#2E86AB')
ax_main.set_title('主图：衰减正弦波', fontsize=16, fontweight='bold')
ax_main.grid(True, alpha=0.3)

# 右上角小图
ax_top_right = fig.add_subplot(gs[0, 2:])
categories = ['A', 'B', 'C', 'D']
values = [25, 35, 30, 20]
ax_top_right.bar(categories, values, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'])
ax_top_right.set_title('分类统计')

# 右中间小图
ax_mid_right = fig.add_subplot(gs[1, 2:])
data = np.random.normal(0, 1, 1000)
ax_mid_right.hist(data, bins=30, alpha=0.7, color='orange')
ax_mid_right.set_title('数据分布')

# 底部横跨图
ax_bottom = fig.add_subplot(gs[2, :])
dates = pd.date_range('2023-01-01', periods=100, freq='D')
values = np.cumsum(np.random.randn(100))
ax_bottom.plot(dates, values, linewidth=2)
ax_bottom.set_title('时间序列数据')
ax_bottom.tick_params(axis='x', rotation=45)

plt.suptitle('复杂布局示例', fontsize=20, fontweight='bold', y=0.98)
plt.show()
```

#### 6.3.4 实战案例

**综合数据分析可视化**  
![2](assets/image.png)

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# 模拟真实数据分析场景
np.random.seed(42)

# 设置中文字体，防止乱码
plt.rcParams['font.sans-serif'] = ['SimHei']   # 使用黑体
plt.rcParams['axes.unicode_minus'] = False     # 正常显示负号
# 模拟真实数据分析场景
np.random.seed(42)

# 生成模拟数据
dates = pd.date_range('2023-01-01', periods=365, freq='D')
base_sales = 1000
trend = np.linspace(0, 200, 365)
seasonal = 100 * np.sin(2 * np.pi * np.arange(365) / 365.25 * 4)
noise = np.random.normal(0, 50, 365)
sales = base_sales + trend + seasonal + noise

# 创建DataFrame
df = pd.DataFrame({
    'date': dates,
    'sales': sales,
    'month': dates.month,
    'weekday': dates.dayofweek
})

# 创建综合分析图表
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. 时间序列图
axes[0, 0].plot(df['date'], df['sales'], linewidth=1, alpha=0.7, color='#2E86AB')
# 添加移动平均线
df['sales_ma'] = df['sales'].rolling(window=30).mean()
axes[0, 0].plot(df['date'], df['sales_ma'], linewidth=3, color='#A23B72', label='30日移动平均')
axes[0, 0].set_title('日销售额趋势', fontsize=14, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# 2. 月度销售分布
monthly_sales = df.groupby('month')['sales'].mean()
bars = axes[0, 1].bar(monthly_sales.index, monthly_sales.values, 
                     color='#4ECDC4', alpha=0.8, edgecolor='black')
axes[0, 1].set_title('月度平均销售额', fontsize=14, fontweight='bold')
axes[0, 1].set_xlabel('月份')
axes[0, 1].set_ylabel('平均销售额')

# 添加数值标签
for bar in bars:
    height = bar.get_height()
    axes[0, 1].text(bar.get_x() + bar.get_width()/2., height + 10,
                    f'{height:.0f}', ha='center', va='bottom', fontweight='bold')

# 3. 星期销售模式
weekday_names = ['周一', '周二', '周三', '周四', '周五', '周六', '周日']
weekday_sales = df.groupby('weekday')['sales'].mean()
axes[1, 0].plot(weekday_sales.index, weekday_sales.values, 
               marker='o', linewidth=3, markersize=8, color='#F18F01')
axes[1, 0].set_title('星期销售模式', fontsize=14, fontweight='bold')
axes[1, 0].set_xticks(range(7))
axes[1, 0].set_xticklabels(weekday_names)
axes[1, 0].grid(True, alpha=0.3)

# 4. 销售额分布直方图
axes[1, 1].hist(df['sales'], bins=50, alpha=0.7, color='#96CEB4', edgecolor='black')
axes[1, 1].axvline(df['sales'].mean(), color='red', linestyle='--', linewidth=2, 
                  label=f'均值: {df["sales"].mean():.0f}')
axes[1, 1].axvline(df['sales'].median(), color='orange', linestyle='--', linewidth=2, 
                  label=f'中位数: {df["sales"].median():.0f}')
axes[1, 1].set_title('销售额分布', fontsize=14, fontweight='bold')
axes[1, 1].legend()

plt.suptitle('2023年销售数据综合分析', fontsize=18, fontweight='bold', y=0.98)
plt.tight_layout()
plt.show()

# 输出统计摘要
print("销售数据统计摘要:")
print(f"总销售额: {df['sales'].sum():,.0f}")
print(f"平均日销售额: {df['sales'].mean():.0f}")
print(f"最高日销售额: {df['sales'].max():.0f}")
print(f"最低日销售额: {df['sales'].min():.0f}")
print(f"销售额标准差: {df['sales'].std():.0f}")
```

**折线图柱状图（同时显示数量和百分比）**

![图片1](assets/image1.png)

```python
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from matplotlib.ticker import FuncFormatter

# 数据准备
data = {
    "key": ["1-5","6-10","11-15","16-20","21-25","26-30","31-35","36-40","41-45","46-50",
           "51-55","56-60","61-65","66-70","71-75","76-80","81-85","86-90","91-95","96-100"],
    "count": [64926535,1138119,411539,216186,131126,89296,66155,52622,45228,32027,
             23867,22066,17321,13541,10670,8168,5837,5157,5305,38348],
    "percentage": [96.53,1.69,0.61,0.32,0.19,0.13,0.10,0.08,0.07,0.05,
                  0.04,0.03,0.03,0.02,0.02,0.01,0.01,0.01,0.01,0.06]
}

df = pd.DataFrame(data)

# 设置样式
plt.style.use('ggplot')

# 解决中文显示问题
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] 
plt.rcParams['axes.unicode_minus'] = False

# 创建图形
fig, ax1 = plt.subplots(figsize=(14, 7))

# 自定义颜色
bar_color = '#4C72B0'
line_color = '#C44E52'

# 柱状图 (左侧Y轴)
bars = ax1.bar(df['key'], df['count'], color=bar_color, alpha=0.7, width=0.8)
ax1.set_ylabel('数量（万）', color=bar_color, fontsize=12)
ax1.tick_params(axis='y', labelcolor=bar_color)
ax1.set_yscale('log')

# 设置Y轴为中文单位（万）
def format_wan(x, pos):
    return f'{x/10000:.0f}万' if x &gt;= 10000 else f'{x:.0f}'

ax1.yaxis.set_major_formatter(FuncFormatter(format_wan))

# 在柱子上添加标签（百分比和数量）
for bar, count, percentage in zip(bars, df['count'], df['percentage']):
    height = bar.get_height()
    count_wan = count/10000

    # 在柱子上方显示百分比
    ax1.text(bar.get_x() + bar.get_width()/2, height*1.05, 
            f'{percentage:.2f}%', 
            ha='center', va='bottom', fontsize=9, color='black')

    # 在柱子内部显示数量（万）
    ax1.text(bar.get_x() + bar.get_width()/2, height*0.5, 
            f'{count_wan:.1f}万' if count_wan &lt; 10 else f'{count_wan:.0f}万', 
            ha='center', va='center', fontsize=9, color='white',
            fontweight='bold')

# 折线图 (右侧Y轴)
ax2 = ax1.twinx()
line = ax2.plot(df['key'], df['percentage'], color=line_color, 
                marker='o', markersize=6, linewidth=2.5, alpha=0.9)
ax2.set_ylabel('百分比 (%)', color=line_color, fontsize=12)
ax2.tick_params(axis='y', labelcolor=line_color)
ax2.grid(False)
ax2.set_yscale('log')  # 设置右侧Y轴为对数刻度

# 设置百分比的对数刻度格式
def format_percent(x, pos):
    return f'{x:.2f}%' if x &gt;= 0.1 else f'{x:.3f}%'

ax2.yaxis.set_major_formatter(FuncFormatter(format_percent))

# 设置X轴
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.xlim(-0.5, len(df['key'])-0.5)

# 添加标题和网格
plt.title('uuid推测出来wifi数量分布', fontsize=14, pad=20)
ax1.grid(True, which="both", ls="--", linewidth=0.5, alpha=0.3)

# 调整布局
plt.tight_layout()

# 添加图例
from matplotlib.lines import Line2D
legend_elements = [
    Line2D([0], [0], color=bar_color, lw=4, label='数量（对数刻度）'),
    Line2D([0], [0], color=line_color, marker='o', lw=2.5, label='百分比（对数刻度）')
]
ax1.legend(handles=legend_elements, loc='upper right', fontsize=10)

plt.show()
```

### 6.4 Bokeh 交互式可视化

#### 6.4.1 Bokeh 基础

**环境设置与基本概念**

```python
from bokeh.plotting import figure, show, output_notebook, output_file
from bokeh.layouts import column, row, gridplot
from bokeh.models import HoverTool, ColumnDataSource, Range1d, LinearAxis
from bokeh.palettes import Category20, Viridis256
from bokeh.transform import factor_cmap
import pandas as pd
import numpy as np

# Jupyter Notebook中显示
output_notebook()

# 或者输出到HTML文件
# output_file("bokeh_plot.html")
```

**基本图表创建**

```python
# 创建基础图形对象
p = figure(
    title="基础Bokeh图表",
    width=800, 
    height=400,
    x_axis_label='X轴',
    y_axis_label='Y轴',
    toolbar_location="above"
)

# 生成示例数据
x = np.linspace(0, 4*np.pi, 100)
y = np.sin(x)

# 添加线图
line = p.line(x, y, legend_label="sin(x)", line_width=2, color='navy')

# 添加圆点
circles = p.circle(x[::5], y[::5], legend_label="采样点", size=8, color='red', alpha=0.6)

# 设置图例
p.legend.location = "top_right"
p.legend.click_policy = "hide"

show(p)
```

#### 6.4.2 基本图表类型

**线图和散点图**

```python
# 创建多种线图
p1 = figure(title="多线图示例", width=600, height=400)

# 数据准备
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)
y3 = np.sin(x) * np.cos(x)

# 添加多条线
p1.line(x, y1, legend_label="sin(x)", line_width=2, color='red')
p1.line(x, y2, legend_label="cos(x)", line_width=2, color='blue', line_dash='dashed')
p1.line(x, y3, legend_label="sin(x)*cos(x)", line_width=2, color='green', line_dash='dotted')

# 散点图
p2 = figure(title="散点图示例", width=600, height=400)

# 生成随机数据
n = 100
x_scatter = np.random.random(n) * 100
y_scatter = np.random.random(n) * 100
colors = np.random.choice(['red', 'green', 'blue', 'orange', 'purple'], n)
sizes = np.random.randint(10, 30, n)

p2.scatter(x_scatter, y_scatter, size=sizes, color=colors, alpha=0.6)

# 显示图表
show(column(p1, p2))
```

**柱状图和条形图**

```python
# 柱状图
categories = ['产品A', '产品B', '产品C', '产品D', '产品E']
values = [23, 45, 56, 78, 32]

p3 = figure(x_range=categories, title="产品销售对比", width=600, height=400)

# 创建柱状图
bars = p3.vbar(x=categories, top=values, width=0.8, 
               color=factor_cmap('x', palette=Category20[5], factors=categories))

# 添加数值标签
from bokeh.models import LabelSet
source = ColumnDataSource(data=dict(x=categories, y=values))
labels = LabelSet(x='x', y='y', text='y', level='glyph',
                 x_offset=-10, y_offset=5, source=source)
p3.add_layout(labels)

# 水平条形图
p4 = figure(y_range=categories, title="水平条形图", width=600, height=400)
p4.hbar(y=categories, right=values, height=0.8, color='lightblue')

show(row(p3, p4))
```

**时间序列图**

```python
# 时间序列数据
dates = pd.date_range('2023-01-01', periods=100, freq='D')
values = np.cumsum(np.random.randn(100)) + 100

# 创建时间序列图
p5 = figure(title="时间序列图", width=800, height=400, x_axis_type='datetime')

# 添加线图
p5.line(dates, values, line_width=2, color='navy')

# 添加圆点标记
p5.circle(dates[::10], values[::10], size=8, color='red', alpha=0.8)

# 设置日期格式
from bokeh.models import DatetimeTickFormatter
p5.xaxis.formatter = DatetimeTickFormatter(
    hours=["%d %B %Y"],
    days=["%d %B %Y"],
    months=["%d %B %Y"],
    years=["%d %B %Y"],
)

show(p5)
```

#### 6.4.3 交互式功能

**悬停工具和选择**

```python
# 创建带悬停工具的散点图
source = ColumnDataSource(data=dict(
    x=np.random.random(100) * 100,
    y=np.random.random(100) * 100,
    size=np.random.randint(10, 30, 100),
    color=np.random.choice(['red', 'green', 'blue', 'orange'], 100),
    alpha=np.random.random(100),
    name=['点' + str(i) for i in range(100)]
))

# 创建悬停工具
hover = HoverTool(tooltips=[
    ("索引", "$index"),
    ("名称", "@name"),
    ("坐标", "($x, $y)"),
    ("大小", "@size")
])

p6 = figure(title="交互式散点图", width=600, height=400, tools=[hover, 'pan', 'wheel_zoom', 'reset'])

# 添加散点
circles = p6.circle('x', 'y', size='size', color='color', alpha='alpha', source=source)

show(p6)
```

**缩放和平移**

```python
# 创建可缩放的大数据集图表
n = 10000
x_large = np.random.randn(n)
y_large = np.random.randn(n)

p7 = figure(title="大数据集可视化", width=800, height=600, 
           tools='pan,wheel_zoom,box_zoom,reset,save')

# 使用alpha通道处理重叠
p7.circle(x_large, y_large, size=3, alpha=0.1, color='navy')

# 添加选择工具
from bokeh.models import BoxSelectTool, LassoSelectTool
p7.add_tools(BoxSelectTool())
p7.add_tools(LassoSelectTool())

show(p7)
```

#### 6.4.4 布局与组合

**多图布局**

```python
# 创建多个子图
p8 = figure(title="图1", width=300, height=300)
p8.circle([1, 2, 3], [1, 4, 2], size=20, color='red')

p9 = figure(title="图2", width=300, height=300)
p9.line([1, 2, 3, 4], [1, 3, 2, 4], line_width=3, color='blue')

p10 = figure(title="图3", width=300, height=300)
p10.vbar(x=[1, 2, 3], top=[1, 3, 2], width=0.5, color='green')

p11 = figure(title="图4", width=300, height=300)
p11.triangle([1, 2, 3], [1, 3, 2], size=20, color='orange')

# 网格布局
grid = gridplot([[p8, p9], [p10, p11]], sizing_mode='scale_width')
show(grid)
```

**复杂仪表板布局**

```python
from bokeh.layouts import layout
from bokeh.models import Div

# 创建标题
title = Div(text="<h1>销售数据仪表板</h1>", width=800, height=50)

# 主图表
main_plot = figure(title="月度销售趋势", width=600, height=400)
months = ['1月', '2月', '3月', '4月', '5月', '6月']
sales = [120, 135, 140, 155, 168, 180]
main_plot.line(range(len(months)), sales, line_width=3, color='navy')
main_plot.circle(range(len(months)), sales, size=10, color='red')
main_plot.xaxis.ticker = list(range(len(months)))
main_plot.xaxis.major_label_overrides = dict(zip(range(len(months)), months))

# 侧边图表
side_plot1 = figure(title="产品分布", width=300, height=200)
products = ['A', 'B', 'C', 'D']
counts = [25, 35, 20, 30]
side_plot1.vbar(x=products, top=counts, width=0.8, color='lightblue')

side_plot2 = figure(title="地区销售", width=300, height=200)
regions = ['北区', '南区', '东区', '西区']
region_sales = [40, 30, 20, 35]
side_plot2.vbar(x=regions, top=region_sales, width=0.8, color='lightgreen')

# 组合布局
dashboard = layout([
    [title],
    [main_plot, column(side_plot1, side_plot2)]
])

show(dashboard)
```

#### 6.4.5 Pandas-Bokeh 集成

**快速绘图**

```python
import pandas_bokeh

# 设置输出到notebook
pandas_bokeh.output_notebook()

# 创建示例数据
df = pd.DataFrame({
    'date': pd.date_range('2023-01-01', periods=100, freq='D'),
    'sales': np.cumsum(np.random.randn(100)) + 1000,
    'profit': np.cumsum(np.random.randn(100)) + 200,
    'category': np.random.choice(['A', 'B', 'C'], 100)
})

# 快速线图
df.plot_bokeh.line(
    x='date',
    y=['sales', 'profit'],
    title='销售和利润趋势',
    figsize=(800, 400)
)

# 快速柱状图
category_summary = df.groupby('category').agg({
    'sales': 'mean',
    'profit': 'mean'
}).reset_index()

category_summary.plot_bokeh.bar(
    x='category',
    y=['sales', 'profit'],
    title='各类别平均销售和利润',
    stacked=True,
    figsize=(600, 400)
)

# 散点图
df.plot_bokeh.scatter(
    x='sales',
    y='profit',
    category='category',
    title='销售vs利润散点图',
    figsize=(600, 400),
    colormap=['red', 'green', 'blue']
)
```

#### 6.4.6 高级应用

**实时数据更新**

```python
from bokeh.models import ColumnDataSource
from bokeh.io import curdoc
from bokeh.plotting import figure
import random

# 创建数据源
source = ColumnDataSource(data=dict(x=[], y=[]))

# 创建图表
p = figure(title="实时数据流", width=600, height=400)
line = p.line('x', 'y', source=source, line_width=2, color='navy')

# 更新函数
def update():
    new_data = dict(
        x=[source.data['x'][-1] + 1 if source.data['x'] else 0],
        y=[random.random()]
    )
    source.stream(new_data, rollover=100)  # 保持最近100个点

# 添加定期回调（在Bokeh服务器中使用）
# curdoc().add_periodic_callback(update, 100)

show(p)
```

**自定义交互**

```python
from bokeh.models import CustomJS, Slider
from bokeh.layouts import column

# 创建数据
x = np.linspace(0, 4*np.pi, 100)
y = np.sin(x)
source = ColumnDataSource(data=dict(x=x, y=y))

# 创建图表
plot = figure(title="交互式正弦波", width=600, height=400)
line = plot.line('x', 'y', source=source, line_width=2, color='navy')

# 创建滑块
freq_slider = Slider(start=0.1, end=5, value=1, step=0.1, title="频率")
amp_slider = Slider(start=0.1, end=3, value=1, step=0.1, title="振幅")

# JavaScript回调
callback = CustomJS(args=dict(source=source, freq=freq_slider, amp=amp_slider), code="""
    const data = source.data;
    const f = freq.value;
    const a = amp.value;
    const x = data['x'];
    const y = data['y'];
    for (let i = 0; i &lt; x.length; i++) {
        y[i] = a * Math.sin(f * x[i]);
    }
    source.change.emit();
""")

freq_slider.js_on_change('value', callback)
amp_slider.js_on_change('value', callback)

# 组合布局
layout = column(freq_slider, amp_slider, plot)
show(layout)
```

### tushare

```python
1.获取api 
a.pro = ts.pro_api('5d03fb68286c12bd294170ab5e8768b28e148a5e420d47b4b3b884dd')
2.获取所有股票
a.all_stock = pro.stock_basic()
3.通用行情接口
a.df = ts.pro_bar(ts_code='000001.SZ', adj='qfq', start_date='20180101', end_date='20181011',ma=[5, 20, 50],factors=['tor', 'vr'])
b.参数
i.asset    资产类别：E股票 I沪深指数 C数字货币 FT期货 FD基金 O期权 CB可转债（v1.2.39），默认E
ii.adj    复权类型(只针对股票)：None未复权 qfq前复权 hfq后复权 , 默认None
iii.freq    数据频度 ：支持分钟(min)/日(D)/周(W)/月(M)K线，其中1min表示1分钟（类推1/5/15/30/60分钟） ，默认D
iv.ma    均线，支持任意合理int数值 e.g: ma_5表示5日均价，ma_v_5表示5日均量
v.factors    股票因子（asset='E'有效）支持 tor换手率 vr量比  factors=['tor', 'vr']
4.获取某一只股票行情
a.pro.daily(ts_code=code)
# 获取一只股票方法
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        return pro.daily(ts_code=code)
5.定义获取股票行情方法
# 根据股票中文名称获取股票行情信息
def get_stock(name):
    all_stock = pro.stock_basic()
    all=all_stock[all_stock['name'].str.contains(name)]
    if len(all)==0:
        print('没有符合条件的股票')
    else:
        print(all)
        print('获取第一行股票的行情信息')
        code=all.head(1)['ts_code'].iloc[0]
        stock=pro.daily(ts_code=code)
        stock.sort_values(by='trade_date',ascending=True,inplace=True)
        stock['trade_date']=stock['trade_date'].astype('datetime64')
        stock['avg_amount']=stock['amount']*10/stock['vol']
        stock['5d_ma']=stock['close'].rolling(5).apply(lambda x:x.mean())
        stock['10d_ma']=stock['close'].rolling(10).apply(lambda x:x.mean())
        stock=stock.dropna(how='any')
        stock.reset_index(inplace=True,drop=True)
        return stock
```

## 7\. Python面试题集

### 7.1 基础语法题

#### 题目1：Python中的可变与不可变对象

**问题**：解释Python中可变对象和不可变对象的区别，并举例说明。

**答案**：

*   **不可变对象**：创建后不能修改的对象，包括int、float、str、tuple、frozenset
*   **可变对象**：创建后可以修改的对象，包括list、dict、set

```python
# 不可变对象示例
a = "hello"
b = a
a += " world"
print(f"a: {a}, b: {b}")  # a: hello world, b: hello

# 可变对象示例
list1 = [1, 2, 3]
list2 = list1
list1.append(4)
print(f"list1: {list1}, list2: {list2}")  # list1: [1, 2, 3, 4], list2: [1, 2, 3, 4]
```

#### 题目2：深拷贝与浅拷贝

**问题**：解释深拷贝和浅拷贝的区别，什么时候使用？

**答案**：

*   **浅拷贝**：创建新对象，但内部元素仍然是原对象的引用
*   **深拷贝**：创建新对象，内部元素也是新创建的

```python
import copy

# 原始数据
original = [[1, 2, 3], [4, 5, 6]]

# 浅拷贝
shallow = copy.copy(original)
shallow[0][0] = 'X'
print(f"原始: {original}")  # [[X, 2, 3], [4, 5, 6]]

# 深拷贝
original = [[1, 2, 3], [4, 5, 6]]
deep = copy.deepcopy(original)
deep[0][0] = 'X'
print(f"原始: {original}")  # [[1, 2, 3], [4, 5, 6]]
print(f"深拷贝: {deep}")    # [[X, 2, 3], [4, 5, 6]]
```

#### 题目3：Python中的作用域

**问题**：解释Python的LEGB规则，并给出示例。

**答案**：  
LEGB规则是Python变量查找的顺序：

*   \*\*L (Local)\*\*：局部作用域
*   \*\*E (Enclosing)\*\*：闭包作用域
*   \*\*G (Global)\*\*：全局作用域
*   \*\*B (Built-in)\*\*：内置作用域

```python
x = "global"

def outer():
    x = "enclosing"

    def inner():
        x = "local"
        print(f"inner中的x: {x}")  # local

    inner()
    print(f"outer中的x: {x}")  # enclosing

outer()
print(f"全局x: {x}")  # global
```

### 7.2 面向对象题

#### 题目4：类方法、静态方法和实例方法

**问题**：解释@classmethod、@staticmethod和普通方法的区别。

**答案**：

```python
class MyClass:
    class_var = "类变量"

    def __init__(self, value):
        self.instance_var = value

    def instance_method(self):
        """实例方法：可以访问实例和类属性"""
        return f"实例方法访问: {self.instance_var}, {self.class_var}"

    @classmethod
    def class_method(cls):
        """类方法：只能访问类属性，不能访问实例属性"""
        return f"类方法访问: {cls.class_var}"

    @staticmethod
    def static_method():
        """静态方法：不能访问类或实例属性"""
        return "静态方法：独立的功能函数"

# 使用示例
obj = MyClass("实例值")
print(obj.instance_method())  # 实例方法访问: 实例值, 类变量
print(MyClass.class_method())  # 类方法访问: 类变量
print(MyClass.static_method())  # 静态方法：独立的功能函数
```

#### 题目5：多重继承和MRO

**问题**：解释Python的多重继承和方法解析顺序(MRO)。

**答案**：

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

# 查看MRO
print(D.mro())  # [D, B, C, A, object]

# 调用方法
d = D()
d.method()
# 输出：
# D.method
# B.method
# C.method
# A.method
```

### 7.3 高级特性题

#### 题目6：装饰器的实现原理

**问题**：手写一个计时装饰器，支持带参数的装饰器。

**答案**：

```python
import time
import functools

def timer(prefix=""):
    """带参数的计时装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(f"{prefix}{func.__name__} 执行时间: {end - start:.4f}秒")
            return result
        return wrapper
    return decorator

# 使用装饰器
@timer("API调用 - ")
def api_call():
    time.sleep(1)
    return "数据"

result = api_call()  # API调用 - api_call 执行时间: 1.0001秒
```

#### 题目7：生成器和迭代器

**问题**：实现一个斐波那契数列的生成器，并解释生成器的优势。

**答案**：

```python
def fibonacci_generator(n):
    """斐波那契数列生成器"""
    a, b = 0, 1
    count = 0
    while count &lt; n:
        yield a
        a, b = b, a + b
        count += 1

# 使用生成器
fib = fibonacci_generator(10)
print(list(fib))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

# 生成器的优势：
# 1. 内存效率：按需生成，不占用大量内存
# 2. 惰性求值：只在需要时计算
# 3. 可以处理无限序列

def infinite_fibonacci():
    """无限斐波那契数列"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 只取前10个
fib_infinite = infinite_fibonacci()
first_10 = [next(fib_infinite) for _ in range(10)]
print(first_10)
```

#### 题目8：上下文管理器

**问题**：实现一个数据库连接的上下文管理器。

**答案**：

```python
from contextlib import contextmanager

class DatabaseConnection:
    """数据库连接上下文管理器"""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None

    def __enter__(self):
        print(f"连接到数据库 {self.host}:{self.port}")
        self.connection = f"connection_to_{self.host}_{self.port}"
        return self.connection

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("关闭数据库连接")
        if exc_type:
            print(f"发生异常: {exc_type.__name__}: {exc_val}")
            # 可以在这里处理异常，比如回滚事务
        self.connection = None
        return False  # 不抑制异常

# 使用contextlib实现
@contextmanager
def database_connection(host, port):
    """使用contextlib实现的数据库连接"""
    print(f"连接到数据库 {host}:{port}")
    connection = f"connection_to_{host}_{port}"
    try:
        yield connection
    except Exception as e:
        print(f"数据库操作异常: {e}")
        raise
    finally:
        print("关闭数据库连接")

# 使用示例
with DatabaseConnection("localhost", 5432) as conn:
    print(f"使用连接: {conn}")
```

### 7.4 性能优化题

#### 题目9：Python性能优化技巧

**问题**：列举Python性能优化的常用方法，并给出示例。

**答案**：

```python
import time
from functools import lru_cache

# 1. 使用列表推导式而不是循环
def slow_way():
    result = []
    for i in range(1000000):
        if i % 2 == 0:
            result.append(i * 2)
    return result

def fast_way():
    return [i * 2 for i in range(1000000) if i % 2 == 0]

# 2. 使用缓存装饰器
@lru_cache(maxsize=128)
def fibonacci_cached(n):
    if n &lt;= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_naive(n):
    if n &lt;= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

# 3. 使用生成器节省内存
def memory_efficient_processing(data):
    """内存高效的数据处理"""
    for item in data:
        if item &gt; 0:
            yield item * 2

# 4. 使用set进行快速查找
def slow_lookup(items, targets):
    result = []
    for target in targets:
        if target in items:  # O(n) 查找
            result.append(target)
    return result

def fast_lookup(items, targets):
    item_set = set(items)  # O(1) 查找
    return [target for target in targets if target in item_set]

# 5. 字符串拼接优化
def slow_string_concat(strings):
    result = ""
    for s in strings:
        result += s  # 每次都创建新字符串
    return result

def fast_string_concat(strings):
    return "".join(strings)  # 一次性拼接
```

#### 题目10：内存管理和垃圾回收

**问题**：解释Python的内存管理机制，如何避免内存泄漏？

**答案**：

```python
import gc
import weakref

# 1. 引用计数
def reference_counting_demo():
    """引用计数演示"""
    import sys

    obj = [1, 2, 3]
    print(f"引用计数: {sys.getrefcount(obj)}")  # 2 (包括getrefcount的参数)

    ref1 = obj
    print(f"引用计数: {sys.getrefcount(obj)}")  # 3

    del ref1
    print(f"引用计数: {sys.getrefcount(obj)}")  # 2

# 2. 循环引用问题
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.parent = None

    def add_child(self, child):
        child.parent = self  # 创建循环引用
        self.children.append(child)

# 3. 使用弱引用解决循环引用
class WeakNode:
    def __init__(self, value):
        self.value = value
        self.children = []
        self._parent = None

    @property
    def parent(self):
        return self._parent() if self._parent else None

    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value) if value else None

# 4. 手动垃圾回收
def manual_gc():
    """手动触发垃圾回收"""
    # 创建循环引用
    root = Node("root")
    child = Node("child")
    root.add_child(child)

    # 删除引用
    del root, child

    # 手动触发垃圾回收
    collected = gc.collect()
    print(f"回收了 {collected} 个对象")

# 5. 内存优化技巧
class OptimizedClass:
    """使用__slots__优化内存"""
    __slots__ = ['name', 'age']  # 限制属性，节省内存

    def __init__(self, name, age):
        self.name = name
        self.age = age
```

### 7.5 实战编程题

#### 题目11：实现LRU缓存

**问题**：手动实现一个LRU(Least Recently Used)缓存。

**答案**：

```python
from collections import OrderedDict

class LRUCache:
    """LRU缓存实现"""

    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key):
        if key in self.cache:
            # 移动到末尾（最近使用）
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    def put(self, key, value):
        if key in self.cache:
            # 更新值并移动到末尾
            self.cache[key] = value
            self.cache.move_to_end(key)
        else:
            # 检查容量
            if len(self.cache) &gt;= self.capacity:
                # 删除最久未使用的项（第一个）
                self.cache.popitem(last=False)
            self.cache[key] = value

# 使用示例
lru = LRUCache(2)
lru.put(1, 1)
lru.put(2, 2)
print(lru.get(1))  # 1
lru.put(3, 3)      # 删除key=2
print(lru.get(2))  # -1 (not found)
print(lru.get(3))  # 3
print(lru.get(1))  # 1
```

#### 题目12：单例模式的多种实现

**问题**：用多种方法实现单例模式。

**答案**：

```python
# 方法1：使用__new__方法
class Singleton1:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

# 方法2：使用装饰器
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Singleton2:
    def __init__(self, value):
        self.value = value

# 方法3：使用元类
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton3(metaclass=SingletonMeta):
    def __init__(self, value):
        self.value = value

# 方法4：使用模块（Python推荐）
# singleton_module.py
class _Singleton:
    def __init__(self):
        self.value = None

instance = _Singleton()

# 测试
s1 = Singleton1()
s2 = Singleton1()
print(s1 is s2)  # True
```

#### 题目13：实现一个简单的线程池

**问题**：实现一个基本的线程池。

**答案**：

```python
import threading
import queue
import time

class ThreadPool:
    """简单的线程池实现"""

    def __init__(self, num_threads):
        self.num_threads = num_threads
        self.task_queue = queue.Queue()
        self.threads = []
        self.shutdown = False

        # 创建工作线程
        for _ in range(num_threads):
            thread = threading.Thread(target=self._worker)
            thread.daemon = True
            thread.start()
            self.threads.append(thread)

    def _worker(self):
        """工作线程函数"""
        while not self.shutdown:
            try:
                # 获取任务（超时1秒）
                task, args, kwargs = self.task_queue.get(timeout=1)
                try:
                    task(*args, **kwargs)
                except Exception as e:
                    print(f"任务执行异常: {e}")
                finally:
                    self.task_queue.task_done()
            except queue.Empty:
                continue

    def submit(self, task, *args, **kwargs):
        """提交任务"""
        if not self.shutdown:
            self.task_queue.put((task, args, kwargs))

    def wait_completion(self):
        """等待所有任务完成"""
        self.task_queue.join()

    def shutdown_pool(self):
        """关闭线程池"""
        self.shutdown = True
        for thread in self.threads:
            thread.join()

# 使用示例
def worker_task(name, duration):
    print(f"任务 {name} 开始执行")
    time.sleep(duration)
    print(f"任务 {name} 执行完成")

# 创建线程池
pool = ThreadPool(3)

# 提交任务
for i in range(5):
    pool.submit(worker_task, f"Task-{i}", 1)

# 等待完成
pool.wait_completion()
pool.shutdown_pool()
```

## 8\. 总结与进阶方向

### Python学习路径总结

**基础阶段**：

1.  掌握Python基本语法和数据类型
2.  理解控制流和函数定义
3.  学习面向对象编程基础

**进阶阶段**：

1.  深入理解Python高级特性（装饰器、生成器、上下文管理器）
2.  掌握内存管理和性能优化
3.  学习常用库和框架

**专业阶段**：

1.  选择专业方向深入学习
2.  参与开源项目
3.  持续关注Python生态发展

### 专业方向选择

| 方向 | 核心技能 | 推荐学习路径 |
| --- | --- | --- |
| **Web开发** | Django/Flask/FastAPI | 后端开发 → 微服务 → 云原生 |
| **数据科学** | NumPy/Pandas/Matplotlib | 数据分析 → 机器学习 → 深度学习 |
| **人工智能** | TensorFlow/PyTorch | 机器学习基础 → 深度学习 → 专业领域 |
| **自动化运维** | Ansible/Fabric | 脚本编写 → 系统管理 → DevOps |
| **爬虫开发** | Scrapy/Selenium | 网络编程 → 反爬虫 → 分布式爬虫 |

### 持续学习建议

1.  **关注Python官方文档和PEP**
2.  **参与Python社区和开源项目**
3.  **定期阅读优秀的Python代码**
4.  **实践项目驱动学习**
5.  **保持对新技术的敏感度**