# Git 使用指南

## 目录
- [Git 使用指南](#git-使用指南)
  - [目录](#目录)
  - [Git 简介](#git-简介)
    - [主要特点](#主要特点)
  - [基本概念](#基本概念)
  - [安装与配置](#安装与配置)
    - [安装 Git](#安装-git)
    - [基本配置](#基本配置)
    - [代理配置](#代理配置)
      - [Git 代理配置](#git-代理配置)
      - [环境变量代理配置](#环境变量代理配置)
      - [检查代理设置](#检查代理设置)
  - [基本操作](#基本操作)
    - [创建仓库](#创建仓库)
    - [提交更改](#提交更改)
    - [查看历史](#查看历史)
    - [撤销更改](#撤销更改)
      - [撤销工作区修改](#撤销工作区修改)
      - [撤销暂存区修改](#撤销暂存区修改)
      - [撤销提交操作](#撤销提交操作)
      - [撤销合并提交](#撤销合并提交)
      - [恢复已删除的提交](#恢复已删除的提交)
      - [撤销操作的比较](#撤销操作的比较)
      - [最佳实践](#最佳实践)
  - [分支管理](#分支管理)
    - [创建与切换分支](#创建与切换分支)
    - [合并分支](#合并分支)
    - [解决冲突](#解决冲突)
  - [远程操作](#远程操作)
    - [GitHub 访问令牌](#github-访问令牌)
    - [克隆仓库](#克隆仓库)
    - [推送更改](#推送更改)
    - [拉取更改](#拉取更改)
    - [远程仓库管理](#远程仓库管理)
    - [远程分支管理](#远程分支管理)
  - [高级操作](#高级操作)
    - [标签管理](#标签管理)
    - [子模块](#子模块)
    - [Cherry-Pick](#cherry-pick)
      - [基本用法](#基本用法)
      - [高级选项](#高级选项)
      - [实际应用场景](#实际应用场景)
      - [处理冲突](#处理冲突)
      - [最佳实践](#最佳实践-1)
    - [变基](#变基)
    - [储藏](#储藏)
  - [Git 工作流](#git-工作流)
    - [集中式工作流](#集中式工作流)
    - [功能分支工作流](#功能分支工作流)
    - [Gitflow 工作流](#gitflow-工作流)
    - [Forking 工作流](#forking-工作流)
  - [最佳实践](#最佳实践-2)
    - [提交规范](#提交规范)
    - [分支命名规范](#分支命名规范)
    - [Git Hooks](#git-hooks)
  - [常见问题与解决](#常见问题与解决)
    - [冲突解决](#冲突解决)
    - [撤销操作](#撤销操作)
    - [性能优化](#性能优化)
    - [连接不上远程仓库](#连接不上远程仓库)

## Git 简介

Git 是一个开源的分布式版本控制系统，由 Linus Torvalds（Linux 内核的创始人）在 2005 年创建，用于管理 Linux 内核的开发。Git 的设计目标是速度、数据完整性和对分布式工作流的支持。

### 主要特点

- **分布式系统**：每个开发者都拥有完整的代码仓库副本
- **强大的分支管理**：创建、合并和删除分支的操作非常快速和简单
- **数据完整性**：Git 使用 SHA-1 哈希算法确保数据完整性
- **高性能**：即使对于大型项目，Git 也能保持高效运行
- **开源免费**：Git 是在 GNU 通用公共许可证下发布的开源软件

## 基本概念

Git 的工作流程涉及以下几个关键区域：

```mermaid
graph TD
    A[工作区] -->|git add| B[暂存区]
    B -->|git commit| C[本地仓库]
    C -->|git push| D[远程仓库]
    D -->|git fetch| C
    C -->|git checkout| A
    D -->|git pull| A
```

- **工作区（Working Directory）**：你实际编辑文件的地方
- **暂存区（Staging Area/Index）**：临时存储你的更改
- **本地仓库（Local Repository）**：存储提交历史的地方
- **远程仓库（Remote Repository）**：托管在服务器上的仓库

## 安装与配置

### 安装 Git

**Linux (Debian/Ubuntu)**
```bash
sudo apt-get update
sudo apt-get install git
```

**Linux (Fedora)**
```bash
sudo dnf install git
```

**macOS**
```bash
# 使用 Homebrew
brew install git

# 或下载安装包
# https://git-scm.com/download/mac
```

**Windows**
- 下载并安装 Git for Windows：https://git-scm.com/download/win

### 基本配置

设置用户信息：
```bash
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

设置默认编辑器：
```bash
git config --global core.editor "vim"  # 或其他编辑器
```

查看配置：
```bash
git config --list
```

### 代理配置

在某些网络环境下，可能需要配置代理才能正常访问远程仓库。

#### Git 代理配置

**HTTP/HTTPS 代理**
```bash
# 设置 HTTP 代理
git config --global http.proxy http://proxyuser:proxypassword@proxy.server.com:port

# 设置 HTTPS 代理
git config --global https.proxy https://proxyuser:proxypassword@proxy.server.com:port

# 如果代理不需要认证
git config --global http.proxy http://proxy.server.com:port
git config --global https.proxy https://proxy.server.com:port
```

**SSH 代理**

在 `~/.ssh/config` 文件中添加：
```
Host github.com
    User git
    ProxyCommand nc -X connect -x proxy.server.com:port %h %p
```

**取消代理**
```bash
# 取消 HTTP 代理
git config --global --unset http.proxy

# 取消 HTTPS 代理
git config --global --unset https.proxy
```

**仅为特定域名设置代理**
```bash
# 仅为 github.com 设置代理
git config --global http.https://github.com.proxy http://proxy.server.com:port
```

#### 环境变量代理配置

**临时设置环境变量代理（当前会话有效）**
```bash
# Linux/macOS
export http_proxy="http://proxy.server.com:port"
export https_proxy="http://proxy.server.com:port"
export all_proxy="socks5://proxy.server.com:port"  # SOCKS 代理

# 带认证的代理
export http_proxy="http://username:password@proxy.server.com:port"
export https_proxy="http://username:password@proxy.server.com:port"

# Windows (CMD)
set http_proxy=http://proxy.server.com:port
set https_proxy=http://proxy.server.com:port

# Windows (PowerShell)
$env:http_proxy="http://proxy.server.com:port"
$env:https_proxy="http://proxy.server.com:port"
```

**永久设置环境变量代理**

*Linux/macOS*

在 `~/.bashrc` 或 `~/.zshrc` 文件中添加：
```bash
# HTTP/HTTPS 代理
export http_proxy="http://proxy.server.com:port"
export https_proxy="http://proxy.server.com:port"
export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com"

# SOCKS 代理
export all_proxy="socks5://proxy.server.com:port"
```

然后执行 `source ~/.bashrc` 或 `source ~/.zshrc` 使配置生效。

*macOS 系统级代理*
```bash
# 设置 HTTP 代理
networksetup -setwebproxy Wi-Fi proxy.server.com port [on/off] [username] [password]

# 设置 HTTPS 代理
networksetup -setsecurewebproxy Wi-Fi proxy.server.com port [on/off] [username] [password]

# 设置 SOCKS 代理
networksetup -setsocksfirewallproxy Wi-Fi proxy.server.com port [on/off] [username] [password]

# 启用/禁用代理
networksetup -setwebproxystate Wi-Fi on
networksetup -setwebproxystate Wi-Fi off
```

*Windows*

通过系统设置或以下命令设置：
```cmd
# 设置系统代理
netsh winhttp set proxy proxy-server="http=proxy.server.com:port;https=proxy.server.com:port" bypass-list="localhost,127.0.0.1"

# 重置系统代理
netsh winhttp reset proxy
```

#### 检查代理设置

**检查当前代理设置**
```bash
# 检查 Git 的代理设置
git config --global --get http.proxy
git config --global --get https.proxy

# 检查 Mac 系统全局代理设置
# 查看 HTTP 代理
networksetup -getwebproxy Wi-Fi

# 查看 HTTPS 代理
networksetup -getsecurewebproxy Wi-Fi

# 查看 SOCKS 代理
networksetup -getsocksfirewallproxy Wi-Fi

# 列出所有网络接口
networksetup -listallnetworkservices

# 检查环境变量中的代理设置
echo $http_proxy
echo $https_proxy
echo $all_proxy
```

**测试代理连接**
```bash
# 使用 curl 测试代理
curl -v -x http://proxy.server.com:port https://www.google.com

# 使用 wget 测试代理
wget -e use_proxy=yes -e http_proxy=http://proxy.server.com:port https://www.google.com
```

## 基本操作

### 创建仓库

**初始化新仓库**
```bash
git init
```

**克隆现有仓库**
```bash
git clone https://github.com/username/repository.git
```

### 提交更改

**查看状态**
```bash
git status
```

**添加文件到暂存区**
```bash
# 添加单个文件
git add filename

# 添加所有更改
git add .
```

**提交更改**
```bash
git commit -m "提交说明"

# 跳过暂存区直接提交
git commit -a -m "提交说明"
```

### 查看历史

**查看提交历史**
```bash
# 基本日志
git log

# 简洁日志
git log --oneline

# 图形化显示
git log --graph --oneline --decorate

# 查看特定文件的历史
git log -- filename
```

**查看文件差异**
```bash
# 工作区与暂存区的差异
git diff

# 暂存区与最后一次提交的差异
git diff --staged

# 两次提交之间的差异
git diff commit1 commit2
```

### 撤销更改

#### 撤销工作区修改
```bash
# 撤销单个文件的修改
git checkout -- filename

# 撤销所有工作区的修改
git checkout -- .
```

#### 撤销暂存区修改
```bash
# 撤销单个文件的暂存
git reset HEAD filename

# 撤销所有暂存的修改
git reset HEAD
```

#### 撤销提交操作

**1. 修改最后一次提交**
```bash
# 修改最后一次提交的信息
git commit --amend -m "新的提交信息"

# 向最后一次提交添加更多更改
git add forgotten-file.txt
git commit --amend --no-edit  # 不修改提交信息
```

**2. 撤销本地提交**
```bash
# 保留工作区更改，撤销最近一次提交
git reset --soft HEAD~1

# 保留工作区更改，撤销最近三次提交
git reset --soft HEAD~3

# 丢弃工作区更改，撤销最近一次提交
git reset --hard HEAD~1

# 撤销到特定提交
git reset --soft <commit-hash>  # 保留更改
git reset --hard <commit-hash>  # 丢弃更改
```

**3. 创建新提交来撤销之前的提交**
```bash
# 撤销特定的提交，但保留提交历史
git revert <commit-hash>

# 撤销多个提交
git revert <oldest-commit-hash>..<newest-commit-hash>

# 撤销但不自动创建提交
git revert -n <commit-hash>
```

**4. 撤销已推送的提交**
```bash
# 方法1: 使用revert（推荐，因为不改变历史）
git revert <commit-hash>
git push origin <branch-name>

# 方法2: 使用reset后强制推送（慎用，会改变历史）
git reset --hard <commit-hash>
git push --force origin <branch-name>
```

#### 撤销合并提交
```bash
# 撤销一个合并提交
git revert -m 1 <merge-commit-hash>  # -m 1 表示保留主分支线
```

#### 恢复已删除的提交
```bash
# 查看操作历史，包括已"删除"的提交
git reflog

# 恢复到特定操作
git reset --hard <reflog-entry>  # 例如 HEAD@{2}
```

#### 撤销操作的比较

| 命令 | 作用范围 | 是否修改历史 | 适用场景 |
|------|---------|------------|---------|
| `git checkout -- <file>` | 工作区 | ❌ 否 | 撤销未暂存的修改 |
| `git reset HEAD <file>` | 暂存区 | ❌ 否 | 撤销已暂存的修改 |
| `git commit --amend` | 最后一次提交 | ✅ 是 | 修改最后一次提交 |
| `git reset --soft HEAD~n` | 本地提交 | ✅ 是 | 撤销提交但保留更改 |
| `git reset --hard HEAD~n` | 本地提交 | ✅ 是 | 撤销提交并丢弃更改 |
| `git revert <commit>` | 任意提交 | ❌ 否 | 撤销提交但保留历史 |
| `git push --force` | 远程提交 | ✅ 是 | 覆盖远程历史（慎用） |

#### 最佳实践

1. **优先使用 revert**：对于已推送的提交，优先使用 `git revert` 而不是 `git reset`，避免改变共享历史
2. **慎用 force push**：只在私有分支或确保其他人未基于该分支工作时使用
3. **使用 reflog 恢复**：如果意外执行了错误的撤销操作，可以通过 `git reflog` 恢复
4. **撤销前先创建分支**：在执行大规模撤销操作前，先创建一个备份分支
   ```bash
   git branch backup-branch
   ```
5. **提交前检查**：使用 `git diff --staged` 检查暂存区，减少需要撤销的情况

## 分支管理

分支是 Git 的核心功能之一，允许开发者在不影响主代码库的情况下进行开发。

```mermaid
graph LR
    A[master] -->|git branch feature| B[feature]
    B -->|开发| C[feature修改]
    C -->|git checkout master| A
    C -->|git merge feature| D[合并后master]
```

### 创建与切换分支

**列出所有分支**
```bash
git branch
```

**创建新分支**
```bash
git branch branch-name
```

**切换分支**
```bash
git checkout branch-name

# 创建并切换到新分支
git checkout -b branch-name
```

**使用 switch 切换分支（Git 2.23+）**
```bash
git switch branch-name

# 创建并切换到新分支
git switch -c branch-name
```

### 合并分支

**合并分支**
```bash
# 切换到目标分支
git checkout master

# 合并其他分支到当前分支
git merge branch-name
```

**使用 --no-ff 创建合并提交**
```bash
git merge --no-ff branch-name
```

### 解决冲突

当合并分支时，如果两个分支修改了同一个文件的同一部分，Git 无法自动合并，会产生冲突。

**解决冲突步骤**
1. Git 会在冲突文件中标记冲突区域
   ```
   <<<<<<< HEAD
   当前分支的修改
   =======
   要合并分支的修改
   >>>>>>> branch-name
   ```
2. 手动编辑文件解决冲突
3. 添加解决后的文件到暂存区
   ```bash
   git add filename
   ```
4. 完成合并提交
   ```bash
   git commit
   ```

## 远程操作

### GitHub 访问令牌

使用 GitHub 时，访问令牌（Personal Access Token, PAT）可以替代密码进行身份验证，提供更好的安全性和更细粒度的权限控制。

**创建 GitHub 访问令牌**

1. **登录 GitHub 账户**
   - 访问 https://github.com 并登录

2. **访问设置页面**
   ```
   点击右上角头像 -> Settings -> Developer settings -> Personal access tokens -> Tokens (classic)
   ```

3. **生成新令牌**
   ```
   点击 "Generate new token" -> "Generate new token (classic)"
   ```

4. **配置令牌**
   - 填写令牌名称（Note）
   - 选择过期时间（Expiration）
   - 选择所需权限（Scopes）：
     - 对于大多数 Git 操作，至少需要 `repo` 权限
     - 对于私有仓库，选择 `repo` 全部权限
     - 对于公共仓库，`public_repo` 权限可能足够

5. **生成并保存令牌**
   ```
   点击页面底部的 "Generate token"
   立即复制并安全保存生成的令牌（离开页面后将无法再次查看完整令牌）
   ```

**使用 GitHub 访问令牌**

**配置 Git 使用令牌**

1. **在 URL 中使用令牌**
   ```bash
   # 克隆仓库时使用令牌
   git clone https://username:token@github.com/username/repository.git
   
   # 修改现有仓库的远程 URL
   git remote set-url origin https://username:token@github.com/username/repository.git
   ```

2. **使用凭证存储**
   ```bash
   # 配置凭证助手
   git config --global credential.helper store
   
   # 下次 Git 操作需要认证时，输入用户名和令牌（而不是密码）
   # Git 将保存凭证，后续操作无需再次输入
   ```

3. **使用 SSH 密钥代替令牌**
   - 如果频繁使用 GitHub，建议配置 SSH 密钥认证，完全避免使用令牌或密码

**管理 GitHub 访问令牌**

**查看和撤销令牌**
```
Settings -> Developer settings -> Personal access tokens -> Tokens (classic)
```

**令牌安全最佳实践**
- 永远不要在公共代码中硬编码令牌
- 定期轮换令牌（例如每 3-6 个月）
- 为不同项目或用途创建不同的令牌
- 遵循最小权限原则，只授予必要的权限
- 考虑使用环境变量存储令牌
  ```bash
  # 设置环境变量
  export GITHUB_TOKEN="your_token_here"
  
  # 配置 Git 使用环境变量
  git config --global credential.helper '!f() { echo "username=${GITHUB_USERNAME}"; echo "password=${GITHUB_TOKEN}"; }; f'
  ```

**解决 GitHub 认证失败问题**

当遇到 `fatal: Authentication failed for 'https://github.com/username/repository.git/'` 错误时，可以尝试以下解决方法：

1. **检查凭证**
   ```bash
   # 查看已保存的凭证
   git config --global credential.helper
   
   # macOS
   git credential-osxkeychain get
   host=github.com
   protocol=https
   
   # Windows
   cmdkey /list:git:https://github.com
   
   # 删除已保存的凭证
   # macOS
   git credential-osxkeychain erase
   host=github.com
   protocol=https
   
   # Windows
   cmdkey /delete:git:https://github.com
   
   # Linux
   git credential-cache exit  # 如果使用 cache
   # 或编辑 ~/.git-credentials 文件删除对应条目
   ```

2. **更新访问令牌**
   - 检查令牌是否已过期或被撤销
   - 在 GitHub 上创建新的访问令牌
   - 使用新令牌更新本地凭证

3. **使用正确的认证格式**
   ```bash
   # 确保使用正确的用户名和令牌
   git remote set-url origin https://username:token@github.com/username/repository.git
   ```

4. **检查双重认证 (2FA)**
   - 如果启用了双重认证，必须使用访问令牌而不是密码
   - 确保令牌有足够的权限

5. **检查网络和代理设置**
   ```bash
   # 检查 Git 是否可以连接到 GitHub
   ssh -T git@github.com  # 如果使用 SSH
   curl -i https://github.com  # 检查 HTTPS 连接
   
   # 如果使用代理，确保代理设置正确
   git config --global --get http.proxy
   git config --global --get https.proxy
   ```

6. **尝试使用 SSH 而不是 HTTPS**
   ```bash
   # 生成 SSH 密钥
   ssh-keygen -t ed25519 -C "your_email@example.com"
   
   # 将公钥添加到 GitHub
   # 复制 ~/.ssh/id_ed25519.pub 的内容到 GitHub -> Settings -> SSH and GPG keys
   
   # 更改远程 URL 为 SSH
   git remote set-url origin git@github.com:username/repository.git
   ```

7. **使用凭证管理器**
   ```bash
   # 在 Windows 上安装 Git Credential Manager
   git config --global credential.helper manager
   
   # 在 macOS 上使用 Keychain
   git config --global credential.helper osxkeychain
   
   # 在 Linux 上使用缓存
   git config --global credential.helper 'cache --timeout=3600'
   ```

8. **检查 Git 版本**
   ```bash
   git --version
   # 确保使用最新版本的 Git，旧版本可能有认证问题
   ```

### 克隆仓库

```bash
git clone https://github.com/username/repository.git

# 指定本地目录名
git clone https://github.com/username/repository.git local-dir

# 克隆特定分支
git clone -b branch-name https://github.com/username/repository.git
```

### 推送更改

**添加远程仓库**
```bash
git remote add origin https://github.com/username/repository.git
```

**查看远程仓库**
```bash
git remote -v
```

**推送到远程仓库**
```bash
# 推送到 origin 的 master 分支
git push origin master

# 设置上游分支并推送
git push -u origin master

# 强制推送（慎用）
git push --force origin master
```

### 拉取更改

**获取远程更新**
```bash
# 只获取更新，不合并
git fetch origin

# 获取所有分支的更新
git fetch --all
```

**拉取并合并远程更新**
```bash
git pull origin master

# 相当于 git fetch + git merge
```

**使用变基方式拉取**
```bash
git pull --rebase origin master
```

### 远程仓库管理

**查看远程仓库**
```bash
# 列出所有远程仓库
git remote -v

# 查看特定远程仓库的详细信息
git remote show origin
```

**添加远程仓库**
```bash
# 添加新的远程仓库
git remote add <name> <url>

# 示例
git remote add origin https://github.com/username/repository.git
git remote add upstream https://github.com/original-owner/original-repository.git
```

**修改远程仓库**
```bash
# 修改远程仓库的 URL
git remote set-url <name> <new-url>

# 示例
git remote set-url origin https://github.com/username/new-repository.git

# 修改远程仓库的名称
git remote rename <old-name> <new-name>

# 示例
git remote rename origin github
```

**删除远程仓库**
```bash
git remote remove <name>

# 示例
git remote remove upstream
```

**多个远程仓库工作流**
```bash
# 添加多个远程仓库
git remote add github https://github.com/username/repository.git
git remote add gitlab https://gitlab.com/username/repository.git

# 从不同远程仓库拉取
git pull github main
git pull gitlab main

# 推送到不同远程仓库
git push github main
git push gitlab main
```

**修改远程仓库 URL 协议**
```bash
# 从 HTTPS 切换到 SSH
git remote set-url origin git@github.com:username/repository.git

# 从 SSH 切换到 HTTPS
git remote set-url origin https://github.com/username/repository.git
```

**设置上游分支**
```bash
# 设置本地分支跟踪的远程分支
git branch --set-upstream-to=origin/main main

# 或在推送时设置
git push -u origin main
```

### 远程分支管理

**查看远程分支**
```bash
git branch -r
```

**查看所有分支（本地和远程）**
```bash
git branch -a
```

**创建跟踪远程分支的本地分支**
```bash
git checkout -b local-branch origin/remote-branch

# 或使用 Git 2.23+ 的新命令
git switch -c local-branch origin/remote-branch
```

**删除远程分支**
```bash
git push origin --delete branch-name
```

**清理过时的远程跟踪分支**
```bash
# 删除远程仓库中已经不存在的分支引用
git fetch --prune

# 或者在 fetch 时自动清理
git config --global fetch.prune true
```

## 高级操作

### 标签管理

标签通常用于标记重要的提交点，如发布版本。

**创建标签**
```bash
# 轻量标签
git tag v1.0.0

# 附注标签
git tag -a v1.0.0 -m "Version 1.0.0"

# 为特定提交创建标签
git tag -a v1.0.0 -m "Version 1.0.0" commit-id
```

**查看标签**
```bash
# 列出所有标签
git tag

# 查看标签详情
git show v1.0.0
```

**推送标签到远程**
```bash
# 推送特定标签
git push origin v1.0.0

# 推送所有标签
git push origin --tags
```

**删除标签**
```bash
# 删除本地标签
git tag -d v1.0.0

# 删除远程标签
git push origin :refs/tags/v1.0.0
```

### 子模块

子模块允许你在一个 Git 仓库中包含其他 Git 仓库作为子目录。

**添加子模块**
```bash
git submodule add https://github.com/username/repository.git path/to/submodule
```

**初始化子模块**
```bash
git submodule init
```

**更新子模块**
```bash
git submodule update

# 初始化并更新所有子模块
git submodule update --init --recursive
```

### Cherry-Pick

Cherry-pick 允许你选择特定的提交并应用到当前分支，非常适合从一个分支选择性地将某些更改移植到另一个分支。

#### 基本用法

```bash
# 将指定的提交应用到当前分支
git cherry-pick <commit-hash>

# 应用多个提交
git cherry-pick <commit-hash1> <commit-hash2>

# 应用一个提交范围（不包含start-commit）
git cherry-pick <start-commit>..<end-commit>

# 应用一个提交范围（包含start-commit）
git cherry-pick <start-commit>^..<end-commit>
```

#### 高级选项

```bash
# 只获取更改但不自动提交，保留在暂存区
git cherry-pick -n <commit-hash>

# 遇到冲突时继续，而不是中止整个操作
git cherry-pick --continue

# 中止当前的cherry-pick操作
git cherry-pick --abort

# 保留原始提交者信息
git cherry-pick -x <commit-hash>

# 添加签名
git cherry-pick -S <commit-hash>

# 编辑提交信息
git cherry-pick -e <commit-hash>
```

#### 实际应用场景

**场景1：将热修复从修复分支应用到主分支**

```bash
# 1. 在hotfix分支上完成修复
git checkout hotfix
# ... 修复bug并提交 ...
git commit -m "Fix critical bug #123"

# 2. 记下提交的哈希值
git log -1  # 假设提交哈希为abc123

# 3. 切换到主分支并应用修复
git checkout main
git cherry-pick abc123

# 4. 如果遇到冲突，解决后继续
# ... 解决冲突 ...
git add <冲突文件>
git cherry-pick --continue
```

**场景2：从功能分支选择性地应用某些提交**

```bash
# 1. 查看功能分支上的提交
git checkout feature-branch
git log --oneline  # 假设有提交 abc123, def456, ghi789

# 2. 切换到目标分支
git checkout develop

# 3. 只应用其中的某些提交
git cherry-pick def456 ghi789

# 4. 或者应用一个范围的提交
git cherry-pick abc123^..ghi789  # 从abc123到ghi789的所有提交（包含abc123）
```

**场景3：将提交应用到多个分支**

```bash
# 假设你在feature分支上有一个提交abc123需要应用到多个版本分支

# 应用到版本1分支
git checkout v1.0-stable
git cherry-pick abc123

# 应用到版本2分支
git checkout v2.0-stable
git cherry-pick abc123
```

#### 处理冲突

当cherry-pick操作遇到冲突时：

1. Git会暂停操作，并标记冲突文件
2. 手动解决冲突文件
3. 使用`git add`将解决后的文件添加到暂存区
4. 使用`git cherry-pick --continue`继续操作

```bash
# 遇到冲突后
git status  # 查看冲突文件

# 编辑冲突文件解决冲突
vim <conflict-file>

# 标记为已解决
git add <conflict-file>

# 继续cherry-pick操作
git cherry-pick --continue

# 如果想放弃此次操作
git cherry-pick --abort
```

#### 最佳实践

1. **先拉取最新代码**：在进行cherry-pick前，确保当前分支已更新到最新
2. **小批量操作**：一次处理少量提交，便于处理可能的冲突
3. **保留原始提交信息**：使用`-x`选项记录原始提交来源
4. **验证结果**：cherry-pick后测试代码，确保功能正常
5. **避免重复cherry-pick**：使用分支标记或笔记跟踪已经应用的提交
6. **优先使用merge**：如果需要应用大量连续提交，考虑使用merge而不是cherry-pick

### 变基

变基（Rebase）是一种整合来自不同分支工作的方式，通过修改提交历史使其更加线性。

```bash
# 在 feature 分支上变基到 master
git checkout feature
git rebase master

# 交互式变基
git rebase -i HEAD~3  # 修改最近3次提交
```

### 储藏

储藏（Stash）可以暂时保存未提交的更改，以便你可以切换到其他任务。

```bash
# 储藏当前更改
git stash

# 储藏时添加说明
git stash save "WIP: 功能开发中"

# 查看储藏列表
git stash list

# 应用最近的储藏
git stash apply

# 应用特定的储藏
git stash apply stash@{2}

# 应用并删除最近的储藏
git stash pop

# 删除特定的储藏
git stash drop stash@{2}

# 清除所有储藏
git stash clear
```

## Git 工作流

### 集中式工作流

所有开发者直接在 master 分支上工作，类似于 SVN 的工作方式。

**优点**：简单易懂
**缺点**：容易产生冲突，不适合大型项目

### 功能分支工作流

每个新功能都在专门的分支上开发，完成后合并到 master。

**流程**：
1. 从 master 创建功能分支
2. 在功能分支上开发
3. 提交到远程功能分支
4. 创建 Pull Request
5. 代码审查后合并到 master

### Gitflow 工作流

一个更加严格的分支模型，适合有计划发布周期的项目。

**主要分支**：
- `master`：存储官方发布历史
- `develop`：集成开发分支
- `feature/*`：新功能开发
- `release/*`：发布准备
- `hotfix/*`：生产环境紧急修复

**流程**：
1. 从 `develop` 创建 `feature` 分支
2. 完成功能后合并回 `develop`
3. 从 `develop` 创建 `release` 分支
4. 测试和修复 bug 后合并到 `master` 和 `develop`
5. 如需紧急修复，从 `master` 创建 `hotfix` 分支
6. 修复后合并回 `master` 和 `develop`

### Forking 工作流

适合开源项目，每个开发者都有自己的服务器端仓库副本。

**流程**：
1. 开发者 fork 主仓库
2. 克隆个人 fork 到本地
3. 添加原始仓库为远程仓库（upstream）
4. 创建功能分支
5. 提交到个人 fork
6. 创建 Pull Request 到主仓库
7. 项目维护者审查并合并更改

## 最佳实践

### 提交规范

**提交信息格式**
```
<类型>(<范围>): <主题>

<正文>

<页脚>
```

**常用类型**：
- `feat`：新功能
- `fix`：修复 bug
- `docs`：文档更改
- `style`：不影响代码含义的更改（空格、格式化等）
- `refactor`：既不修复 bug 也不添加功能的代码更改
- `perf`：性能优化
- `test`：添加或修正测试
- `chore`：对构建过程或辅助工具的更改

**示例**：
```
feat(auth): 添加用户认证功能

实现了基于JWT的用户认证系统，包括登录、注册和密码重置功能。

Closes #123
```

### 分支命名规范

- `feature/<feature-name>`：新功能
- `bugfix/<bug-name>`：Bug 修复
- `hotfix/<fix-name>`：紧急修复
- `release/<version>`：发布准备
- `docs/<doc-name>`：文档更新
- `refactor/<refactor-name>`：代码重构

### Git Hooks

Git Hooks 是在特定 Git 事件发生时自动执行的脚本。

**常用 Hooks**：
- `pre-commit`：提交前执行，可用于代码检查
- `commit-msg`：检查提交信息
- `pre-push`：推送前执行，可用于运行测试

**使用 Husky 管理 Hooks**：
```bash
# 安装 Husky
npm install husky --save-dev

# 配置 package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  }
}
```

## 常见问题与解决

### 冲突解决

**使用图形化工具**
```bash
git mergetool
```

**放弃合并**
```bash
git merge --abort
```

**使用 `--ours` 或 `--theirs` 选择一方的更改**
```bash
git checkout --ours filename
git checkout --theirs filename
```

### 撤销操作

**撤销公共提交**

创建一个新的提交来撤销之前的更改：
```bash
git revert commit-id
```

**修改提交历史**

如果提交尚未推送到远程：
```bash
# 修改最后一次提交
git commit --amend

# 重写多个提交
git rebase -i HEAD~3
```

**恢复已删除的分支**
```bash
# 查找分支指向的提交
git reflog

# 基于该提交创建新分支
git branch branch-name commit-id
```

### 性能优化

**大型仓库优化**
```bash
# 压缩仓库
git gc

# 清理不必要的文件
git prune

# 验证仓库完整性
git fsck
```

**使用浅克隆**
```bash
# 只获取最近的历史
git clone --depth=1 repository-url
```

**部分克隆**
```bash
# 只克隆特定目录
git clone --filter=blob:none --sparse repository-url
cd repository
git sparse-checkout set dir1 dir2
```

**配置 Git LFS**

对于大型二进制文件，使用 Git Large File Storage：
```bash
# 安装 Git LFS
git lfs install

# 跟踪大文件
git lfs track "*.psd"

# 确保 .gitattributes 被提交
git add .gitattributes
``` 


### 连接不上远程仓库

推送代码显示连接超市，但是网页能访问github。
```bash
$ git clone git@github.com:ralph-wren/ai_bot.git Cloning into 'ai_bot'... kex_exchange_identification: read: Software caused connection abort banner exchange: Connection to 20.205.243.166 port 22: Software caused connection abort fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.
```

**修复方式**
改用 SSH 的 443 端口（绕过被封的 22）
先编辑配置：
```bash
vim ~/.ssh/config
```
添加以下内容：
```bash
Host github.com
  HostName ssh.github.com
  Port 443
  User git
```
保存后尝试重新推送