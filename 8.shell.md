# Shell 命令参考手册

## 目录
- [Shell 命令参考手册](#shell-命令参考手册)
  - [目录](#目录)
  - [文件操作](#文件操作)
    - [文件查找与过滤](#文件查找与过滤)
    - [文件处理](#文件处理)
    - [文件压缩](#文件压缩)
  - [HDFS操作](#hdfs操作)
    - [文件查看](#文件查看)
    - [文件大小统计](#文件大小统计)
  - [文本处理](#文本处理)
    - [文件读取](#文件读取)
    - [文本过滤](#文本过滤)
  - [控制结构](#控制结构)
    - [条件判断](#条件判断)
    - [分支语句](#分支语句)
    - [循环语句](#循环语句)
    - [函数定义](#函数定义)
    - [信号与异常处理](#信号与异常处理)
  - [字符串处理](#字符串处理)
    - [字符串基本操作](#字符串基本操作)
    - [字符串截取与替换](#字符串截取与替换)
    - [字符串转换](#字符串转换)
    - [字符串比较与判断](#字符串比较与判断)
    - [正则表达式处理](#正则表达式处理)
  - [进程管理](#进程管理)
  - [时间处理](#时间处理)
  - [网络请求](#网络请求)
  - [实用工具](#实用工具)

## 文件操作

### 文件查找与过滤
```bash
# 查找目录下以8位数字结尾的文件（YYYYMMDD格式）
find /path/to/dir -type f -regextype posix-extended -regex '.*[0-9]{8}$'

# 检查文件是否存在
if [ ! -f "$file" ]; then
    echo "File not found: $file"
    exit 1
fi
```

### 文件处理
```bash
# 分割大文件
split -b 10M large_file.txt output_

# 合并文件
cat output_* > combined_file.txt
```

### 文件压缩
```bash
# 压缩文件
gzip a.txt          # 压缩并删除原文件
gzip -c a.txt       # 压缩并保留原文件

# 解压文件
gunzip your_file.txt.gz
```

## HDFS操作

### 文件查看
```bash
# 列出HDFS目录下以8位数字结尾的文件
hadoop fs -ls /path/to/dir | awk '$NF ~ /[0-9]{8}$/ {print $NF}'

# 使用grep过滤HDFS目录
hadoop fs -ls /data/dept/bi/dim/data | grep -E "[0-9]{8}$"
```

### 文件大小统计
```bash
# 获取目录文件大小并选择最后一行
hadoop fs -du -h $line | tail -n 1 >> file_size_result.txt
```

## 文本处理

### 文件读取
```bash
# 遍历文件每一行
file="example.txt"
while IFS= read -r line; do
    echo "$line"
done < "$file"

# 另一种读取方式
cat "$file" | while read line; do
    echo "$line"
done
```

### 文本过滤
```bash
# 查看grep过滤结果的前100个字符
grep "关键词" file.txt | cut -c 1-100

# 显示匹配行及其后5行
curl -s "http://localhost:8080/hotsearch" | grep -A 5 "wallpaper-menu"
```

## 控制结构

### 条件判断

**文件测试**
```bash
# 文件存在性测试
[ -e file.txt ] && echo "文件存在"
[ -f file.txt ] && echo "文件存在且是普通文件"
[ -d dir ] && echo "目录存在"
[ -L symlink ] && echo "符号链接存在"
[ -r file.txt ] && echo "文件可读"
[ -w file.txt ] && echo "文件可写"
[ -x file.txt ] && echo "文件可执行"
[ -s file.txt ] && echo "文件大小不为0"

# 文件比较
[ file1 -nt file2 ] && echo "file1比file2新"
[ file1 -ot file2 ] && echo "file1比file2旧"
```

**数值比较**
```bash
# 使用 [ ] 进行数值比较
[ $a -eq $b ] && echo "a等于b"
[ $a -ne $b ] && echo "a不等于b"
[ $a -gt $b ] && echo "a大于b"
[ $a -lt $b ] && echo "a小于b"
[ $a -ge $b ] && echo "a大于等于b"
[ $a -le $b ] && echo "a小于等于b"

# 使用 (( )) 进行数学表达式比较
(( a == b )) && echo "a等于b"
(( a != b )) && echo "a不等于b"
(( a > b )) && echo "a大于b"
(( a < b )) && echo "a小于b"
(( a >= b )) && echo "a大于等于b"
(( a <= b )) && echo "a小于等于b"
```

**字符串比较**
```bash
# 字符串比较
[ "$str1" = "$str2" ] && echo "字符串相等"
[ "$str1" != "$str2" ] && echo "字符串不相等"
[ -z "$str" ] && echo "字符串为空"
[ -n "$str" ] && echo "字符串非空"

# 使用 [[ ]] 进行模式匹配
[[ "$str" == *pattern* ]] && echo "字符串匹配模式"
[[ "$str" =~ ^[0-9]+$ ]] && echo "字符串全为数字"
```

**逻辑运算**
```bash
# 与运算
[ condition1 ] && [ condition2 ] && echo "两个条件都为真"

# 或运算
[ condition1 ] || [ condition2 ] && echo "至少一个条件为真"

# 非运算
[ ! condition ] && echo "条件为假"

# 组合条件
[ condition1 -a condition2 ] && echo "两个条件都为真"
[ condition1 -o condition2 ] && echo "至少一个条件为真"
```

### 分支语句

**if-else语句**
```bash
# 基本if语句
if [ $count -gt 10 ]; then
    echo "Count is greater than 10"
fi

# if-else语句
if [ $count -gt 10 ]; then
    echo "Count is greater than 10"
else
    echo "Count is less than or equal to 10"
fi

# if-elif-else语句
if [ $count -gt 10 ]; then
    echo "Count is greater than 10"
elif [ $count -eq 10 ]; then
    echo "Count is equal to 10"
else
    echo "Count is less than 10"
fi

# 单行if语句
[ $count -gt 10 ] && echo "Count is greater than 10"
[ $count -gt 10 ] || echo "Count is less than or equal to 10"
```

**case语句**
```bash
# 基本case语句
case "$option" in
    start)
        echo "Starting service..."
        start_service
        ;;
    stop)
        echo "Stopping service..."
        stop_service
        ;;
    restart)
        echo "Restarting service..."
        restart_service
        ;;
    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
        ;;
esac

# 使用模式匹配
case "$filename" in
    *.jpg|*.jpeg|*.png)
        echo "图像文件"
        ;;
    *.mp3|*.wav|*.ogg)
        echo "音频文件"
        ;;
    *.mp4|*.avi|*.mkv)
        echo "视频文件"
        ;;
    *)
        echo "其他类型文件"
        ;;
esac

# 使用正则表达式 (Bash 4.0+)
case "$string" in
    [0-9]*)
        echo "以数字开头"
        ;;
    [A-Za-z]*)
        echo "以字母开头"
        ;;
    *)
        echo "以其他字符开头"
        ;;
esac
```

### 循环语句

**for循环**
```bash
# 基本for循环
for i in 1 2 3 4 5; do
    echo "Number: $i"
done

# 使用序列
for i in {1..5}; do
    echo "Number: $i"
done

# 带步长的序列 (Bash 4.0+)
for i in {1..10..2}; do
    echo "Odd number: $i"
done

# C风格for循环
for ((i=1; i<=5; i++)); do
    echo "Count: $i"
done

# 遍历文件列表
for file in *.txt; do
    echo "Processing $file"
done

# 遍历命令输出
for line in $(cat file.txt); do
    echo "Line: $line"
done

# 遍历数组
array=("item1" "item2" "item3")
for item in "${array[@]}"; do
    echo "Array item: $item"
done
```

**while循环**
```bash
# 基本while循环
count=1
while [ $count -le 5 ]; do
    echo "Count: $count"
    ((count++))
done

# 读取文件每一行
while read -r line; do
    echo "Line: $line"
done < file.txt

# 无限循环
while true; do
    echo "Press Ctrl+C to stop"
    sleep 1
done

# 带条件的无限循环
while :; do
    echo "Another infinite loop"
    sleep 1
done

# 处理命令输出
ls -la | while read -r line; do
    echo "File info: $line"
done
```

**until循环**
```bash
# 基本until循环 (直到条件为真才停止)
count=1
until [ $count -gt 5 ]; do
    echo "Count: $count"
    ((count++))
done

# 等待文件出现
until [ -f "expected_file.txt" ]; do
    echo "Waiting for file to appear..."
    sleep 5
done
echo "File found!"
```

**循环控制**
```bash
# break语句 - 跳出循环
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Breaking at $i"
        break
    fi
    echo "Number: $i"
done

# continue语句 - 跳过当前迭代
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Skipping $i"
        continue
    fi
    echo "Number: $i"
done

# 多层循环中的break和continue
for i in {1..3}; do
    for j in {1..3}; do
        if [ $i -eq 2 ] && [ $j -eq 2 ]; then
            echo "Breaking inner loop at i=$i, j=$j"
            break
        fi
        echo "i=$i, j=$j"
    done
done

# 带标签的break (Bash 不支持，但可以用其他方式实现)
outer_loop=true
for i in {1..3}; do
    for j in {1..3}; do
        if [ $i -eq 2 ] && [ $j -eq 2 ]; then
            echo "Breaking both loops at i=$i, j=$j"
            outer_loop=false
            break
        fi
        echo "i=$i, j=$j"
    done
    if ! $outer_loop; then
        break
    fi
done
```

### 函数定义

**基本函数**
```bash
# 定义函数
hello() {
    echo "Hello, World!"
}

# 调用函数
hello

# 带参数的函数
greet() {
    echo "Hello, $1!"
}

greet "John"  # 输出: Hello, John!

# 返回值
is_even() {
    if (( $1 % 2 == 0 )); then
        return 0  # 成功 (true)
    else
        return 1  # 失败 (false)
    fi
}

if is_even 4; then
    echo "4 is even"
else
    echo "4 is odd"
fi

# 函数输出作为返回值
get_date() {
    echo $(date +%Y-%m-%d)
}

today=$(get_date)
echo "Today is $today"

# 局部变量
calculate() {
    local result=$(( $1 + $2 ))
    echo "The sum of $1 and $2 is $result"
}

calculate 5 3
```

**高级函数特性**
```bash
# 默认参数
default_param() {
    local name=${1:-"Guest"}
    echo "Hello, $name!"
}

default_param         # 输出: Hello, Guest!
default_param "John"  # 输出: Hello, John!

# 可变参数
process_all() {
    echo "Processing $# parameters"
    for param in "$@"; do
        echo "- $param"
    done
}

process_all apple banana cherry

# 递归函数
factorial() {
    if [ $1 -le 1 ]; then
        echo 1
    else
        local prev=$(factorial $(( $1 - 1 )))
        echo $(( $1 * prev ))
    done
}

result=$(factorial 5)
echo "5! = $result"  # 输出: 5! = 120
```

### 信号与异常处理

**捕获信号**
```bash
# 捕获SIGINT信号 (Ctrl+C)
trap 'echo "Caught Ctrl+C - Exiting gracefully"; exit' INT

# 捕获多个信号
trap 'echo "Cleaning up..."; rm -f temp_*; exit' EXIT INT TERM

# 在脚本退出时执行清理操作
cleanup() {
    echo "Performing cleanup..."
    rm -f /tmp/tempfile_$$
}
trap cleanup EXIT

# 忽略信号
trap '' INT  # 忽略Ctrl+C

# 恢复默认处理
trap - INT   # 恢复Ctrl+C的默认行为
```

**错误处理**
```bash
# 出错时退出
set -e  # 任何命令返回非零状态时脚本将退出

# 管道错误检测
set -o pipefail  # 管道中任何命令失败时整个管道命令返回失败

# 未定义变量检测
set -u  # 使用未定义变量时脚本将退出

# 调试模式
set -x  # 执行前显示每个命令

# 组合使用
set -euo pipefail  # 严格模式

# 自定义错误处理
error_handler() {
    echo "Error occurred at line $1"
    exit 1
}
trap 'error_handler $LINENO' ERR
```

## 字符串处理

### 字符串基本操作
```bash
# 字符串定义
str="Hello World"
echo $str

# 字符串长度
echo ${#str}  # 输出: 11

# 字符串拼接
str1="Hello"
str2="World"
str3="$str1 $str2"  # 使用变量拼接
str4=$str1$str2     # 直接拼接
echo $str3  # 输出: Hello World
echo $str4  # 输出: HelloWorld

# 字符串重复
repeat_str=$(printf '%.s-' {1..10})
echo $repeat_str  # 输出: ----------
```

### 字符串截取与替换
```bash
# 字符串截取
str="Hello World"
echo ${str:0:5}    # 从索引0开始，截取5个字符，输出: Hello
echo ${str:6}      # 从索引6开始到结束，输出: World
echo ${str: -5}    # 从倒数第5个字符开始到结束，输出: World (注意空格)

# 字符串替换
str="Hello World"
echo ${str/World/Shell}  # 替换第一个匹配，输出: Hello Shell
echo ${str//l/L}         # 替换所有匹配，输出: HeLLo WorLd

# 字符串删除
file="example.tar.gz"
echo ${file#*.}     # 删除第一个.及其左边的字符，输出: tar.gz
echo ${file##*.}    # 删除最后一个.及其左边的字符，输出: gz
echo ${file%.*}     # 删除最后一个.及其右边的字符，输出: example.tar
echo ${file%%.*}    # 删除第一个.及其右边的字符，输出: example

# 字符串前缀和后缀处理
path="/usr/local/bin/bash"
echo ${path##*/}    # 获取文件名，输出: bash
echo ${path%/*}     # 获取目录路径，输出: /usr/local/bin
```

### 字符串转换
```bash
# 大小写转换
str="Hello World"
echo ${str^^}       # 全部转为大写，输出: HELLO WORLD
echo ${str,,}       # 全部转为小写，输出: hello world

# 首字母大写 (Bash 4.0+)
str="hello world"
echo ${str^}        # 首字母大写，输出: Hello world
echo ${str^^[hw]}   # 指定字符大写，输出: Hello World

# 使用tr命令转换大小写
echo "Hello World" | tr '[:lower:]' '[:upper:]'  # 输出: HELLO WORLD
echo "Hello World" | tr '[:upper:]' '[:lower:]'  # 输出: hello world

# 使用awk转换
echo "Hello World" | awk '{print toupper($0)}'  # 输出: HELLO WORLD
echo "Hello World" | awk '{print tolower($0)}'  # 输出: hello world
```

### 字符串比较与判断
```bash
# 字符串比较
str1="abc"
str2="def"

# 相等比较
if [ "$str1" = "$str2" ]; then
    echo "字符串相等"
else
    echo "字符串不相等"
fi

# 大小比较
if [[ "$str1" < "$str2" ]]; then
    echo "$str1 在字典序中小于 $str2"
fi

# 判断字符串是否为空
str=""
if [ -z "$str" ]; then
    echo "字符串为空"
fi

# 判断字符串是否非空
str="Hello"
if [ -n "$str" ]; then
    echo "字符串非空"
fi

# 判断字符串是否包含子串
str="Hello World"
substr="World"
if [[ "$str" == *"$substr"* ]]; then
    echo "字符串包含子串"
fi
```

### 正则表达式处理
```bash
# 使用=~操作符进行正则匹配
str="Hello 123 World"
if [[ $str =~ [0-9]+ ]]; then
    echo "字符串包含数字"
    echo "匹配的数字是: ${BASH_REMATCH[0]}"
fi

# 使用grep提取匹配内容
echo "Email: user@example.com" | grep -o '[a-zA-Z0-9._%+-]\+@[a-zA-Z0-9.-]\+\.[a-zA-Z]\{2,\}'

# 使用sed进行复杂替换
echo "Hello 123 World" | sed -E 's/([0-9]+)/(\1)/g'  # 输出: Hello (123) World

# 使用awk处理格式化字符串
echo "Name: John, Age: 30" | awk -F'[:,]' '{print "User " $2 " is " $4 " years old"}'

# 提取字符串中的数字
str="abc123def456"
echo $str | grep -o '[0-9]\+'  # 输出所有数字序列

# 验证字符串格式
validate_email() {
    local email=$1
    if [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        echo "有效的邮箱地址"
        return 0
    else
        echo "无效的邮箱地址"
        return 1
    fi
}

validate_email "user@example.com"
```

## 进程管理
```bash
# 查看特定进程
ps aux | grep pyspark
```

## 时间处理
```bash
# 获取当前时间戳（秒）
end_time=$(date +%s)

# 计算时间差
elapsed=$((end_time-start_time))
```




## 网络请求
```bash
# 循环发送curl请求
while IFS= read -r i; do
    response=$(curl -s -f --location \
        --request POST 'http://xxxx/api/v1/endpoint' \
        --header 'Content-Type: application/json' \
        -d '{
        "able":true
        }')
    
    if [ $? -eq 0 ]; then
        # 使用jq解析JSON
        unique_items=$(echo "$response" | jq -r '.data[].item' | sort -u)
        echo "Unique items for id $i:"
        echo "$unique_items"
        # 统计数量
        count=$(echo "$unique_items" | wc -l)
        echo "Total unique items: $count"
    else
        echo "Error fetching data for id $i" >&2
    fi
done < input.txt
```

## 实用工具
```bash
# 安装Python kernel
python -m ipykernel install --user --name openai --display-name "openai"
```
